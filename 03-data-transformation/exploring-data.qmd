# Daten kennenlernen {#sec-exploring-data}

```{r}
#| include: false
source("setup.R")
```

Ihr habt gelernt, wie ihr Daten aus verschiedenen Quellen laden kÃ¶nnt, und ihr kennt die Pipe als Werkzeug, um Schritte sauber aneinanderzureihen. Dieses Kapitel widmet sich dem nÃ¤chsten logischen Schritt: Euren Datensatz kennenzulernen, bevor ihr ihn verÃ¤ndert. Wir befassen uns damit, wie ihr die GrÃ¶ÃŸe des Datensatzes bestimmt, Spalten und Datentypen Ã¼berblickt, fehlende Werte aufspÃ¼rt und erste statistische Kennzahlen ermittelt.

Dieser explorative Schritt ist enorm wichtig fÃ¼r den weiteren Verlauf eurer Arbeit, wird aber oft aus Ungeduld Ã¼bersprungen. Wer sich die Zeit nimmt, seine Daten initial grÃ¼ndlich zu prÃ¼fen, versteht nicht nur die inhaltlichen ZusammenhÃ¤nge besser, sondern erkennt auch Probleme wie verschmutzte Daten frÃ¼hzeitig. Das spart spÃ¤ter viel Zeit, weil ihr genau wisst, wo ihr ansetzen mÃ¼sst, statt euch mitten in der Analyse Ã¼ber unerwartete Fehler zu wundern.

Die folgende Tabelle zeigt die Funktionen, die wir in diesem Abschnitt kennenlernen.

| Funktion | Paket | Beschreibung |
|---|---|---|
| `glimpse()` | `dplyr` | Kompakte SpaltenÃ¼bersicht mit Datentypen und ersten Werten |
| `head()` / `tail()` | Base R | Erste bzw. letzte Zeilen anzeigen |
| `nrow()` / `ncol()` | Base R | Anzahl Zeilen bzw. Spalten |
| `names()` | Base R | Spaltennamen als Vektor |
| `summary()` | Base R | Statistische Kennzahlen pro Spalte |
| `count()` | `dplyr` | HÃ¤ufigkeiten von Werten zÃ¤hlen |
| `skim()` | `skimr` | AusfÃ¼hrliche Ãœbersicht nach Datentyp |

Beginnen wir damit, die grundlegenden Dimensionen unseres Datensatzes zu erfassen.

## Dimensionen und Spalten {#sec-exploring-data-dimensions}

Die erste Frage bei einem neuen Datensatz ist: Wie groÃŸ ist er? Mit `nrow()` und `ncol()` bekommt ihr die Anzahl der Zeilen und Spalten:

```{r}
nrow(tweets)
```

```{r}
ncol(tweets)
```

Unser Tweets-Datensatz hat also `r format(nrow(tweets), big.mark = ".")` Zeilen und `r ncol(tweets)` Spalten. Jede Zeile steht fÃ¼r einen Tweet, jede Spalte fÃ¼r eine Eigenschaft dieses Tweets.

Welche Spalten gibt es Ã¼berhaupt? Mit `names()` bekommt ihr die Spaltennamen als Vektor:

```{r}
names(tweets)
```

Das ist nÃ¼tzlich, wenn ihr schnell nachschauen wollt, wie eine Spalte genau heiÃŸt. Denn Tippfehler in Spaltennamen fÃ¼hren sofort zu Fehlermeldungen.

## Erste Zeilen anschauen {#sec-exploring-data-first-rows}

Ein Blick auf die ersten Zeilen gibt euch ein GefÃ¼hl dafÃ¼r, wie die Daten aussehen. DafÃ¼r gibt es `head()`:

```{r}
tweets |>
  head(5)
```

Und wenn ihr lieber die letzten Zeilen sehen wollt, nutzt ihr `tail()`:

```{r}
tweets |>
  tail(5)
```

In der Praxis reichen oft die ersten fÃ¼nf bis zehn Zeilen, um zu erkennen, ob die Daten plausibel aussehen. Sind die Spalten richtig benannt? Stehen dort Werte, die Sinn ergeben? Sehen Zahlen wie Zahlen aus und Texte wie Texte?

## Struktur mit `glimpse()` {#sec-exploring-data-glimpse}

`glimpse()` aus `dplyr` ist eine der nÃ¼tzlichsten Funktionen, um sich schnell einen Ãœberblick zu verschaffen. Sie zeigt euch fÃ¼r jede Spalte den Namen, den Datentyp und die ersten Werte:

```{r}
tweets |>
  glimpse()
```

Warum ist `glimpse()` so praktisch? Weil ihr auf einen Blick seht, ob die Datentypen stimmen. Wenn eine Spalte, die Zahlen enthalten sollte, als `chr` (Text) angezeigt wird, wisst ihr sofort, dass etwas beim Laden schiefgegangen ist. Und wenn eine Datumsspalte als `dttm` erscheint, kÃ¶nnt ihr sicher sein, dass R sie als Zeitstempel erkannt hat.

Im Tweets-Datensatz seht ihr zum Beispiel:

- `screen_name` und `text` sind Text (`chr`)
- `retweet_count` und `favorite_count` sind ganze Zahlen (`int`)
- `created_at` ist ein Zeitstempel (`dttm`)
- `is_retweet` ist ein logischer Wert (`lgl`), also `TRUE` oder `FALSE`

Diese Information braucht ihr immer wieder, wenn ihr spÃ¤ter mit `mutate()` oder `filter()` arbeitet. Deshalb schaut euch `glimpse()` am besten direkt nach dem Laden eurer Daten an.

::: {.callout-tip icon="ğŸ’¡" title="glimpse() vs. str()"}
Die Base-R-Funktion `str()` liefert Ã¤hnliche Informationen wie `glimpse()`, aber in einem weniger lesbaren Format. Im Tidyverse ist `glimpse()` die bevorzugte Wahl.
:::

## Statistische Ãœbersicht mit `summary()` {#sec-exploring-data-summary}

WÃ¤hrend `glimpse()` euch die Struktur zeigt, liefert `summary()` statistische Kennzahlen. FÃ¼r numerische Spalten bekommt ihr Minimum, Maximum, Mittelwert, Median und Quartile. FÃ¼r Text- und Faktorspalten bekommt ihr die HÃ¤ufigkeiten der hÃ¤ufigsten Werte.

```{r}
tweets |>
  select(retweet_count, favorite_count, is_retweet) |>
  summary()
```

Was sagt euch diese Ausgabe? Schaut euch den Mittelwert und den Median an. Wenn die beiden weit auseinanderliegen, deutet das auf eine schiefe Verteilung hin. Bei `retweet_count` ist das typisch: Die meisten Tweets haben wenige Retweets, aber ein paar wenige haben sehr viele. Der Mittelwert wird von diesen AusreiÃŸern nach oben gezogen, der Median bleibt davon unbeeindruckt.

Auch das Maximum ist aufschlussreich. Wenn dort ein unplausibel hoher Wert steht, habt ihr vielleicht einen Datenfehler entdeckt.

## Fehlende Werte erkennen {#sec-exploring-data-missing}

Fehlende Werte sind in echten DatensÃ¤tzen vÃ¶llig normal. Nicht jeder Tweet ist eine Antwort auf einen anderen, also ist `in_reply_to_screen_name` oft leer. Aber ihr solltet wissen, wie viele fehlende Werte es gibt und wo sie auftreten, bevor ihr mit der Analyse beginnt.

Mit `is.na()` und `sum()` kÃ¶nnt ihr die fehlenden Werte pro Spalte zÃ¤hlen:

```{r}
tweets |>
  summarise(
    na_reply_to = sum(is.na(in_reply_to_screen_name)),
    na_quoted = sum(is.na(quoted_status_id)),
    na_retweets = sum(is.na(retweet_count))
  )
```

Das funktioniert, ist aber mÃ¼hsam, wenn ihr viele Spalten prÃ¼fen wollt. Eleganter geht es mit `across()`, das ihr spÃ¤ter noch im Detail kennenlernt (siehe @sec-mutate-modify-across). Hier ein Vorgeschmack:

```{r}
tweets |>
  summarise(across(everything(), \(x) sum(is.na(x)))) |>
  glimpse()
```

So seht ihr auf einen Blick, welche Spalten fehlende Werte haben und wie viele. Spalten mit null fehlenden Werten sind unkritisch. Bei Spalten mit vielen `NA`-Werten mÃ¼sst ihr euch Ã¼berlegen, wie ihr damit umgehen wollt: ignorieren, ersetzen oder die betroffenen Zeilen ausschlieÃŸen.

::: {.callout-tip icon="ğŸ’¡" title="Fehlende Werte sind Information"}
Ein `NA` bedeutet nicht, dass etwas kaputt ist. Es bedeutet, dass die Information nicht vorhanden ist. Ein Tweet ohne `in_reply_to_screen_name` ist kein Fehler, sondern einfach kein Reply. Behandelt fehlende Werte also nicht reflexartig als Problem, sondern fragt euch immer, warum sie fehlen.
:::

## HÃ¤ufigkeiten mit `count()` {#sec-exploring-data-count}

Bei kategorialen Variablen, also Spalten mit einer begrenzten Anzahl mÃ¶glicher Werte, wollt ihr wissen, wie die Werte verteilt sind. Welche Accounts twittern am meisten? In welcher Sprache wird getwittert? Wie viele Tweets sind Retweets?

DafÃ¼r ist `count()` aus `dplyr` das perfekte Werkzeug:

```{r}
tweets |>
  count(is_retweet)
```

UngefÃ¤hr die HÃ¤lfte der Tweets sind Retweets. Das ist eine wichtige Information, denn bei vielen Analysen wollt ihr Retweets ausschlieÃŸen, um nur Original-Inhalte zu betrachten.

Welche Sprachen kommen vor?

```{r}
tweets |>
  count(lang, sort = TRUE) |>
  head(10)
```

Und welche Accounts sind am aktivsten?

```{r}
tweets |>
  count(screen_name, sort = TRUE) |>
  head(10)
```

Mit `sort = TRUE` sortiert `count()` direkt absteigend nach HÃ¤ufigkeit. Das spart euch ein zusÃ¤tzliches `arrange()`.

Ihr kÃ¶nnt auch nach mehreren Variablen gleichzeitig zÃ¤hlen. Zum Beispiel: Wie verteilen sich Original-Tweets und Retweets auf die Accounts?

```{r}
tweets |>
  count(screen_name, is_retweet, sort = TRUE) |>
  head(10)
```

`count()` wird euch im ganzen Buch immer wieder begegnen, weil es die schnellste Art ist, sich einen Ãœberblick Ã¼ber kategoriale Variablen zu verschaffen. Mehr zu `count()` und verwandten Funktionen erfahrt ihr im Kapitel Ã¼ber `summarise()` (siehe @sec-summarize).

## Kompakte Ãœbersicht mit `skimr` {#sec-exploring-data-skimr}

Wenn ihr alles auf einmal sehen wollt, ohne einzelne Funktionen nacheinander aufzurufen, ist das Paket `skimr` eine ausgezeichnete Wahl. Die Funktion `skim()` liefert eine umfassende Ãœbersicht, die nach Datentypen gruppiert ist:

```{r}
library(skimr)

tweets |>
  select(screen_name, text, retweet_count, favorite_count, is_retweet, created_at) |>
  skim()
```

`skim()` zeigt euch fÃ¼r jede Spalte unterschiedliche Kennzahlen, je nach Datentyp:

- FÃ¼r **numerische Spalten**: Mittelwert, Standardabweichung, Quartile und ein kleines Histogramm
- FÃ¼r **Text-Spalten**: Anzahl fehlender Werte, kÃ¼rzeste und lÃ¤ngste Zeichenkette, Anzahl eindeutiger Werte
- FÃ¼r **logische Spalten**: Anzahl `TRUE` und `FALSE`
- FÃ¼r **Datum/Zeit-Spalten**: FrÃ¼hestes und spÃ¤testes Datum

Das kleine Histogramm in der Spalte `hist` ist besonders praktisch: Es zeigt euch auf einen Blick, ob die Verteilung symmetrisch, schief oder gleichmÃ¤ÃŸig ist, ganz ohne einen Plot erstellen zu mÃ¼ssen.

::: {.callout-tip icon="ğŸ’¡" title="skimr vs. summary()"}
`summary()` liefert die klassischen R-Kennzahlen und funktioniert ohne zusÃ¤tzliches Paket. `skim()` bietet mehr Informationen, eine klarere Struktur und die kleinen Histogramme. FÃ¼r eine schnelle PrÃ¼fung reicht `summary()`, fÃ¼r eine grÃ¼ndliche Erstuntersuchung ist `skim()` die bessere Wahl.
:::

## Eine Checkliste fÃ¼r neue DatensÃ¤tze {#sec-exploring-data-checklist}

Wenn ihr einen neuen Datensatz bekommt, kÃ¶nnt ihr euch an dieser Reihenfolge orientieren:

1. **Dimensionen prÃ¼fen**: `nrow()` und `ncol()` â€“ wie groÃŸ ist der Datensatz?
2. **Struktur ansehen**: `glimpse()` â€“ welche Spalten gibt es, welche Datentypen liegen vor?
3. **Erste Zeilen inspizieren**: `head()` â€“ sehen die Werte plausibel aus?
4. **Fehlende Werte zÃ¤hlen**: `summarise(across(everything(), \(x) sum(is.na(x))))` â€“ wo fehlen Daten?
5. **Kategorien erkunden**: `count()` â€“ wie sind kategoriale Variablen verteilt?
6. **Statistische Kennzahlen**: `summary()` oder `skim()` â€“ wie verteilen sich numerische Werte?

Diese Reihenfolge hilft euch, systematisch vorzugehen, statt planlos in den Daten herumzustochern. In den folgenden Kapiteln werden wir den Tweets-Datensatz StÃ¼ck fÃ¼r StÃ¼ck auseinandernehmen. DafÃ¼r braucht ihr die Werkzeuge, die jetzt kommen: Spalten auswÃ¤hlen mit `select()` (siehe @sec-select), Variablen verÃ¤ndern mit `mutate()` (siehe @sec-mutate-modify) und Zeilen filtern mit `filter()` (siehe @sec-filter).

Jetzt, da ihr den Datensatz kennt und wisst, was euch erwartet, kÃ¶nnen wir mit der eigentlichen Arbeit beginnen. Im nÃ¤chsten Kapitel lernt ihr, wie ihr mit `select()` gezielt die Spalten auswÃ¤hlt, die ihr fÃ¼r eine bestimmte Frage braucht.