# Daten laden {#sec-loading-data}

```{r}
#| include: false
source("setup.R")
```

Jeder Analyseprozess beginnt mit dem Laden der Daten (s. @fig-loading-data-eda-process). In diesem Kapitel schauen wir uns an, wie ihr die g√§ngigsten Datenformate in R laden k√∂nnt. Wir starten mit textbasierten Formaten wie CSV und JSON, gehen dann √ºber zu bin√§ren Formaten wie Excel und RDS und werfen zuletzt einen Blick auf das Laden von Daten direkt aus Google Sheets.

![Der Prozess der explorativen Datenanalyse beginnt mit dem Laden der Daten.](https://winf-hsos.github.io/university-docs/images/eda_process.png){#fig-loading-data-eda-process .lightbox}

Zu wissen, wie man Daten aus verschiedenen Quellen importiert, ist grundlegend f√ºr jede Analyseaufgabe. In der Realit√§t liegen Daten selten im perfekten R-Format vor, sondern verteilen sich √ºber verschiedene Systeme, Dateitypen und Cloud-Dienste. Wer diese Formate souver√§n in R √ºberf√ºhren kann, spart sich von Anfang an viel Zeit und frustrierende manuelle Zwischenschritte.

Die folgende Tabelle zeigt die Funktionen, die wir in diesem Abschnitt kennenlernen.

| Funktion | Paket | Beschreibung |
|---|---|---|
| `read_csv()` / `read_csv2()` | `readr` | CSV-Dateien laden |
| `read_delim()` | `readr` | Textdateien mit beliebigem Trennzeichen laden |
| `fromJSON()` / `stream_in()` | `jsonlite` | JSON- und JSONL-Dateien laden |
| `read_excel()` | `readxl` | Excel-Dateien laden |
| `read_sheet()` | `googlesheets4` | Google Sheets laden |
| `read_rds()` | `readr` | RDS-Dateien laden |

Zun√§chst besch√§ftigen wir uns mit den grundlegenden Dateiformaten, aus denen wir Daten laden k√∂nnen.

## Dateiformate {#sec-loading-data-dateiformate}

Daten im Computer speichern wir √ºblicherweise in Dateien. Ein Datensatz kann dabei aus einer oder mehreren Dateien bestehen. Auf der untersten Ebene enth√§lt eine Datei Daten in Form von Nullen und Einsen, denn der Computer arbeitet mit Bits und dem Bin√§rsystem.

In der Arbeit mit Daten unterscheiden wir zwei grundlegende Ideen, wie wir einen Datensatz als Datei speichern:

- Als Textdatei
- Als Bin√§rdatei

![Dateiformate f√ºr Daten sind entweder textbasierte Formate oder propriet√§re bin√§re Formate.](/images/data-file-formats.svg)

Was ist der Unterschied? Eine Textdatei speichert die Daten in einem Format, das f√ºr Menschen lesbar ist. Die Daten werden als Zeichenfolge gespeichert, die √ºber ein g√§ngiges Kodierungssystem wie UTF-8 in lesbare Zeichen √ºbersetzt werden kann. Beispiele f√ºr textbasierte Formate sind CSV (Comma-Separated Values), TSV (Tab-Separated Values) und JSON (JavaScript Object Notation). Ihr k√∂nnt solche Dateien in jedem beliebigen Texteditor √∂ffnen und lesen. Das ist der gro√üe Vorteil: Sie sind einfach zu verstehen und zu bearbeiten.

Bin√§re Formate kodieren die Daten nicht als Text, sondern in einem Format, das f√ºr den Computer effizienter zu lesen und zu schreiben ist. Beispiele sind Excel-Dateien (.xlsx), RDS-Dateien (.rds) und Parquet-Dateien (.parquet). Bin√§re Formate sind in der Regel schneller zu lesen und ben√∂tigen weniger Speicherplatz. Allerdings sind sie nicht direkt von Menschen lesbar und erfordern spezielle Software.

## CSV-Dateien {#sec-loading-data-csv}

Eines der g√§ngigsten Datenformate ist CSV. CSV steht f√ºr "Comma-Separated Values" und ist ein einfaches textbasiertes Format, das Daten in tabellarischer Form speichert. Jede Zeile in einer CSV-Datei entspricht einer Zeile in der Tabelle, und die Werte werden durch Kommas getrennt. CSV-Dateien k√∂nnen von vielen Anwendungen erstellt und gelesen werden, einschlie√ülich Tabellenkalkulationsprogrammen wie Microsoft Excel und Google Sheets.

In R k√∂nnt ihr CSV-Dateien mit der Funktion `read_csv()` aus dem `readr`-Paket laden. Hier ein Beispiel:

```{r}
orders <- read_csv("data/orders.csv")
orders |> 
    head(5)
```

Das hat funktioniert. Aber bei CSV-Dateien gibt es einige Dinge, die sich unterscheiden k√∂nnen und die ihr beim Laden ber√ºcksichtigen m√ºsst.

### Trennzeichen {#sec-loading-data-trennzeichen}

In einigen L√§ndern, zum Beispiel in Deutschland, wird anstelle eines Kommas h√§ufig ein Semikolon als Trennzeichen verwendet. F√ºr diesen Fall gibt es die Funktion `read_csv2()`. Ob das Trennzeichen falsch eingestellt ist, erkennt ihr sofort am Ergebnis: Alle Werte werden in einer einzigen Spalte zusammengefasst, anstatt in mehreren Spalten verteilt zu sein. Schauen wir uns das kurz an:

```{r}
orders_wrong <- read_csv2("data/orders.csv")
```

Wie in der Ausgabe zu sehen, wurde nur eine Spalte erkannt. Wenn wir uns Beispielwerte ausgeben lassen, sehen wir, dass alle Werte in dieser einen Spalte zusammengefasst wurden:

```{r}
head(orders_wrong)
```

Die Funktion `read_csv2()` verwenden wir nur, wenn wirklich ein Semikolon als Trennzeichen verwendet wird. Bei einem Komma als Trennzeichen m√ºssen wir `read_csv()` verwenden, damit die Werte korrekt in Spalten aufgeteilt werden.

Neben dem Tabulator-Zeichen als weiterem g√§ngigem Trennzeichen gibt es die allgemeine Funktion `read_delim()`, bei der ihr das Trennzeichen explizit angeben k√∂nnt. Die Tabelle gibt einen √úberblick:

| Funktion       | Trennzeichen |
|----------------|--------------|
| `read_csv()`   | Komma (`,`)  |
| `read_csv2()`  | Semikolon (`;`) |
| `read_tsv()`   | Tabulator (`\t`) |
| `read_delim()` | Beliebiges Trennzeichen (muss angegeben werden) |

Hier ein Beispiel f√ºr `read_delim()`, wenn das Trennzeichen ein Pipe-Symbol w√§re:

```{r}
orders_delim <- read_delim("data/orders.csv", delim = "|")
```

### Zeichenkodierung {#sec-loading-data-encoding}

Textdateien speichern die Daten in einem bestimmten Kodierungsformat. In Deutschland war es lange √ºblich, das Kodierungsformat "ISO-8859-1" (auch "Latin-1" genannt) zu verwenden, w√§hrend international "UTF-8" der Standard ist. Wenn die CSV-Datei in einem anderen Kodierungsformat vorliegt als erwartet, m√ºssen wir dies beim Laden angeben.

Da die meisten Dateien heute im UTF-8-Format vorliegen, ist dies auch die Standardeinstellung in den Funktionen von `readr`. Mit UTF-8 k√∂nnt ihr auch das √§ltere, aber immer noch verwendete ASCII-Zeichenset abdecken, weil UTF-8 r√ºckw√§rtskompatibel ist. Liegt die CSV-Datei jedoch in einem anderen Format vor, gebt ihr es explizit an:

```{r}
orders_iso <- read_csv(
    "data/orders.csv", 
    locale = locale(encoding = "ISO-8859-1")
)
```

Das ISO-8859-1-Format ist eine Erweiterung des ASCII-Zeichensatzes und unterst√ºtzt die meisten westeurop√§ischen Sprachen, einschlie√ülich Deutsch mit seinen Umlauten. UTF-8 ist leider nicht vollst√§ndig r√ºckw√§rtskompatibel mit ISO-8859-1: Wenn also ein Datensatz mit ISO-8859-1 kodiert wurde und ihr ihn als UTF-8 ladet, k√∂nnen Umlaute und Sonderzeichen kaputt gehen.

### Dezimaltrennzeichen {#sec-loading-data-dezimal}

In Deutschland wird anstelle eines Punktes h√§ufig ein Komma als Dezimaltrennzeichen verwendet. Die Funktion `read_csv2()` ber√ºcksichtigt das automatisch. Ihr k√∂nnt das Dezimaltrennzeichen aber auch explizit √ºber den Parameter `locale` angeben.

Ob das Dezimaltrennzeichen falsch eingestellt ist, erkennt ihr wieder am Ergebnis: Alle Zahlen, die ein Dezimaltrennzeichen enthalten, werden als Text (Strings) interpretiert, anstatt als numerische Werte.

Hier ein Beispiel, bei dem wir absichtlich ein falsches Dezimaltrennzeichen angeben:

```{r}
orders_wrong_decimal <- read_csv(
    "data/orders.csv", 
    locale = locale(decimal_mark = ",")
)
```

Schauen wir uns jetzt die Spalte `total_price` an, die eigentlich eine Dezimalzahl sein m√ºsste:

```{r}
orders_wrong_decimal |> 
    select(total_price) |> 
    head(5)
```

Achtet auf die Angabe des Datentyps `chr`, was f√ºr "character" steht, also Text. Wir sollten also schleunigst das richtige Dezimaltrennzeichen verwenden.

Manchmal hat nur eine einzelne Spalte ein anderes Dezimaltrennzeichen als die √ºbrigen Spalten. Dann k√∂nnt ihr euch damit behelfen, die Spalte nachtr√§glich in den korrekten Datentyp umzuwandeln:

```{r}
orders_fixed_decimal <- orders_wrong_decimal |> 
    mutate(total_price = as.double(total_price))
```

Pr√ºfen wir, ob es geklappt hat:

```{r}
orders_fixed_decimal |> 
    select(total_price) |> 
    head(5)
```

Die Funktion `as.double()` sucht standardm√§√üig nach einem Punkt als Dezimaltrennzeichen. Sollte es in der Spalte tats√§chlich ein Komma als Dezimaltrennzeichen geben, m√ºsst ihr `parse_number()` verwenden und das Dezimaltrennzeichen explizit angeben:

```{r}
orders_fixed_decimal <- orders_wrong_decimal |> 
    mutate(total_price = parse_number(total_price, locale = locale(decimal_mark = ",")))
```

### Kopfzeilen {#sec-loading-data-header}

CSV-Dateien enthalten in der Regel eine Kopfzeile, die die Namen der Spalten angibt. Die Funktionen aus `readr` gehen davon aus, dass diese Zeile vorhanden ist. Wenn die CSV-Datei keine Kopfzeile enth√§lt, m√ºsst ihr dies beim Laden angeben:

```{r}
orders_no_header <- read_csv(
    "data/orders.csv", 
    col_names = FALSE
)
```

Schaut euch das Ergebnis an:

```{r}
orders_no_header |> 
    head(5)
```

Was ist passiert? Die Spalten wurden automatisch mit generischen Namen wie `X1`, `X2`, `X3` benannt, weil keine Kopfzeile vorhanden war. Oder zumindest haben wir das behauptet. Zus√§tzlich wurde die erste Zeile der CSV-Datei als Datenzeile interpretiert, anstatt als Kopfzeile.

## JSON und JSONL {#sec-loading-data-json}

Neben CSV gibt es ein weiteres textbasiertes Format, das euch in der Datenanalyse immer h√§ufiger begegnet: JSON. JSON steht f√ºr "JavaScript Object Notation" und wurde urspr√ºnglich f√ºr den Datenaustausch im Web entwickelt. Heute ist JSON weit √ºber das Web hinaus verbreitet und wird oft f√ºr APIs, Konfigurationsdateien und hierarchisch strukturierte Daten verwendet.

Was unterscheidet JSON von CSV? In einer CSV-Datei sind die Daten flach und tabellarisch. JSON erlaubt dagegen verschachtelte Strukturen. Ein einzelner JSON-Eintrag kann so aussehen:

```json
{
  "name": "Anna",
  "age": 23,
  "courses": ["Statistics", "Programming", "Data Analytics"]
}
```

Hier hat die Person ein Feld `courses`, das selbst eine Liste enth√§lt. In CSV w√§re das nur umst√§ndlich abzubilden.

### JSON-Dateien laden {#sec-loading-data-json-laden}

Zum Laden von JSON-Dateien nutzt ihr das Paket `jsonlite`. Es wandelt die JSON-Struktur automatisch in ein tibble-√§hnliches Objekt um, wenn die Daten tabellarisch interpretierbar sind:

```{r}
#| eval: false
library(jsonlite)
data <- fromJSON("data/example.json")
```

Die Funktion `fromJSON()` erkennt, ob die JSON-Datei ein einzelnes Objekt oder eine Liste von Objekten enth√§lt, und versucht, die Daten intelligent in einen Data Frame umzuwandeln. Bei einfachen, flachen JSON-Strukturen funktioniert das problemlos.

### JSONL {#sec-loading-data-jsonl}

In der Praxis begegnet euch h√§ufig auch das Format JSONL (JSON Lines). Dabei enth√§lt jede Zeile der Datei genau ein JSON-Objekt. Das ist besonders bei gro√üen Datens√§tzen praktisch, weil die Datei zeilenweise gelesen und verarbeitet werden kann.

Eine JSONL-Datei sieht zum Beispiel so aus:

```
{"name": "Anna", "age": 23, "passed": true}
{"name": "Ben", "age": 21, "passed": false}
{"name": "Cleo", "age": 25, "passed": true}
```

Zum Laden von JSONL-Dateien k√∂nnt ihr `stream_in()` aus dem Paket `jsonlite` verwenden:

```{r}
#| eval: false
data <- stream_in(file("data/example.jsonl"))
```

Die Funktion `stream_in()` liest die Datei zeilenweise und liefert am Ende einen Data Frame. Das ist besonders bei sehr gro√üen Dateien effizienter als `fromJSON()`, weil nicht die gesamte Datei auf einmal in den Arbeitsspeicher geladen werden muss.

::: {.callout-tip icon="üí°" title="JSON oder CSV?"}
F√ºr tabellarische Daten ist CSV oft die einfachere Wahl. JSON spielt seine St√§rken bei verschachtelten oder hierarchischen Daten aus, zum Beispiel bei Antworten von Web-APIs. Wenn ihr Daten von einer API bekommt, liegen sie fast immer im JSON-Format vor.
:::

## Excel-Dateien {#sec-loading-data-excel}

Excel-Dateien geh√∂ren zu den bin√§ren Formaten. Sie sind in der Praxis extrem verbreitet, weil viele Menschen mit Microsoft Excel oder Google Sheets arbeiten. Das Format `.xlsx` ist kein einfacher Text, sondern ein komprimiertes Archiv, das die Daten zusammen mit Formatierungen, Formeln und Metadaten speichert.

Zum Laden von Excel-Dateien in R nutzt ihr das Paket `readxl`, das ebenfalls zum Tidyverse-√ñkosystem geh√∂rt:

```{r}
#| eval: false
library(readxl)
data <- read_excel("data/example.xlsx")
```

Die Funktion `read_excel()` erkennt automatisch, ob es sich um eine `.xls`- oder `.xlsx`-Datei handelt. Das Ergebnis ist ein Tibble, genau wie bei `read_csv()`.

### Arbeitsbl√§tter ausw√§hlen {#sec-loading-data-excel-sheets}

Eine Besonderheit von Excel-Dateien ist, dass sie mehrere Arbeitsbl√§tter (Sheets) enthalten k√∂nnen. Standardm√§√üig liest `read_excel()` das erste Arbeitsblatt. Wenn ihr ein anderes Blatt laden wollt, gebt ihr es √ºber den Parameter `sheet` an:

```{r}
#| eval: false
# √úber den Namen
data <- read_excel("data/example.xlsx", sheet = "Sales")

# Oder √ºber die Position
data <- read_excel("data/example.xlsx", sheet = 2)
```

Wenn ihr nicht wisst, welche Arbeitsbl√§tter eine Excel-Datei enth√§lt, hilft euch `excel_sheets()`:

```{r}
#| eval: false
excel_sheets("data/example.xlsx")
```

### Bereiche und Kopfzeilen {#sec-loading-data-excel-ranges}

Manchmal beginnen die eigentlichen Daten in einer Excel-Datei nicht in der ersten Zeile, weil dar√ºber ein Titel oder Erl√§uterungen stehen. In diesem Fall k√∂nnt ihr Zeilen √ºberspringen:

```{r}
#| eval: false
data <- read_excel("data/example.xlsx", skip = 3)
```

Oder ihr gebt einen konkreten Zellbereich an, wie ihr es aus Excel kennt:

```{r}
#| eval: false
data <- read_excel("data/example.xlsx", range = "B2:F100")
```

Genau wie bei CSV k√∂nnt ihr auch angeben, dass keine Kopfzeile vorhanden ist:

```{r}
#| eval: false
data <- read_excel("data/example.xlsx", col_names = FALSE)
```

::: {.callout-tip icon="üí°" title="readxl braucht kein Excel"}
Das Paket `readxl` liest Excel-Dateien direkt, ohne dass Microsoft Excel installiert sein muss. Das ist besonders praktisch auf Servern oder in automatisierten Pipelines, wo kein Excel vorhanden ist.
:::

## Google Sheets {#sec-loading-data-google}

Was ist, wenn eure Daten gar nicht als Datei auf eurem Rechner liegen, sondern in der Cloud? Google Sheets ist einer der verbreitetsten Orte, an denen Teams gemeinsam Daten sammeln und pflegen. Zum Beispiel, wenn ihr eine Umfrage √ºber Google Forms durchf√ºhrt: Die Antworten landen automatisch in einem Google Sheet.

Das Paket `googlesheets4` erlaubt es euch, Daten direkt aus Google Sheets in R zu laden, ohne sie erst herunterladen zu m√ºssen:

```{r}
#| eval: false
library(googlesheets4)
data <- read_sheet("https://docs.google.com/spreadsheets/d/...")
```

Ihr √ºbergebt einfach die URL oder die ID eures Google Sheets an `read_sheet()`. Das Ergebnis ist ein Tibble.

### Authentifizierung {#sec-loading-data-google-auth}

Beim ersten Aufruf fragt euch `googlesheets4` nach einer Berechtigung, auf euer Google-Konto zuzugreifen. Es √∂ffnet sich ein Browserfenster, in dem ihr euch anmeldet und die Berechtigung erteilt. R speichert diese Berechtigung dann lokal, sodass ihr euch nicht jedes Mal neu anmelden m√ºsst.

Wenn ihr auf √∂ffentlich zug√§ngliche Sheets zugreifen wollt, k√∂nnt ihr die Authentifizierung auch komplett abschalten:

```{r}
#| eval: false
gs4_deauth()
data <- read_sheet("https://docs.google.com/spreadsheets/d/...")
```

### Arbeitsbl√§tter und Bereiche {#sec-loading-data-google-sheets}

Genau wie bei Excel-Dateien k√∂nnt ihr bei Google Sheets das Arbeitsblatt und den Zellbereich angeben:

```{r}
#| eval: false
# Bestimmtes Arbeitsblatt laden
data <- read_sheet("https://docs.google.com/spreadsheets/d/...", sheet = "Responses")

# Bestimmten Bereich laden
data <- read_sheet("https://docs.google.com/spreadsheets/d/...", range = "A1:E100")
```

::: {.callout-tip icon="üí°" title="Wann Google Sheets, wann CSV?"}
Google Sheets ist praktisch, wenn Daten laufend aktualisiert werden und ihr immer den neuesten Stand laden wollt. F√ºr statische Datens√§tze, die sich nicht mehr √§ndern, ist eine heruntergeladene CSV-Datei meistens die einfachere und reproduzierbarere L√∂sung.
:::

## RDS-Dateien {#sec-loading-data-rds}

Zum Schluss schauen wir uns ein Format an, das speziell f√ºr R entwickelt wurde: RDS. RDS steht f√ºr "R Data Serialization" und ist ein bin√§res Format, mit dem ihr einzelne R-Objekte speichern und wieder laden k√∂nnt.

Warum ist das n√ºtzlich? Stellt euch vor, ihr habt einen Datensatz aufwendig bereinigt und transformiert. Wenn ihr ihn als CSV speichert, gehen dabei Informationen verloren, zum Beispiel Datentypen, Faktor-Levels oder die Zeitzone von Datumswerten. RDS bewahrt all das, weil es das R-Objekt exakt so speichert, wie es im Arbeitsspeicher vorliegt.

### RDS-Dateien laden {#sec-loading-data-rds-laden}

Zum Laden nutzt ihr `read_rds()`:

```{r}
tweets <- read_rds("data/tweets_ampel.rds")
tweets |>
    head(5)
```

Das Ergebnis ist exakt das Objekt, das gespeichert wurde, einschlie√ülich aller Datentypen und Attribute.

### RDS-Dateien speichern {#sec-loading-data-rds-speichern}

Umgekehrt k√∂nnt ihr jedes R-Objekt als RDS-Datei speichern:

```{r}
#| eval: false
write_rds(tweets, "data/tweets_backup.rds")
```

Ein wichtiger Unterschied zu anderen Formaten: RDS speichert genau ein Objekt pro Datei. Wenn ihr mehrere Objekte speichern wollt, erstellt ihr entweder mehrere RDS-Dateien oder nutzt das verwandte Format `.RData` (auch `.rda`), das mehrere Objekte auf einmal speichern kann.

### Wann RDS verwenden? {#sec-loading-data-rds-wann}

RDS ist die beste Wahl, wenn ihr innerhalb von R arbeitet und sicherstellen wollt, dass keine Informationen verloren gehen. In diesem Buch laden wir den Tweets-Datensatz als RDS-Datei, weil so alle Spaltentypen und Metadaten erhalten bleiben. Wenn ihr Daten dagegen mit anderen Tools oder Personen teilen wollt, die kein R verwenden, ist CSV oder ein anderes offenes Format die bessere Wahl.

## Kurz zusammengefasst {#sec-loading-data-zusammenfassung}

::: {.reuse #load-data-summary}

- **CSV** ist das verbreitetste textbasierte Format. Ihr ladet es mit `read_csv()` aus dem `readr`-Paket. Achtet auf Trennzeichen, Zeichenkodierung und Dezimaltrennzeichen.
- **JSON** eignet sich f√ºr hierarchische oder verschachtelte Daten und kommt oft von Web-APIs. Ihr nutzt `fromJSON()` oder `stream_in()` aus dem Paket `jsonlite`.
- **Excel-Dateien** ladet ihr mit `read_excel()` aus dem Paket `readxl`. Ihr k√∂nnt Arbeitsbl√§tter, Bereiche und Kopfzeilen gezielt ansteuern.
- **Google Sheets** lassen sich direkt mit `read_sheet()` aus dem Paket `googlesheets4` laden, ohne die Datei herunterladen zu m√ºssen.
- **RDS** ist das R-eigene Bin√§rformat. Es bewahrt alle Datentypen und Attribute und eignet sich perfekt f√ºr die Arbeit innerhalb von R.

:::

Daten laden ist der Startpunkt jeder Analyse. Im n√§chsten Kapitel lernt ihr mit dem Pipe-Operator `|>` ein Werkzeug kennen, das euch dabei hilft, die geladenen Daten Schritt f√ºr Schritt weiterzuverarbeiten (siehe @sec-pipe).

_Abbildung: Ein Flussdiagramm mit einem zentralen Kasten "Daten laden in R". Von dort gehen f√ºnf Pfeile ab zu je einem Format-Kasten: CSV (mit Icon einer Textdatei), JSON (mit geschweiften Klammern), Excel (mit einem gr√ºnen Tabellen-Icon), Google Sheets (mit einem Cloud-Icon), RDS (mit dem R-Logo). Unter jedem Format-Kasten steht die zugeh√∂rige R-Funktion: `read_csv()`, `fromJSON()`, `read_excel()`, `read_sheet()`, `read_rds()`. Die Format-K√§sten sind in zwei Gruppen aufgeteilt: links "Textbasiert" (CSV, JSON), rechts "Bin√§r / Cloud" (Excel, Google Sheets, RDS)._
