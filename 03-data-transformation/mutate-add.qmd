# Variablen erstellen {#sec-mutate-add}

```{r}
#| include: false
source("setup.R")
```

Im vorherigen Kapitel habt ihr gelernt, wie ihr bestehende Variablen ver√§ndert und repariert. Jetzt gehen wir den n√§chsten logischen Schritt: Neue Variablen anlegen. In diesem Kapitel lernt ihr, wie ihr mit `mutate()` aus zwei oder mehr Spalten eine v√∂llig neue berechnet, Kategorien aus numerischen Werten ableitet und laufende Summen oder R√§nge aufbaut. Der Unterschied zum vorherigen Kapitel ist konzeptionell einfach: Wenn ihr bei `mutate()` links vom Gleichheitszeichen einen Namen verwendet, der im Datensatz noch nicht existiert, wird die Spalte neu angeh√§ngt.

In vielen quantitativen Projekten enthalten die rohen Daten nicht direkt die Kennzahlen, die ihr f√ºr eure Forschungsfrage ben√∂tigt. Ihr m√ºsst sie erst berechnen ‚Äì seien es Altersgruppen aus Geburtsjahren, prozentuale Anteile aus absoluten Zahlen oder textuelle Zusammenfassungen aus Einzelstrings. Die F√§higkeit, gezielt neue Metriken zu synthetisieren, erweitert eure Analysem√∂glichkeiten enorm und macht eure Visualisierungen sp√§ter deutlich aussagekr√§ftiger.

Die folgende Tabelle zeigt die Funktionen, die wir in diesem Abschnitt kennenlernen.

| Funktion | Beschreibung |
|---|---|
| `mutate()` | Neue Spalten berechnen und anh√§ngen |
| `str_c()` | Texte zusammenf√ºgen |
| `lag()` / `lead()` | Vorheriger bzw. n√§chster Wert (Fensterfunktionen) |
| `cumsum()` / `cummean()` | Laufende Summe bzw. laufender Durchschnitt |
| `min_rank()` / `dense_rank()` / `row_number()` | Rangfolgen berechnen |
| `transmute()` | Nur neue Spalten behalten |
| `.before` / `.after` / `.keep` | Position und Auswahl neuer Spalten steuern |

Schauen wir uns als Erstes an, wie wir ganz klassisch mit bestehenden Werten rechnen.

## Neue Variablen berechnen {#sec-mutate-add-berechnen}

Die einfachste Form: Ihr rechnet mit bestehenden Spalten und gebt dem Ergebnis einen neuen Namen.

```{r}
tweets |>
  mutate(total_engagement = retweet_count + favorite_count) |>
  select(screen_name, retweet_count, favorite_count, total_engagement) |>
  head(5)
```

Hier entsteht die neue Spalte `total_engagement` als Summe von Retweets und Likes. Die bestehenden Spalten bleiben vollst√§ndig erhalten.

Ihr k√∂nnt in einem einzigen `mutate()`-Aufruf auch mehrere neue Variablen gleichzeitig anlegen. Dabei k√∂nnt ihr sogar auf Variablen zugreifen, die ihr gerade erst erstellt habt:

```{r}
tweets |>
  mutate(
    total_engagement = retweet_count + favorite_count,
    engagement_ratio = retweet_count / total_engagement
  ) |>
  select(screen_name, total_engagement, engagement_ratio) |>
  head(5)
```

`engagement_ratio` greift auf `total_engagement` zu, obwohl diese Spalte erst in der Zeile dar√ºber definiert wurde. Das funktioniert, weil `mutate()` die neuen Variablen von oben nach unten abarbeitet.

::: {.callout-tip icon="üí°" title="Division durch Null"}
Wenn `total_engagement` den Wert 0 hat, liefert die Division `Inf` (unendlich). In der Praxis wollt ihr solche F√§lle abfangen, zum Beispiel mit `if_else(total_engagement == 0, 0, retweet_count / total_engagement)`.
:::

## Textuelle Variablen {#sec-mutate-add-text}

Neben arithmetischen Berechnungen k√∂nnt ihr auch neue Textspalten zusammensetzen. Die Funktion `str_c()` aus `stringr` f√ºgt mehrere Werte zu einem einzigen String zusammen:

```{r}
tweets |>
  mutate(label = str_c(screen_name, ": ", text)) |>
  select(label) |>
  head(3)
```

Ein h√§ufiger Anwendungsfall ist das Erstellen lesbarer Labels f√ºr Diagramme oder Berichte. Wenn ihr Werte mit einem Trennzeichen zusammenf√ºgen wollt, nutzt den Parameter `sep`:

```{r}
tweets |>
  mutate(
    info = str_c(screen_name, retweet_count, sep = " | ")
  ) |>
  select(info) |>
  head(3)
```

## Bedingte Variablen {#sec-mutate-add-bedingt}

Oft h√§ngt der Wert einer neuen Spalte von einer Bedingung ab. Das kennt ihr bereits aus dem vorherigen Kapitel. Hier erstellen wir aber eine neue Variable, statt eine bestehende zu ver√§ndern.

### Zwei F√§lle mit `if_else()`

```{r}
tweets |>
  mutate(is_popular = if_else(retweet_count >= 100, "popular", "normal")) |>
  select(screen_name, retweet_count, is_popular) |>
  head(5)
```

### Mehrere F√§lle mit `case_when()`

```{r}
tweets |>
  mutate(
    engagement_level = case_when(
      retweet_count >= 1000 ~ "viral",
      retweet_count >= 100  ~ "high",
      retweet_count >= 10   ~ "medium",
      .default = "low"
    )
  ) |>
  select(screen_name, retweet_count, engagement_level) |>
  head(10)
```

Die Reihenfolge der Bedingungen ist entscheidend: Die erste zutreffende Bedingung gewinnt. Wenn ihr die speziellsten F√§lle nicht zuerst nennt, werden sie von allgemeineren Bedingungen √ºberschattet.

## Fensterfunktionen {#sec-mutate-add-fenster}

Fensterfunktionen sind Funktionen, die f√ºr jede Zeile einen Wert berechnen, aber dabei die umliegenden Zeilen ber√ºcksichtigen. Im Gegensatz zu Aggregatfunktionen wie `sum()` oder `mean()`, die einen Datensatz auf einen einzigen Wert reduzieren, geben Fensterfunktionen f√ºr jede Zeile einen eigenen Wert zur√ºck. Der Datensatz beh√§lt also seine L√§nge.

### Vorherige und n√§chste Werte mit `lag()` und `lead()`

Mit `lag()` greift ihr auf den Wert der vorherigen Zeile zu, mit `lead()` auf den der n√§chsten. Das ist besonders n√ºtzlich f√ºr Zeitreihendaten, wenn ihr Ver√§nderungen zwischen aufeinanderfolgenden Eintr√§gen berechnen wollt.

```{r}
orders |>
  arrange(created_at) |>
  mutate(
    previous_price = lag(total_price),
    price_change = total_price - lag(total_price)
  ) |>
  select(order_id, created_at, total_price, previous_price, price_change) |>
  head(5)
```

Beachtet, dass die erste Zeile f√ºr `lag()` immer `NA` liefert, weil es keinen Vorg√§nger gibt. Genauso liefert `lead()` f√ºr die letzte Zeile `NA`.

::: {.callout-tip icon="üí°" title="Sortierung ist entscheidend"}
`lag()` und `lead()` arbeiten auf der aktuellen Zeilenreihenfolge. Wenn eure Daten nicht sortiert sind, liefern sie unsinnige Ergebnisse. Sortiert deshalb vorher mit `arrange()`.
:::

### Laufende Summen und Durchschnitte

Laufende (kumulative) Berechnungen bauen Schritt f√ºr Schritt auf: Jede Zeile enth√§lt die Summe, den Mittelwert oder das Maximum aller bisherigen Werte.

```{r}
orders |>
  arrange(created_at) |>
  mutate(
    cumulative_revenue = cumsum(total_price),
    running_avg_price = cummean(total_price)
  ) |>
  select(order_id, total_price, cumulative_revenue, running_avg_price) |>
  head(10)
```

Die wichtigsten kumulativen Funktionen:

| Funktion | Beschreibung |
|---|---|
| `cumsum()` | Laufende Summe |
| `cummean()` | Laufender Durchschnitt |
| `cummax()` | Laufendes Maximum |
| `cummin()` | Laufendes Minimum |

### Rangfolgen

Wenn ihr Zeilen nach einem Wert ranken wollt, gibt es mehrere Funktionen. Der Unterschied liegt im Umgang mit Gleichst√§nden:

```{r}
tweets |>
  filter(!is_retweet) |>
  mutate(rank = min_rank(desc(retweet_count))) |>
  select(screen_name, retweet_count, rank) |>
  arrange(rank) |>
  head(10)
```

`min_rank()` vergibt bei Gleichstand denselben Rang und l√§sst danach Pl√§tze aus (wie bei einem Sportwettbewerb: Platz 1, 1, 3). `dense_rank()` l√§sst dagegen keine Pl√§tze aus (Platz 1, 1, 2). `row_number()` vergibt jeden Rang nur einmal, die Reihenfolge bei Gleichstand ist aber willk√ºrlich.

```{r}
example <- tibble(score = c(100, 90, 90, 80))

example |>
  mutate(
    min_rank = min_rank(desc(score)),
    dense_rank = dense_rank(desc(score)),
    row_number = row_number(desc(score))
  )
```

_Abbildung: Drei Spalten nebeneinander mit denselben vier Werten (100, 90, 90, 80). In der ersten Spalte steht die Rangfolge mit `min_rank` (1, 2, 2, 4). In der zweiten Spalte steht `dense_rank` (1, 2, 2, 3). In der dritten Spalte steht `row_number` (1, 2, 3, 4). Die Gleichst√§nde bei 90 sind farblich hervorgehoben, um den Unterschied im Umgang mit Gleichst√§nden zu zeigen._

### Zeilennummern

Manchmal braucht ihr einfach eine fortlaufende Nummer f√ºr jede Zeile. Daf√ºr gibt es `row_number()` ohne Argument:

```{r}
tweets |>
  filter(!is_retweet) |>
  arrange(desc(retweet_count)) |>
  mutate(position = row_number()) |>
  select(position, screen_name, retweet_count) |>
  head(5)
```

## Gruppiertes Mutieren {#sec-mutate-add-grouped}

Hier wird es besonders spannend: Wenn ihr `mutate()` auf einen gruppierten Datensatz anwendet, werden die Berechnungen innerhalb jeder Gruppe durchgef√ºhrt. Das √∂ffnet die T√ºr f√ºr Fragen wie "Wie verh√§lt sich dieser Wert im Vergleich zu seiner Gruppe?"

![In Kombination mit Gruppierung erzeugt `mutate` Berechnungen auf Gruppenebene, beh√§lt aber weiterhin jede Zeile.](https://winf-hsos.github.io/university-docs/images/group_by_mutate_schema.png){.lightbox}

### Anteile innerhalb von Gruppen

Stellt euch vor, ihr wollt wissen, wie viel Prozent der Gesamtinteraktion jeder Tweet innerhalb seines Accounts ausmacht:

```{r}
tweets |>
  filter(!is_retweet) |>
  group_by(screen_name) |>
  mutate(
    account_total = sum(retweet_count),
    share = retweet_count / account_total
  ) |>
  select(screen_name, retweet_count, account_total, share) |>
  head(10)
```

Ohne `group_by()` w√ºrde `sum(retweet_count)` die Summe √ºber den gesamten Datensatz berechnen. Mit `group_by()` berechnet R die Summe separat f√ºr jeden Account. Die Spalte `account_total` hat also f√ºr alle Tweets desselben Accounts denselben Wert.

_Abbildung: Ein Datensatz als Tabelle mit drei Gruppen (farblich markiert, jeweils 3 Zeilen). Links: eine Spalte "value" mit Einzelwerten. Rechts: eine neue Spalte "group_sum" mit der Gruppensumme, die f√ºr alle Zeilen einer Gruppe identisch ist. Ein Pfeil zeigt, dass `group_by() |> mutate(group_sum = sum(value))` die Summe pro Gruppe berechnet und in jede Zeile schreibt, statt den Datensatz zu komprimieren._

### Rang innerhalb von Gruppen

Auch Rangfolgen funktionieren gruppiert:

```{r}
tweets |>
  filter(!is_retweet) |>
  group_by(screen_name) |>
  mutate(rank_within_account = min_rank(desc(retweet_count))) |>
  filter(rank_within_account == 1) |>
  select(screen_name, retweet_count, rank_within_account)
```

Hier bekommt jeder Tweet einen Rang innerhalb seines Accounts. Das Filtern auf Rang 1 ergibt den meistretweeteten Tweet pro Account.

### Laufende Berechnungen pro Gruppe

Kumulative Funktionen in gruppierten Daten starten f√ºr jede Gruppe neu von Null:

```{r}
orders |>
  arrange(created_at) |>
  group_by(financial_status) |>
  mutate(
    cumulative_revenue = cumsum(total_price),
    order_number_in_group = row_number()
  ) |>
  select(financial_status, total_price, cumulative_revenue, order_number_in_group) |>
  head(10)
```

::: {.callout-tip icon="üí°" title="Gruppierung entfernen"}
Vergesst nicht, die Gruppierung nach dem Mutieren mit `ungroup()` wieder aufzuheben, wenn ihr danach mit dem gesamten Datensatz weiterarbeiten wollt. Sonst wirken sich sp√§tere Operationen weiterhin nur innerhalb der Gruppen aus.
:::

## Optionen f√ºr `mutate()` {#sec-mutate-add-optionen}

Standardm√§√üig f√ºgt `mutate()` neue Spalten ganz rechts an und beh√§lt alle bestehenden Spalten. √úber drei Parameter k√∂nnt ihr dieses Verhalten anpassen: `.before`, `.after` und `.keep`.

### Position neuer Spalten mit `.before` und `.after`

Wenn ihr die neue Spalte an einer bestimmten Stelle im Datensatz haben wollt, statt ganz am Ende, nutzt `.before` oder `.after`:

```{r}
tweets |>
  mutate(
    total_engagement = retweet_count + favorite_count,
    .after = screen_name
  ) |>
  select(screen_name, total_engagement, retweet_count, favorite_count) |>
  head(3)
```

Mit `.before = retweet_count` w√ºrde die neue Spalte direkt vor `retweet_count` erscheinen. Das ist praktisch, wenn ihr euren Datensatz √ºbersichtlich halten wollt, ohne danach extra `relocate()` aufrufen zu m√ºssen.

### Spalten behalten oder verwerfen mit `.keep`

Der Parameter `.keep` steuert, welche der bestehenden Spalten im Ergebnis erhalten bleiben. Es gibt vier Optionen:

| `.keep` | Verhalten |
|---|---|
| `"all"` | Alle Spalten behalten (Standard) |
| `"used"` | Nur die Spalten behalten, die in der Berechnung verwendet wurden |
| `"unused"` | Nur die Spalten behalten, die *nicht* in der Berechnung verwendet wurden |
| `"none"` | Keine bestehenden Spalten behalten, nur die neuen |

Schauen wir uns die Unterschiede an. Mit `"used"` behaltet ihr nur die Spalten, aus denen die neue Variable berechnet wurde:

```{r}
tweets |>
  mutate(
    total_engagement = retweet_count + favorite_count,
    .keep = "used"
  ) |>
  head(3)
```

Das Ergebnis enth√§lt `retweet_count`, `favorite_count` und `total_engagement`, aber keine der anderen Spalten. Das ist n√ºtzlich, wenn ihr schnell pr√ºfen wollt, ob eure Berechnung stimmt.

Mit `"none"` behaltet ihr ausschlie√ülich die neuen Variablen:

```{r}
tweets |>
  mutate(
    user = screen_name,
    total_engagement = retweet_count + favorite_count,
    .keep = "none"
  ) |>
  head(3)
```

### `transmute()` als Alternative

`mutate(..., .keep = "none")` macht genau das Gleiche wie `transmute()`. Die Funktion `transmute()` existierte bereits, bevor `.keep` eingef√ºhrt wurde, und ist eine k√ºrzere Schreibweise:

```{r}
tweets |>
  transmute(
    user = screen_name,
    total_engagement = retweet_count + favorite_count,
    engagement_ratio = retweet_count / total_engagement
  ) |>
  head(5)
```

Welchen Weg ihr w√§hlt, ist Geschmackssache. `transmute()` ist etwas k√ºrzer, `mutate(..., .keep = "none")` macht die Absicht √ºber den Parameter expliziter.

## Kurz zusammengefasst {#sec-mutate-add-zusammenfassung}

- Mit `mutate()` erstellt ihr neue Variablen, indem ihr links vom `=` einen neuen Namen vergebt.
- Ihr k√∂nnt arithmetisch rechnen, Texte zusammensetzen und bedingte Werte mit `if_else()` oder `case_when()` erzeugen.
- Fensterfunktionen wie `lag()`, `lead()`, `cumsum()` und `min_rank()` berechnen Werte im Kontext umliegender Zeilen.
- Mit `group_by() |> mutate()` laufen Berechnungen innerhalb von Gruppen, ohne den Datensatz zu komprimieren.
- Mit `.before` und `.after` steuert ihr die Position neuer Spalten.
- Mit `.keep` bestimmt ihr, welche bestehenden Spalten erhalten bleiben (`"all"`, `"used"`, `"unused"`, `"none"`).
- `transmute()` ist eine Kurzform f√ºr `mutate(..., .keep = "none")`.

Mit `select()` und `mutate()` k√∂nnt ihr Spalten ausw√§hlen, ver√§ndern und neue berechnen. Im n√§chsten Kapitel dreht sich alles um die Frage, welche Zeilen f√ºr eure Analyse relevant sind (siehe @sec-filter).
