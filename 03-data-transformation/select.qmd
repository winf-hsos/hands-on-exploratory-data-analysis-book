# Variablen ausw√§hlen {#sec-select}

```{r}
#| include: false
source("setup.R")
```

Nachdem ihr im vorherigen Kapitel einen ersten √úberblick √ºber euren Datensatz gewonnen habt, geht es nun an das gezielte Aufr√§umen. In diesem Kapitel lernt ihr die Funktion `select()` aus dem `dplyr`-Paket kennen. Wir zeigen euch, wie ihr bestimmte Spalten ausw√§hlt, √ºberfl√ºssige Spalten entfernt, die Reihenfolge der Variablen ver√§ndert und Spalten bei der Auswahl direkt umbenennt.

Das gezielte Ausw√§hlen von Variablen ist ein zentraler Bestandteil der Datenvorbereitung, da reale Datens√§tze oft hunderte von Spalten enthalten, von denen f√ºr eine spezifische Analyse nur eine Handvoll relevant ist. Durch das Reduzieren des Datensatzes auf das Wesentliche behaltet ihr den √úberblick, vermeidet Ablenkungen und macht eure Analysen deutlich strukturierter. Ihr k√∂nnt euch das wie das Packen eines Rucksacks vorstellen: Ihr nehmt nur das mit, was ihr f√ºr die n√§chste Etappe braucht, der Rest bleibt zu Hause.

Die folgende Tabelle zeigt die Funktionen, die wir in diesem Abschnitt kennenlernen.

| Funktion | Beschreibung |
|---|---|
| `select()` | Spalten ausw√§hlen, entfernen oder umordnen |
| `rename()` | Spalten umbenennen, ohne die Auswahl zu √§ndern |
| `starts_with()` / `ends_with()` / `contains()` | Spalten nach Namensmuster ausw√§hlen |
| `matches()` | Spalten mit regul√§rem Ausdruck ausw√§hlen |
| `all_of()` / `any_of()` | Spalten √ºber einen Vektor ausw√§hlen |
| `where()` | Spalten nach Datentyp ausw√§hlen |
| `relocate()` | Spalten an eine andere Position verschieben |

Bevor wir Variablen gezielt ausw√§hlen, werfen wir einen gemeinsamen Blick auf die verf√ºgbaren Spalten im Datensatz.

Wir nutzen in diesem Kapitel wieder den Tweets Datensatz. Wenn ihr euch erst einmal orientieren wollt, schaut euch kurz die Spalten an:

::: {.reuse #select-first-glimpse}

```{r}
tweets |>
  glimpse()
```

:::

In diesem Kapitel kl√§ren wir drei Dinge:

::: {.reuse #select-learning-objectives}

- Wie w√§hlt ihr einzelne und mehrere Spalten aus, und wie werft ihr Spalten gezielt weg?
- Wie nutzt ihr Auswahl Helfer wie `starts_with()` oder `contains()`, damit eure Auswahl flexibel bleibt?
- Wie w√§hlt ihr Spalten dynamisch aus, zum Beispiel aus einem Vektor oder nach Datentyp?

:::

## Das Grundprinzip {#sec-select-grundprinzip}

`select()` nimmt einen Tibble und gibt einen Tibble zur√ºck. Nur die Spalten √§ndern sich.

Die einfachste Form ist die Auswahl einzelner Spalten:

::: {.reuse #select-basics-single}

```{r}
tweets |>
  select(screen_name)
```

:::

Mehrere Spalten schreibt ihr einfach hintereinander:

::: {.reuse #select-basics-multiple}

```{r}
tweets |>
  select(screen_name, retweet_count, favorite_count)
```

:::

Ein praktischer Nebeneffekt ist die Reihenfolge. `select()` ordnet die Spalten genau so an, wie ihr sie angebt. Das ist hilfreich, wenn ihr euch eine Ausgabe gezielt lesbar machen wollt:

::: {.reuse #select-basics-order}

```{r}
tweets |>
  select(retweet_count, favorite_count, screen_name, text) |>
  head(3)
```

:::

_Abbildung: Eine Skizze, die einen Datensatz als Tabelle zeigt. Ein Marker hebt vier Spalten hervor, die in eine kleinere Tabelle √ºbernommen werden. Ein Pfeil zeigt, dass `select()` die Spalten ausw√§hlt und dabei die Reihenfolge neu anordnet._

## Spalten entfernen {#sec-select-entfernen}

Manchmal ist es einfacher zu sagen, was weg soll. In `select()` k√∂nnt ihr Spalten mit einem Minus entfernen.

::: {.reuse #select-drop-one}

```{r}
tweets |>
  select(-text) |>
  head(3)
```

:::

Das funktioniert auch mit mehreren Spalten:

::: {.reuse #select-drop-multiple}

```{r}
tweets |>
  select(-text, -is_retweet) |>
  head(3)
```

:::

Wenn ihr euch die Spaltennamen anschauen wollt, hilft `names()`:

::: {.reuse #select-names}

```{r}
names(tweets)
```

:::

::: {.callout-tip icon="üí°" title="Wenn `select()` meckert"}
Wenn ihr euch bei einem Spaltennamen vertippt, bekommt ihr eine Fehlermeldung. Das ist gut, denn es verhindert stillschweigende Fehler. Schaut dann als Erstes in `names(tweets)`, ob der Name genau so geschrieben ist.
:::

## Umbenennen {#sec-select-umbenennen}

Ihr k√∂nnt Spalten in `select()` auch direkt umbenennen. Das Muster ist:

`neuer_name = alter_name`

::: {.reuse #select-rename-inline}

```{r}
tweets |>
  select(
    user = screen_name,
    likes = favorite_count,
    retweets = retweet_count,
    text
  ) |>
  head(3)
```

:::

Das ist praktisch, wenn ihr ohnehin gerade eine Auswahl baut. Wenn ihr dagegen nur umbenennen wollt, ohne die Spaltenauswahl zu √§ndern, ist `rename()` die bessere Wahl:

```{r}
tweets |>
  rename(user = screen_name, likes = favorite_count) |>
  head(3)
```

Mit `rename()` bleiben alle Spalten erhalten, nur die genannten bekommen einen neuen Namen.

## Spaltenmuster {#sec-select-muster}

In echten Projekten √§ndern sich Datens√§tze. Es kommen Spalten dazu, Namen √§ndern sich leicht, oder ihr bekommt eine zweite Version einer Datei. Dann ist es hilfreich, nicht alles hart auszuschreiben, sondern √ºber Muster auszuw√§hlen.

### `starts_with()`, `ends_with()`, `contains()`

Diese drei Helfer sind schnell verstanden:

- `starts_with("...")`: Name beginnt mit diesem Text
- `ends_with("...")`: Name endet mit diesem Text
- `contains("...")`: Name enth√§lt diesen Text

Damit das reproduzierbar ist, schauen wir uns die Idee kurz an einem Mini Datensatz an:

::: {.reuse #select-helpers-mini-data}

```{r}
mini <- tibble(
  user_name = c("a", "b"),
  user_id = c(1, 2),
  tweet_text = c("hi", "bye"),
  tweet_id = c(10, 20)
)

mini |>
  select(starts_with("user"))
```

:::

Und genauso funktionieren die Helfer auch in gr√∂√üeren Datens√§tzen. Wenn eure Spalten sinnvolle Pr√§fixe oder Suffixe haben, spart ihr euch viel Tipparbeit.

### `matches()` f√ºr regul√§re Ausdr√ºcke

`matches()` ist die fortgeschrittene Variante, wenn ihr ein Muster sehr genau beschreiben wollt. Dahinter stecken regul√§re Ausdr√ºcke.

::: {.reuse #select-matches-mini}

```{r}
mini |>
  select(matches("_(id|text)$"))
```

:::

Wenn euch regul√§re Ausdr√ºcke neu sind, merkt euch erst einmal diese Idee: Ihr k√∂nnt damit sehr pr√§zise sagen, wie Spaltennamen aussehen sollen.

### `everything()` und `last_col()`

Manchmal wollt ihr nur einzelne Spalten an eine bestimmte Stelle schieben. Daf√ºr k√∂nnt ihr `everything()` nutzen, das f√ºr alle √ºbrigen Spalten steht.

::: {.reuse #select-everything}

```{r}
tweets |>
  select(screen_name, everything()) |>
  head(3)
```

:::

`last_col()` ist √§hnlich praktisch, wenn ihr Bereiche √ºber das Ende eines Datensatzes ausdr√ºcken wollt. Das ist vor allem bei vielen Spalten hilfreich.

## Bereiche {#sec-select-bereiche}

Ihr k√∂nnt Spalten auch als Bereich ausw√§hlen, zum Beispiel `a:c`. Das funktioniert allerdings nur, wenn die Spalten im Datensatz in dieser Reihenfolge vorkommen.

Damit ihr den Mechanismus sicher seht, nutzen wir wieder einen kleinen Datensatz:

::: {.reuse #select-range-colon}

```{r}
toy <- tibble(a = 1, b = 2, c = 3, d = 4)

toy |>
  select(b:d)
```

:::

In euren eigenen Daten ist `:` vor allem dann praktisch, wenn Spaltenbl√∂cke zusammenh√§ngen, zum Beispiel Messwerte von `m1` bis `m20`.

## Dynamische Auswahl {#sec-select-dynamisch}

Oft habt ihr eine Liste von Spaltennamen, die ihr ausw√§hlen wollt. Vielleicht kommt sie aus einem Skript, aus einer Konfiguration oder ihr baut sie dynamisch zusammen.

Wenn ihr einfach einen Vektor in `select()` schreibt, funktioniert das nicht so, wie ihr es vermutlich erwartet. Stattdessen nutzt ihr `all_of()` oder `any_of()`:

- `all_of(cols)`: alle Spalten m√ºssen existieren, sonst gibt es einen Fehler
- `any_of(cols)`: nimmt, was existiert, und ignoriert den Rest

::: {.reuse #select-all-of-any-of}

```{r}
#| error: true
cols <- c("screen_name", "retweet_count", "does_not_exist")

# all_of() ist strikt und hilft, Fehler fr√ºh zu finden.
# Dieser Aufruf wirft hier absichtlich einen Fehler, weil eine Spalte nicht existiert.
tweets |>
  select(all_of(cols))
```

```{r}
cols <- c("screen_name", "retweet_count", "does_not_exist")

# any_of() ist tolerant, wenn sich Spalten je nach Version unterscheiden
tweets |>
  select(any_of(cols)) |>
  head(3)
```

:::

`all_of()` ist oft die bessere Wahl, wenn ihr euch auf eine feste Struktur verlasst. `any_of()` ist hilfreich, wenn ihr bewusst mit mehreren Datensatz Varianten arbeiten wollt.

## Auswahl nach Datentyp {#sec-select-datentyp}

Manchmal wollt ihr nicht nach Namen ausw√§hlen, sondern nach Eigenschaften. Zum Beispiel alle numerischen Spalten, weil ihr sie gleich zusammenfassen oder visualisieren wollt.

Das geht mit `where()`:

::: {.reuse #select-where-numeric}

```{r}
tweets |>
  select(where(is.numeric)) |>
  glimpse()
```

:::

Ihr k√∂nnt `where()` auch kombinieren, zum Beispiel alle Zeichen Spalten, aber ohne den Text:

::: {.reuse #select-where-combine}

```{r}
tweets |>
  select(where(is.character), -text) |>
  head(3)
```

:::

_Abbildung: Zwei Filterkarten. Karte eins hei√üt "Namensmuster" und zeigt `starts_with()`, `contains()`, `matches()`. Karte zwei hei√üt "Eigenschaften" und zeigt `where(is.numeric)`. Beide f√ºhren in denselben Ausgang "select()". Der Fokus ist, dass es zwei Denkweisen gibt._

## Weitere Werkzeuge {#sec-select-weitere}

### `num_range()` f√ºr durchnummerierte Spalten

Wenn Spalten durchnummeriert sind, hilft `num_range()`. Das ist typisch bei Messreihen oder Umfrageitems wie `q1`, `q2`, `q3`.

::: {.reuse #select-num-range}

```{r}
survey_like <- tibble(q1 = 1, q2 = 2, q3 = 3, meta = "x")

survey_like |>
  select(num_range("q", 1:3))
```

:::

### Optionales Entfernen mit `-any_of()`

Manchmal wollt ihr Spalten entfernen, die vielleicht gar nicht in jeder Version eures Datensatzes existieren. Dann ist `-any_of()` praktisch:

::: {.reuse #select-drop-any-of}

```{r}
tweets |>
  select(-any_of(c("text", "does_not_exist"))) |>
  head(3)
```

:::

### Gruppierte Daten: Gruppierungsvariablen bleiben erhalten

Ein Detail, das euch sp√§ter viel Zeit sparen kann: Wenn ein Tibble gruppiert ist, beh√§lt `select()` die Gruppierungsvariablen auch dann, wenn ihr sie nicht explizit ausw√§hlt.

::: {.reuse #select-grouped-keeps-groups}

```{r}
tweets |>
  group_by(screen_name) |>
  select(retweet_count) |>
  head(3)
```

:::

## Spalten umordnen mit `relocate()` {#sec-select-relocate}

Manchmal wollt ihr Spalten nicht ausw√§hlen oder entfernen, sondern nur an eine andere Stelle schieben. Daf√ºr gibt es `relocate()`. Es verschiebt Spalten, ohne die √ºbrigen zu ver√§ndern:

```{r}
tweets |>
  relocate(text, .before = screen_name) |>
  head(3)
```

Mit `.before` und `.after` legt ihr fest, wohin die Spalte wandert. Wenn ihr mehrere Spalten auf einmal verschieben wollt, funktionieren auch die bekannten Helfer wie `starts_with()` oder `where()`:

```{r}
tweets |>
  relocate(where(is.numeric), .after = last_col()) |>
  head(3)
```

`relocate()` ist eine gute Alternative zu dem Trick mit `select(spalte, everything())`, weil die Absicht klarer ist.

## Einsatz in Pipe-Ketten {#sec-select-pipe}

In der explorativen Analyse nutzt ihr `select()` selten allein. Meist ist es ein Schritt in einer Pipe-Kette, um die Sicht auf den Datensatz zu fokussieren.

Hier ist ein typisches Muster: erst ausw√§hlen, dann kurz pr√ºfen.

::: {.reuse #select-chain-glimpse}

```{r}
tweets |>
  select(screen_name, retweet_count, favorite_count) |>
  glimpse()
```

:::

Wenn ihr danach weiterarbeitet, habt ihr weniger Ballast in eurem Kopf und in euren Ausgaben.

## Kurz zusammengefasst {#sec-select-zusammenfassung}

::: {.reuse #select-summary}

- `select()` w√§hlt Spalten aus, ordnet sie um und kann sie auch umbenennen.
- Mit `-spalte` entfernt ihr Spalten, statt sie aufzuz√§hlen.
- Mit Helfern wie `starts_with()` oder `matches()` bleibt eure Auswahl flexibel.
- Mit `all_of()` und `any_of()` w√§hlt ihr Spalten √ºber Vektoren aus, strikt oder tolerant.
- Mit `where()` w√§hlt ihr Spalten nach Datentyp aus, zum Beispiel alle numerischen Spalten.

:::

Ihr wisst jetzt, wie ihr euren Datensatz auf die relevanten Spalten zuschneidet. Im n√§chsten Kapitel lernt ihr, wie ihr bestehende Spalten mit `mutate()` ver√§ndern k√∂nnt, zum Beispiel um Datentypen zu korrigieren oder Texte zu normalisieren (siehe @sec-mutate-modify).
