# Histogramme {#sec-histograms}

```{r}
#| include: false
source("setup.R")
```

Histogramme zeigen, wie sich die Werte einer numerischen Variable verteilen. Statt einzelne Datenpunkte darzustellen, werden die Werte in Intervalle (Bins) eingeteilt und die H√§ufigkeit pro Intervall als Balken dargestellt. Claus Wilke beschreibt Histogramme als die nat√ºrliche Wahl, wenn ihr die Form einer Verteilung untersuchen wollt ‚Äî ob symmetrisch, schief oder mit mehreren Gipfeln [@wilke_fundamentals_2019].

## Einfaches Histogramm

Wie sieht die Verteilung der Retweet-Zahlen aus? Die meisten Tweets bekommen wenige Retweets, einige wenige bekommen sehr viele:

```{r}
#| label: fig-hist-basic
#| fig-cap: "Verteilung der Retweet-Zahlen."
tweets |>
  filter(!is_retweet) |>
  ggplot() +
  aes(x = retweet_count) +
  geom_histogram()
```

`ggplot2` zeigt eine Meldung, dass es 30 Bins verwendet hat (`bins = 30`). Das ist der Standardwert, aber nicht immer ideal.

## Bins einstellen

Die Anzahl der Bins beeinflusst, wie viel Detail ihr seht. Zu wenige Bins verbergen Muster, zu viele erzeugen Rauschen:

```{r}
#| label: fig-hist-bins-10
#| fig-cap: "Histogramm mit 10 Bins: grob, aber √ºbersichtlich."
tweets |>
  filter(!is_retweet) |>
  ggplot() +
  aes(x = retweet_count) +
  geom_histogram(bins = 10)
```

```{r}
#| label: fig-hist-bins-100
#| fig-cap: "Histogramm mit 100 Bins: mehr Detail, aber auch mehr Rauschen."
tweets |>
  filter(!is_retweet) |>
  ggplot() +
  aes(x = retweet_count) +
  geom_histogram(bins = 100)
```

Alternativ k√∂nnt ihr statt der Anzahl die Breite der Bins festlegen:

```{r}
#| label: fig-hist-binwidth
#| fig-cap: "Histogramm mit einer Binbreite von 50."
tweets |>
  filter(!is_retweet) |>
  ggplot() +
  aes(x = retweet_count) +
  geom_histogram(binwidth = 50)
```

::: {.callout-tip icon="üí°" title="Bins ausprobieren"}
Es gibt keine perfekte Bin-Anzahl. Probiert zwei, drei Werte aus und schaut, welcher die Verteilung am klarsten zeigt. Das ist ein normaler Teil der explorativen Analyse.
:::

## Schiefe Verteilungen

Daten wie Retweet-Zahlen, Ums√§tze oder Follower-Zahlen sind oft stark rechtsschief: Die meisten Werte sind klein, einige wenige sind extrem gro√ü. In solchen F√§llen hilft es, den Blick auf einen Ausschnitt zu richten:

```{r}
#| label: fig-hist-zoom
#| fig-cap: "Histogramm mit Fokus auf den Bereich 0‚Äì500 Retweets."
tweets |>
  filter(!is_retweet, retweet_count <= 500) |>
  ggplot() +
  aes(x = retweet_count) +
  geom_histogram(binwidth = 10)
```

Alternativ k√∂nnt ihr eine logarithmische Skala verwenden:

```{r}
#| label: fig-hist-log
#| fig-cap: "Histogramm mit logarithmischer x-Achse."
tweets |>
  filter(!is_retweet, retweet_count > 0) |>
  ggplot() +
  aes(x = retweet_count) +
  geom_histogram(bins = 30) +
  scale_x_log10()
```

## Gruppen vergleichen

### √úberlagerte Histogramme

Um die Verteilung zweier Gruppen zu vergleichen, k√∂nnt ihr sie √ºberlagern. `alpha` sorgt daf√ºr, dass beide sichtbar bleiben:

```{r}
#| label: fig-hist-overlay
#| fig-cap: "√úberlagerte Histogramme vergleichen zwei Gruppen."
tweets |>
  ggplot() +
  aes(x = retweet_count, fill = is_retweet) +
  geom_histogram(bins = 30, alpha = 0.5, position = "identity") +
  scale_x_log10()
```

`position = "identity"` ist hier wichtig, sonst stapelt `ggplot2` die Histogramme √ºbereinander statt sie zu √ºberlagern.

### Facetten

Bei mehr als zwei Gruppen werden √ºberlagerte Histogramme schnell unlesbar. Facetten sind dann die bessere Wahl:

```{r}
#| label: fig-hist-facet
#| fig-cap: "Facetten zeigen die Verteilung pro Sprache."
tweets |>
  filter(!is_retweet, lang %in% c("de", "en", "fr"), retweet_count > 0) |>
  ggplot() +
  aes(x = retweet_count) +
  geom_histogram(bins = 30) +
  facet_wrap(~ lang) +
  scale_x_log10()
```

## Dichtekurven als Alternative

`geom_density()` zeichnet eine gegl√§ttete Kurve statt diskreter Balken. Das kann hilfreich sein, wenn ihr die Form der Verteilung hervorheben wollt:

```{r}
#| label: fig-hist-density
#| fig-cap: "Dichtekurven gl√§tten die Verteilung."
tweets |>
  filter(!is_retweet, retweet_count > 0) |>
  ggplot() +
  aes(x = retweet_count, fill = is_quote_status) +
  geom_density(alpha = 0.4) +
  scale_x_log10()
```

Dichtekurven eignen sich besonders gut f√ºr Vergleiche, weil sich die Kurven leichter √ºberlagern lassen als Balken [@wilke_fundamentals_2019].

## Typische Fehler

### Standardwerte nicht hinterfragen

Die 30 Standard-Bins sind ein Startpunkt, nicht die richtige Wahl. Passt `bins` oder `binwidth` immer bewusst an.

### Gruppen ohne `position = "identity"`

Wenn ihr Histogramme zweier Gruppen √ºberlagern wollt, vergesst nicht `position = "identity"`. Sonst werden sie gestapelt, und ihr seht nicht die echte Verteilung.

### Nullwerte bei Log-Skalen

`log10(0)` ist nicht definiert. Filtert Nullwerte heraus, wenn ihr logarithmische Skalen verwendet.

## Kurz zusammengefasst

- `geom_histogram()` zeigt die Verteilung einer numerischen Variable.
- Steuert die Aufl√∂sung mit `bins` oder `binwidth`. Probiert verschiedene Werte aus.
- Bei schiefen Verteilungen helfen Zoom (`filter`) oder logarithmische Skalen.
- Vergleicht Gruppen mit `fill` + `position = "identity"` oder mit `facet_wrap()`.
- `geom_density()` ist eine gegl√§ttete Alternative, besonders gut f√ºr Gruppenvergleiche.
