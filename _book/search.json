[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Exploratory Data Analytics",
    "section": "",
    "text": "Vorwort\nDieses Buch f√ºhrt in die Werkzeuge der explorativen Datenanalyse ein. Konkretes Werzeug, mit dem wir unsere Analysen erstellen, ist R in Kombination mit dem Tidyverse. F√ºr manche Aufgaben im Buch verwenden wir auch Python, insbesondere f√ºr die Anwendung von Werkzeugen aus dem Bereich des maschinellen Lernens.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html",
    "href": "project-1-survey/survey-data.html",
    "title": "1¬† Umfragedaten",
    "section": "",
    "text": "1.1 Daten laden mit R\nIn diesem Projekt geht es um die Analyse eines Umfragedatensatzes. Umfragen sind ein praktisches Werkzeug, wenn wir etwas √ºber Einstellungen, Pr√§ferenzen oder Verhalten von Menschen herausfinden wollen ‚Äì und genau solche Datens√§tze begegnen euch sp√§ter auch im Job ziemlich h√§ufig.\nBevor wir loslegen, eine Leitfrage: Wenn ihr eine Tabelle mit hunderten Spalten vor euch habt ‚Äì woher wisst ihr eigentlich, was ihr da seht? Was ist eine Zeile? Was ist eine Spalte? Und wie k√∂nnt ihr schnell pr√ºfen, ob die Daten √ºberhaupt korrekt in R angekommen sind? Genau darum geht es in diesem Abschnitt.\nIn jedem Projekt steht am Anfang das Laden der Daten. In diesem Buch gehen wir davon aus, dass ein Datensatz bereits erhoben wurde. Die Datenerhebung ist nicht direkt Bestandteil dieses Buches ‚Äì es geht prim√§r um die Datenanalyse.\nDie Umfrageergebnisse wurden mit der Software Limesurvey erhoben und als CSV-Datei exportiert. Wenn ihr das GitHub-Repository f√ºr dieses Buch auf euren Rechner heruntergeladen habt, dann liegen die Daten im Ordner /data und k√∂nnen so geladen werden:\nlibrary(tidyverse)\nsurvey &lt;- read_csv(\"data/mds12_schoko_milch.csv\")\nNach Ausf√ºhrung des Codeblocks stehen die Daten auf dem Objekt survey als Tibble bereit. Es ist eine gute Idee, f√ºr h√§ufig verwendete Objekte kurze, aber sprechende Namen zu w√§hlen ‚Äì survey ist hier ein guter Kompromiss.\nZum Laden der Daten geh√∂rt immer auch ein kurzer Reality-Check: Sind wirklich alle Beobachtungen (Zeilen) und Variablen (Spalten) da? Genau diese Frage beantworten wir im n√§chsten Abschnitt.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#daten-laden-mit-r",
    "href": "project-1-survey/survey-data.html#daten-laden-mit-r",
    "title": "1¬† Umfragedaten",
    "section": "",
    "text": "WarnungAchtet auf den Unterstrich\n\n\n\nBitte achtet auf die Verwendung der richtigen Funktion read_csv. Es gibt in R auch eine Funktion mit dem Namen read.csv, die sehr √§hnlich ist, aber keinen Tibble erzeugt. Wir verwenden in diesem Buch durchgehend das Tidyverse und Tibbles.\n\n\n\n\n\n\n\n\n\n\nHinweisMehr zum Laden von Daten laden (auch weitere Formate)\n\n\n\nAn dieser Stelle gehen wir nicht tiefer auf das Laden von Daten und andere Formate ein. Einen detaillierten Einblick findet ihr in Kapitel 8.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#kontext-und-metainformationen",
    "href": "project-1-survey/survey-data.html#kontext-und-metainformationen",
    "title": "1¬† Umfragedaten",
    "section": "1.2 Kontext und Metainformationen",
    "text": "1.2 Kontext und Metainformationen\n\nStellt euch vor, ihr bekommt eine Excel-Datei per Mail ‚Äì ohne Begleittext. Ihr k√∂nnt sie √∂ffnen, aber ihr wisst nicht, wer befragt wurde, wann die Erhebung stattgefunden hat oder was die Antwortcodes bedeuten. Ihr k√∂nnt dann zwar rechnen, aber ihr lauft Gefahr, das Falsche zu interpretieren. Ein paar Begleitinformationen in der E-Mail w√§ren daher nicht schlecht. Vielleicht so etwas:\n\n‚ÄúDer verwendete Datensatz wurde am Fachgebiet Agrar√∂konomie der Hochschule Osnabr√ºck unter Leitung von Prof.¬†Dr.¬†Ulrich Enneking im Jahr 2025 erhoben. In einer umfangreichen, mehrteiligen Online-Umfrage wurden deutschlandweit Menschen zu Einstellungen und Kaufverhalten bei Lebensmitteln befragt. An der Umfrage haben 2.811 Personen teilgenommen.‚Äù\nSolche Informationen nennen wir Metainformationen (meta = √ºber) oder Kontextinformationen. H√§ufig lassen sie sich als W‚ÄëFragen formulieren. Tabelle¬†1.1 fasst die wichtigsten f√ºr unseren Datensatz zusammen:\n\n\n\nTabelle¬†1.1: Metainformationen zum Umfragedatensatz\n\n\n\n\n\n\n\n\n\nW‚ÄëFrage\nAntwort\n\n\n\n\nWer hat die Daten erhoben?\nProf.¬†Dr.¬†Enneking\n\n\nWie wurden die Daten erhoben?\nOnline-Umfrage\n\n\nWann wurden die Daten erhoben?\n2025\n\n\nWo wurden die Daten erhoben?\nonline\n\n\nWer wurde befragt?\n2.811 Menschen deutschlandweit\n\n\nWas wurde erhoben?\nEinstellungen und Kaufverhalten bei Lebensmitteln\n\n\n\n\n\n\nEine Frage ist dabei besonders wichtig, weil sie bestimmt, wie wir sp√§ter Zahlen interpretieren: Was repr√§sentiert eine Zeile in den Daten? Was sehen wir eigentlich, wenn wir eine Zeile betrachten? Auf diese Frage brauchen wir eine klare Antwort, bevor wir mit der Analyse beginnen. Manchmal kann man es durch genaues Hinschauen erraten ‚Äì aber der Schein kann tr√ºgen. Wenn wir die Daten nicht selbst erhoben haben, sollten wir diese Information aus sicherer Quelle bekommen. In diesem Beispiel habe ich nachgefragt: Eine Zeile entspricht den Antworten einer Person auf die Online‚ÄëUmfrage. In der empirischen Forschung sprechen wir dann von Beobachtungen.\n\nEmpirical research is any research that uses structured observations from the real world to attempt to answer questions. (Huntington-Klein 2026)\n\nWenn wir wissen, dass jede Zeile eine befragte Person ist, k√∂nnen wir auch sauber begr√ºnden, warum die Anzahl der Zeilen gleich der Anzahl der Teilnehmenden ist.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#dimensionierung-der-daten",
    "href": "project-1-survey/survey-data.html#dimensionierung-der-daten",
    "title": "1¬† Umfragedaten",
    "section": "1.3 Dimensionierung der Daten",
    "text": "1.3 Dimensionierung der Daten\nEs gibt mehrere Wege, die Anzahl der Beobachtungen zu bestimmen. Ein sehr direkter ist count(): Wenn wir count() ohne Variable aufrufen, z√§hlt R schlicht die Zeilen.\n\nsurvey |&gt;\n1  count()\n\n\n1\n\nDer Befehl count() z√§hlt die Beobachtungen (Zeilen) in einem Datensatz.\n\n\n\n\n# A tibble: 1 √ó 1\n      n\n  &lt;int&gt;\n1  2811\n\n\nEine zweite, oft sehr praktische M√∂glichkeit ist: Gebt einfach den Namen des Tibbles aus. Tibbles zeigen euch direkt eine kompakte Zusammenfassung inkl. Dimensionen (Zeilen x Spalten) und eine Vorschau.\n\nsurvey\n\n# A tibble: 2,811 √ó 813\n   q001hheinkauf q002geburt q003land q004geschlecht q005os v041nofleisch\n           &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1             2       1970        1              1      0             0\n 2             1       1990        7              1      0             0\n 3             2       1963        6              1      0             0\n 4             2       1989       13              2      0             1\n 5             2       1965        4              1      0             1\n 6             2       1957        2              1      0             0\n 7             2       1960       14              2      0             1\n 8             2       1984       13              1      0             0\n 9             2       1974        1              2      0             0\n10             2       1954       13              2      0             0\n# ‚Ñπ 2,801 more rows\n# ‚Ñπ 807 more variables: v041nofleisch_other &lt;chr&gt;, v041diaet_0nodiaet &lt;dbl&gt;,\n#   v041diaet_1lowcarb &lt;dbl&gt;, v041diaet_2laktose &lt;dbl&gt;,\n#   v041diaet_3gluten &lt;dbl&gt;, v041diaet_4paleo &lt;dbl&gt;, v041diaet_5ketogen &lt;dbl&gt;,\n#   v041diaet_6rohkost &lt;dbl&gt;, v041diaet_7makro &lt;dbl&gt;, v041diaet_8trenn &lt;dbl&gt;,\n#   v041diaet_9frutarisch &lt;dbl&gt;, v041diaet_10fleisch &lt;dbl&gt;,\n#   v041diaet_11mediterran &lt;dbl&gt;, v041diaet_12histaminarm &lt;dbl&gt;, ‚Ä¶\n\n\nIn der ersten Zeile der Ausgabe steht die Dimensionierung der Daten. Wir bekommen also nicht nur die Information, wie viele Beobachtungen (2.811) vorhanden sind, sondern auch, wie viele Variablen der Datensatz hat (813). Danach folgen die ersten Zeilen (und so viele Spalten, wie auf die Konsole passen). Tibbles achten darauf, die Konsole nicht komplett mit Text zu fluten, und schneiden daher irgendwann ab.\nManchmal wollen wir die Anzahl Zeilen und Spalten nicht nur wissen, sondern weiterverwenden. Wir k√∂nnen sie dann auf Objekten speichern:\n\nrows &lt;- nrow(survey)\ncols &lt;- ncol(survey)\n\nprint(str_glue(\"Der Datensatz hat {rows} Zeilen und {cols} Spalten.\"))\n\nDer Datensatz hat 2811 Zeilen und 813 Spalten.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#variablen-spalten",
    "href": "project-1-survey/survey-data.html#variablen-spalten",
    "title": "1¬† Umfragedaten",
    "section": "1.4 Variablen (Spalten)",
    "text": "1.4 Variablen (Spalten)\nNeben der Frage ‚ÄûWas ist eine Zeile?‚Äú ist die zweite Kernfrage: ‚ÄûWas misst jede Spalte?‚Äú In Umfragen steckt hinter fast jeder Frage (und oft hinter jeder Antwortoption) eine eigene Variable ‚Äì deshalb werden solche Datens√§tze schnell sehr ‚Äûspaltenreich‚Äú.\n\nA variable, in the context of empirical research, is a bunch of observations of the same measurement. (Huntington-Klein 2026)\n\nBeobachtungen stellen wir typischerweise horizontal (in Zeilen) dar, Variablen vertikal (in Spalten).\n\n\n\n\n\n\nAbbildung¬†1.1: Beobachtungen repr√§sentieren wir als Zeilen, Variablen als Spalten.\n\n\n\nIm Idealfall gibt es zu einem Datensatz ein Data Dictionary (oder Codebuch): eine Art W√∂rterbuch, in dem jede Variable aufgef√ºhrt und inhaltlich erl√§utert ist. Das ist Gold wert ‚Äì denn aus reinen Spaltennamen wie q001hheinkauf k√∂nnt ihr die Bedeutung oft nicht zuverl√§ssig ableiten.\nDamit ihr trotzdem schnell arbeitsf√§hig werdet, schauen wir uns jetzt Werkzeuge an, mit denen ihr Variablen in R systematisch ‚Äûabklopfen‚Äú k√∂nnt:\n\nWie viele Variablen gibt es?\nWelche Namen und Datentypen haben sie?\nWelche Werte kommen in einer Variable √ºberhaupt vor?\n\n\nWie viele Variablen?\nDie Anzahl der Variablen habt ihr bereits √ºber die Tibble-Ausgabe gesehen. Ihr k√∂nnt sie aber auch direkt als Wert auslesen. Hier die Variante mit der Pipe:\n\nsurvey |&gt;\n  ncol()\n\n[1] 813\n\n\nDen Wert k√∂nnt ihr auf einem neuen Objekt speichern und sp√§ter wiederverwenden , das ist in Skripten h√§ufig n√ºtzlich:\n\nvariable_count &lt;- ncol(survey)\n1print(str_glue(\"Der Datensatz hat {variable_count} Variablen.\"))\n\n\n1\n\nMit str_glue() k√∂nnt ihr Zeichenketten mit Platzhaltern versehen, die bei der Ausf√ºhrung mit Werten ersetzt werden.\n\n\n\n\nDer Datensatz hat 813 Variablen.\n\n\n\n\nNamen, Typen, erste Werte: select() + glimpse()\nSchauen wir uns f√ºrs Erste nur die ersten 10 Variablen im Datensatz an:\n\nsurvey |&gt;\n1  select(1:10) |&gt;\n2  glimpse()\n\n\n1\n\nMit select() k√∂nnt ihr Variablen ausw√§hlen. Die Notation 1:10 bedeutet: Variablen an Position 1 bis 10.\n\n2\n\nMit glimpse() bekommt ihr schnell eine √úbersicht der Namen, Datentypen und ersten Werte der Variablen.\n\n\n\n\nRows: 2,811\nColumns: 10\n$ q001hheinkauf       &lt;dbl&gt; 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1,‚Ä¶\n$ q002geburt          &lt;dbl&gt; 1970, 1990, 1963, 1989, 1965, 1957, 1960, 1984, 19‚Ä¶\n$ q003land            &lt;dbl&gt; 1, 7, 6, 13, 4, 2, 14, 13, 1, 13, 5, 14, 9, 4, 3, ‚Ä¶\n$ q004geschlecht      &lt;dbl&gt; 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1,‚Ä¶\n$ q005os              &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n$ v041nofleisch       &lt;dbl&gt; 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,‚Ä¶\n$ v041nofleisch_other &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA‚Ä¶\n$ v041diaet_0nodiaet  &lt;dbl&gt; 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1,‚Ä¶\n$ v041diaet_1lowcarb  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n$ v041diaet_2laktose  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,‚Ä¶\n\n\nHier steckt direkt ein wichtiges Muster drin: Wir bauen eine kleine ‚ÄûBefehlskette‚Äú. Das etwas merkw√ºrdig aussehende Symbol |&gt; (Pipe) sorgt daf√ºr, dass das Ergebnis links an den n√§chsten Befehl rechts √ºbergeben wird. Eine dedizierte Einf√ºhrung in die Pipe findet ihr in Kapitel 9.\nMit der Flexibilit√§t einer Programmiersprache wie R k√∂nnt ihr jede beliebige Menge an Spalten ausw√§hlen ‚Äì zum Beispiel auch die letzten 10:\n\nsurvey |&gt;\n  select(tail(everything(), 10))\n\n# A tibble: 2,811 √ó 10\n   M070handeldiff3_1hochwertig M070handeldiff3_2regio M070handeldiff3_3preis\n                         &lt;dbl&gt;                  &lt;dbl&gt;                  &lt;dbl&gt;\n 1                          NA                     NA                     NA\n 2                          -1                      1                      2\n 3                          NA                     NA                     NA\n 4                          NA                     NA                     NA\n 5                          NA                     NA                     NA\n 6                          NA                     NA                     NA\n 7                          NA                     NA                     NA\n 8                          NA                     NA                     NA\n 9                           2                      2                     -2\n10                          NA                     NA                     NA\n# ‚Ñπ 2,801 more rows\n# ‚Ñπ 7 more variables: M070handeldiff3_4tierwohl &lt;dbl&gt;,\n#   M070handeldiff3_5vielfalt &lt;dbl&gt;, M070handeldiff3_6vetrauen &lt;dbl&gt;,\n#   M070handeldiff3_7nachhaltig &lt;dbl&gt;, M070handeldiff3_8gesund &lt;dbl&gt;,\n#   M070handeldiff3_9kauf &lt;dbl&gt;, M070handeldiff3_10trends &lt;dbl&gt;\n\n\nMit tail() ermitteln wir die letzten n Elemente einer Liste. everything() gibt uns (innerhalb von select()) die Liste aller Spalten. Der Ausdruck l√§sst sich also √ºbersetzen als: Gib mir die letzten 10 Elemente aus der Liste aller Spalten. Gerade bei Umfragen mit vielen Spalten ist dieses gezielte Ausw√§hlen extrem n√ºtzlich. Noch mehr M√∂glichkeiten, Spalten auszuw√§hlen, lernen wir im Verlauf des Projekts und im dedizierten Kapitel 10.\n\n\n\n\n\n\nHinweisVariablen haben eine feste Position\n\n\n\nVariablen (Spalten) haben eine feste Reihenfolge und Position in einem Datensatz. Ihr k√∂nnt eine Spalte daher nicht nur √ºber ihren Namen, sondern auch √ºber ihre Position ansprechen.\n\n\n\n\nWelchen Wertebereich hat eine Variable?\nglimpse() ist super, um schnell einen Eindruck zu bekommen, aber es zeigt euch nur die ersten Werte. Wenn ihr wirklich wissen wollt, welche Auspr√§gungen vorkommen, m√ºsst ihr gezielt nachsehen.\nNehmen wir die Variable q001hheinkauf. Sie geh√∂rt zur Frage, ob die teilnehmende Person f√ºr den Lebensmitteleinkauf hauptverantwortlich ist oder ob die Aufgabe mit einer anderen Person geteilt wird. Im Codebuch zur Umfrage lesen wir nach, dass ‚Äú1‚Äù f√ºr ‚ÄúIch selbst und eine andere Person‚Äù steht, w√§hrend ‚Äú2‚Äù f√ºr ‚ÄúHaupts√§chlich ich selbst‚Äù steht. Der Wert ‚Äú0‚Äù st√ºnde f√ºr ‚ÄúFast immer eine andere Person‚Äù. Aber kommen wirklich nur diese Werte vor? Oder kommen √ºberhaupt alle vor?\nZuerst k√∂nnen wir uns die Spalte als Tibble ausgeben lassen:\n\nsurvey |&gt;\n  select(q001hheinkauf)\n\n# A tibble: 2,811 √ó 1\n   q001hheinkauf\n           &lt;dbl&gt;\n 1             2\n 2             1\n 3             2\n 4             2\n 5             2\n 6             2\n 7             2\n 8             2\n 9             2\n10             2\n# ‚Ñπ 2,801 more rows\n\n\nStandardm√§√üig zeigt R dabei nur die ersten 10 Zeilen. Das k√∂nnt ihr √§ndern:\n\nsurvey |&gt;\n  select(q001hheinkauf) |&gt;\n  print(n = 20)\n\n# A tibble: 2,811 √ó 1\n   q001hheinkauf\n           &lt;dbl&gt;\n 1             2\n 2             1\n 3             2\n 4             2\n 5             2\n 6             2\n 7             2\n 8             2\n 9             2\n10             2\n11             2\n12             1\n13             2\n14             1\n15             2\n16             2\n17             1\n18             1\n19             2\n20             1\n# ‚Ñπ 2,791 more rows\n\n\nAlle Zeilen auszugeben w√ºrde dieses Kapitel sehr lang machen und w√§re gleichzeitig aufw√§ndig zu pr√ºfen. Um dennoch sicher zu wissen, welche Werteauspr√§gungen existieren, k√∂nnen wir uns die eindeutigen Werte ausgeben lassen:\n\nsurvey |&gt;\n  distinct(q001hheinkauf)\n\n# A tibble: 2 √ó 1\n  q001hheinkauf\n          &lt;dbl&gt;\n1             2\n2             1\n\n\nEine kleine √úberraschung, denn die ‚Äú0‚Äù ist nicht vertreten. Hat scheinbar niemand geantwortet. Wenn ihr zus√§tzlich wissen wollt, wie h√§ufig die Auspr√§gungen angekreuzt wurden:\n\nsurvey |&gt;\n  count(q001hheinkauf)\n\n# A tibble: 2 √ó 2\n  q001hheinkauf     n\n          &lt;dbl&gt; &lt;int&gt;\n1             1   919\n2             2  1892\n\n\nDie Funktion count() gruppiert die Daten nach der √ºbergebenen Variable und z√§hlt die Beobachtungen pro Gruppe. Wir stecken schon mittem in der Analyse der Daten ü§ì.\n\n\n\n\n\n\nHinweisAggregieren von Daten\n\n\n\nDie Funktion count() ist eine Aggregationsfunktion. Eine dedizierte Einf√ºhrung, wie man mit R und dem dplyr‚ÄëPaket Daten zusammenfasst, findet ihr in Kapitel 14.\n\n\nUnd weil es gerade passt: Wenn wir Daten analysieren, dann bevorzugen wir in dem allermeisten F√§llen eine aussagekr√§ftige Visualisierung √ºber eine tabellarische Ausgabe. Die H√§ufigkeiten der beiden Antwortm√∂glichkeiten k√∂nnen wir wunderbar als Balkendiagramm visualisieren:\n\nsurvey |&gt;\n  count(q001hheinkauf) |&gt;\n  ggplot() +\n  aes(x = q001hheinkauf, y = n) +\n  geom_col()\n\n\n\n\n\n\n\n\nZugegeben: Das Balkendiagramm ist verbesserungsw√ºrdig, dennoch zeigt es einen wichtigen Aspekt der explorativen Datenanalyse und warum R daf√ºr so gut geeignet ist. Mit nur drei Zeilen Code erstellen wir ein Balkendiagramm, das uns die Verh√§ltnisse der Anworten zur ersten Frage im Datensatz visuell aufzeigt. Und das Diagramm ist inhaltlich korrekt, daf√ºr sorgt die Bibliothek ggplot2, die wir hier verwenden. Es ist daf√ºr nicht wirklich ansprechend (schaut etwas mal die Labels auf der x-Achse an). Aber darum geht es in der explorativen Datenanalyse nicht. Wir wollen schhnell Ergebnisse sehen und flexibel in den Daten w√ºhlen k√∂nnen. Das funktioniert mit R und dem Tidyverse perfekt!\nWir lernen in Kapitel 2 noch mehr dar√ºber, wie wir schnell den Wertebereich einer Variable √ºberblicken k√∂nnen. Als n√§chstes schauen wir auf den zweiten wichtigen Aspekt: Die Beobachtungen.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#beobachtungen-zeilen",
    "href": "project-1-survey/survey-data.html#beobachtungen-zeilen",
    "title": "1¬† Umfragedaten",
    "section": "1.5 Beobachtungen (Zeilen)",
    "text": "1.5 Beobachtungen (Zeilen)\nWas f√ºr Variablen gilt, gilt auch f√ºr Zeilen: Jede hat eine feste Position. Bei Zeilen nennen wir das auch die row number (Zeilennummer). Mit row_number() k√∂nnt ihr diese Position abfragen und damit gezielt Zeilen ausw√§hlen.\n\nsurvey |&gt;\n  select(1:10) |&gt;\n1  filter(row_number() &lt;= 10)\n\n\n1\n\nMit row_number() bekommen wir die Position (Zeilennummer) einer Beobachtung.\n\n\n\n\n# A tibble: 10 √ó 10\n   q001hheinkauf q002geburt q003land q004geschlecht q005os v041nofleisch\n           &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1             2       1970        1              1      0             0\n 2             1       1990        7              1      0             0\n 3             2       1963        6              1      0             0\n 4             2       1989       13              2      0             1\n 5             2       1965        4              1      0             1\n 6             2       1957        2              1      0             0\n 7             2       1960       14              2      0             1\n 8             2       1984       13              1      0             0\n 9             2       1974        1              2      0             0\n10             2       1954       13              2      0             0\n# ‚Ñπ 4 more variables: v041nofleisch_other &lt;chr&gt;, v041diaet_0nodiaet &lt;dbl&gt;,\n#   v041diaet_1lowcarb &lt;dbl&gt;, v041diaet_2laktose &lt;dbl&gt;\n\n\nDie Funktion filter() verwenden wir, um Beobachtungen nach Kriterien einzugrenzen ‚Äì zum Beispiel um nur weibliche Personen zu betrachten. Mit row_number() k√∂nnt ihr stattdessen nach Position filtern, z. B. um ‚ÄûBeispielzeilen‚Äú f√ºr einen ersten Blick zu nehmen.\nStatt ‚Äûkleiner-gleich‚Äú (&lt;=) k√∂nnt ihr nat√ºrlich auch andere Operatoren verwenden:\n\nsurvey |&gt;\n  filter(row_number() == 42) |&gt;\n  select(q004geschlecht)\n\n# A tibble: 1 √ó 1\n  q004geschlecht\n           &lt;dbl&gt;\n1              2\n\n\nDamit habt ihr jetzt die wichtigsten Werkzeuge f√ºr den Start: Daten laden, Kontext verstehen, Dimensionen pr√ºfen, Variablen √ºberblicken und Wertebereiche testen. Im n√§chsten Schritt geht es darum, die Variablen inhaltlich zu interpretieren (Codebuch/Data Dictionary) und die Daten f√ºr Analysen vorzubereiten.\n\n\n\n\nHuntington-Klein, Nick. 2026. The effect: an introduction to research design and causality. Second edition. A Chapman & Hall Book. CRC Press.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html",
    "href": "project-1-survey/types-of-variables.html",
    "title": "2¬† Arten von Variablen",
    "section": "",
    "text": "2.1 Ein Schema zur Orientierung\nIn Kapitel 1 haben wir gesehen, dass Umfragedaten aus vielen unterschiedlichen Spalten bestehen: Manche Spalten sind Zahlen, andere sind Kategorien wie ‚Äûm√§nnlich/weiblich/divers‚Äú, wieder andere enthalten Freitext. Das ist nicht nur ‚ÄûKosmetik‚Äú, der Variablentyp entscheidet ganz praktisch dar√ºber,\nLasst uns deshalb Ordnung in die Spalten bringen: Welche Arten von Variablen gibt es und woran erkennt ihr sie in R?\nUm Variablen sauber abzugrenzen, hilft ein einfaches Schema. Laut Huntington-Klein (2026) unterscheiden wir in der empirischen Forschung zwischen:\nIch w√ºrde einen Schritt weiter gehen und kontinuierliche und Z√§hlvariablen zur Klasse der numerischen Variablen zusammenfassen. Da ordinale Variablen ebenfalls Katgeorien darstellen, die zus√§tzlich geordnet sind, werden Sie ihnen untergeordnet. Daneben gibt es dann die kategorialien Variablen ohne Reihenfolge, die wir nominale Variablen nennen. Qualitative Variablen (sowas wie Texte) bilden ihre eigene Klasse. In Abbildung¬†2.1 ist das Schema zusammengefasst dargestellt.\nWichtig: Diese Einteilung beschreibt das Messniveau (also: was wird gemessen?). Der Datentyp in R (&lt;dbl&gt;, &lt;int&gt;, &lt;chr&gt;, ‚Ä¶) ist ein Hinweis, aber nicht die ganze Wahrheit. In Umfragen werden Kategorien z. B. oft als Zahlen kodiert (1, 2, 3 ‚Ä¶) oder als viele 0/1‚ÄëSpalten (Mehrfachauswahl). Ohne Codebuch/Data Dictionary kann man das leicht falsch lesen.\nSchauen wir uns jetzt die Typen nacheinander an ‚Äì jeweils mit Beispielen aus unserem Datensatz.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#ein-schema-zur-orientierung",
    "href": "project-1-survey/types-of-variables.html#ein-schema-zur-orientierung",
    "title": "2¬† Arten von Variablen",
    "section": "",
    "text": "Kontinuierlichen Variablen\nZ√§hlvariablen\nOrdinalen Variablen\nKategorialen Variablen\nQualitativen Variablen\n\n\n\n\n\n\n\n\nAbbildung¬†2.1: Klassifizierungsschema f√ºr Arten von Variablen.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#numerische-variablen",
    "href": "project-1-survey/types-of-variables.html#numerische-variablen",
    "title": "2¬† Arten von Variablen",
    "section": "2.2 Numerische Variablen",
    "text": "2.2 Numerische Variablen\nNumerische (quantitative) Variablen messen eine Menge oder Gr√∂√üe. Mit ihnen k√∂nnen wir rechnen, im Sinne von Mittelwerte bilden, den Median bestimmen oder eine Spannweite berechnen. Wir unterscheiden dabei zwei grundlende numerische Arten: kontinuierlich und diskret. Anders ausgedr√ºckt: Zahlen mit Kommastelle und ganze Zahlen (ohne Kommastellen)\n\nKontinuierliche Variablen\n\nContinuous variables are variables that could take any value (perhaps within some range). (Huntington-Klein 2026)\n\nIm Umfragedatensatz fragt eine Frage nach der Eingabe eines Preises, den die Teilnehmenden bereit w√§ren, f√ºr einen Liter Milch einer vorgegebenen Marke zu bezahlen:\n‚ÄúGeben Sie f√ºr die 3 Marken bitte den Preis an, den Sie f√ºr angemessen halten und bei dem Sie zugreifen w√ºrden! Als Dezimaltrennzeichen verwenden Sie bitte das Komma.‚Äù\nSchauen wir auf ein paar Beobachtungen. Wie sehen die Antworten aus?\n\nsurvey |&gt;\n  select(u013pzahl_1weihen)\n\n# A tibble: 2,811 √ó 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              1.49\n 2             NA   \n 3             NA   \n 4             NA   \n 5             NA   \n 6             NA   \n 7             NA   \n 8             NA   \n 9            150   \n10             NA   \n# ‚Ñπ 2,801 more rows\n\n\nAnhand der Ausgabe erkennt ihr typischerweise drei Dinge:\n\nDer Datentyp ist &lt;dbl&gt; (double). Das passt zu Dezimalzahlen und ist daher typisch f√ºr kontinuierliche Variablen.\nViele Werte sind NA ‚Äì es fehlen also Angaben. Sp√§ter m√ºssen wir kl√§ren, warum Werte fehlen und wie wir damit umgehen.\nManchmal seht ihr sehr ungew√∂hnliche Werte (z. B. 150 ‚Ç¨). Das sind oft Ausrei√üer ‚Äì z. B. durch Tippfehler.\n\n\nFehlende Werte (‚ÄûNA‚Äú) kurz behandeln\nF√ºr einen ersten √úberblick k√∂nnen wir fehlende Werte herausfiltern (auch wenn das nicht immer die richtige Entscheidung f√ºr eine echte Analyse ist). Das geht mit drop_na():\n\nsurvey |&gt;\n  select(u013pzahl_1weihen) |&gt;\n  drop_na()\n\n# A tibble: 231 √ó 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              1.49\n 2            150   \n 3              1.19\n 4              3   \n 5              2   \n 6              1.6 \n 7              1.09\n 8              3   \n 9              1.8 \n10              2.2 \n# ‚Ñπ 221 more rows\n\n\nJetzt sehen wir mehr ‚Äûechte‚Äú Preise. F√ºr kontinuierliche Variablen ist typisch: Es gibt keine feste Liste an Auspr√§gungen, sondern (theoretisch) unendlich viele Werte auf einem Kontinuum. Das merkt ihr auch daran, dass distinct() bei solchen Variablen schnell sehr viele unterschiedliche Werte liefern kann:\n\nsurvey |&gt;\n  select(u013pzahl_1weihen) |&gt;\n  drop_na() |&gt;\n  distinct()\n\n# A tibble: 48 √ó 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              1.49\n 2            150   \n 3              1.19\n 4              3   \n 5              2   \n 6              1.6 \n 7              1.09\n 8              1.8 \n 9              2.2 \n10            120   \n# ‚Ñπ 38 more rows\n\n\nZwar sieht es hier so aus, als w√§ren die eindeutigen Werte mit 48 gar nicht so zahlreich. Trotzdem ist klar: theoretisch k√∂nnten viel mehr unterschiedliche Preise eingegeben werden ‚Äì und ‚ÄûPreis‚Äú ist von Natur aus eine numerische Gr√∂√üe.\n\n\nAusrei√üer, Mittelwert und Median\nBei kontinuierlichen Variablen spielt h√§ufig das Problem der Ausrei√üer eine Rolle. Gerade in Umfragen ist ein Tippfehler eine naheliegende Ursache. Je nach Ursprung sind unterschiedliche Ma√ünahmen m√∂glich: Tippfehler sollten wir korrigieren ‚Äì oder (wenn wir nicht sicher korrigieren k√∂nnen) pragmatisch filtern.\nStarten wir mit dem Durchschnittspreis als arithmetischem Mittel:\n\nsurvey |&gt;\n  summarize(avg_price = mean(u013pzahl_1weihen))\n\n# A tibble: 1 √ó 1\n  avg_price\n      &lt;dbl&gt;\n1        NA\n\n\nWarum steht dort NA? Weil R nicht ‚Äûraten‚Äú will, wie NA in Berechnungen behandelt werden soll. Sobald ein NA in die Rechnung eingeht, wird das Ergebnis NA. F√ºr einen ersten Blick entfernen wir also die fehlenden Werte:\n\nsurvey |&gt;\n1  drop_na(u013pzahl_1weihen) |&gt;\n  summarize(avg_price = mean(u013pzahl_1weihen))\n\n\n1\n\ndrop_na() entfernt alle Zeilen mit fehlenden Werten. Wenn ihr Spalten angebt, bezieht sich das Entfernen nur auf diese Spalten.\n\n\n\n\n# A tibble: 1 √ó 1\n  avg_price\n      &lt;dbl&gt;\n1      4.58\n\n\nIm Durchschnitt halten die Probanden also einen Preis von 4,58 ‚Ç¨ f√ºr einen Liter Milch f√ºr gerechtfertigt. Klingt das plausibel? Pr√ºfen wir das mit einer robusteren Kenngr√∂√üe: dem Median.\n\nsurvey |&gt;\n  drop_na(u013pzahl_1weihen) |&gt;\n  summarize(avg_price = median(u013pzahl_1weihen))\n\n# A tibble: 1 √ó 1\n  avg_price\n      &lt;dbl&gt;\n1      1.49\n\n\nDer Median ist mit 1,49 ‚Ç¨ deutlich kleiner. Woran liegt das? Der Median ist robust gegen√ºber Ausrei√üern, das arithmetische Mittel dagegen nicht.\nDas arithmetische Mittel ist:\n\\[\n\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i\n\\]\nDer Median ist der mittlere Wert der sortierten Daten; bei geradem \\(n\\) ist er der Mittelwert der beiden mittleren Werte:\n\\[\n\\tilde{x} =\n\\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, & \\text{falls } n \\text{ ungerade ist},\\\\[6pt]\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & \\text{falls } n \\text{ gerade ist}.\n\\end{cases}\n\\]\nWas also tun? Da wir nicht sicher wissen, welche Eingabe ‚Äûeigentlich gemeint‚Äú war, entscheiden wir uns hier pragmatisch f√ºr ein Filtern unplausibler Werte. Schauen wir zuerst, welche extrem hohen Werte vorkommen:\n\nsurvey |&gt;\n  select(u013pzahl_1weihen) |&gt;\n  arrange(desc(u013pzahl_1weihen))\n\n# A tibble: 2,811 √ó 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1               150\n 2               150\n 3               129\n 4               120\n 5               109\n 6                50\n 7                 7\n 8                 4\n 9                 4\n10                 3\n# ‚Ñπ 2,801 more rows\n\n\nGar nicht so einfach, eine Grenze festzulegen. F√ºr dieses Beispiel w√§hlen wir 10 ‚Ç¨ als Obergrenze:\n\nsurvey |&gt;\n  filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n  summarize(avg_price = mean(u013pzahl_1weihen))\n\n# A tibble: 1 √ó 1\n  avg_price\n      &lt;dbl&gt;\n1      1.56\n\n\nGibt es auch Ausrei√üer nach unten?\n\nsurvey |&gt;\n  select(u013pzahl_1weihen) |&gt;\n  arrange(u013pzahl_1weihen)\n\n# A tibble: 2,811 √ó 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              0   \n 2              0   \n 3              0   \n 4              0.09\n 5              0.89\n 6              0.95\n 7              0.99\n 8              0.99\n 9              0.99\n10              0.99\n# ‚Ñπ 2,801 more rows\n\n\nAuch hier sehen wir unplausible Werte (z. B. 0 ‚Ç¨). Filtern wir beide Seiten:\n\nsurvey |&gt;\n  filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n  filter(u013pzahl_1weihen &gt; 0.1) |&gt;\n  summarize(avg_price = mean(u013pzahl_1weihen))\n\n# A tibble: 1 √ó 1\n  avg_price\n      &lt;dbl&gt;\n1      1.59\n\n\nDurch die Pipeline werden die Filter nacheinander angewendet: zuerst ‚Äûzu gro√ü‚Äú, danach ‚Äûzu klein‚Äú. Danach berechnen wir erneut den Mittelwert.\n\n\n\n\n\n\nHinweisFiltern von Daten\n\n\n\nDie Funktion filter() ist zentral f√ºr die Auswahl der richtigen Beobachtungen. Eine Einf√ºhrung, wie man mit R und dem dplyr‚ÄëPaket Daten filtert, findet ihr in Kapitel 13.\n\n\n\n\nAusrei√üer sehen: Boxplot und Histogramm\nVisualisierungen helfen, Ausrei√üer schnell zu erkennen. Ein Boxplot stellt Ausrei√üer als Punkte au√üerhalb der Box dar:\n\nsurvey |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nMan erkennt hier sehr sch√∂n die Handvoll Ausrei√üer. Die Box selbst ist dadurch kaum sichtbar. Was tun? Bei einem Boxplot solltet ihr nicht einfach filtern, ‚Äûnur damit es sch√∂ner aussieht‚Äú, weil der Boxplot Kennzahlen wie den Median und Quartile aus den gefilterten Daten berechnen w√ºrde ‚Äì und ihr damit den Plot inhaltlich ver√§ndert.\nDie L√∂sung: Reinzoomen statt filtern. Wir begrenzen nur die Achsenansicht:\n\nsurvey |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_boxplot() +\n  coord_cartesian(xlim = c(0, 10))\n\n\n\n\n\n\n\n\nSchon besser. Die ‚ÄûWhisker‚Äú des Boxplots reichen typischerweise bis zum 1,5‚Äëfachen Interquartilsabstand (IQR) √ºber/unter die Quartile:\n\\[\n\\left[\\, Q_1 - 1.5\\cdot\\mathrm{IQR},\\; Q_3 + 1.5\\cdot\\mathrm{IQR} \\,\\right]\n\\]\nwobei gilt:\n\\[\n\\mathrm{IQR} = Q_3 - Q_1\n\\]\nZoomen wir noch ein St√ºck weiter hinein:\n\nsurvey |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_boxplot() +\n  coord_cartesian(xlim = c(0, 5))\n\n\n\n\n\n\n\n\nEine Alternative ist ein Histogramm:\n\nsurvey |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_histogram()\n\n\n\n\n\n\n\n\nAuch hier ‚Äûziehen‚Äú Ausrei√üer die Skala auseinander. Beim Histogramm d√ºrft ihr f√ºr die Darstellung pragmatisch filtern, weil es nur H√§ufigkeiten pro Klasse z√§hlt:\n\nsurvey |&gt;\n  filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_histogram()\n\n\n\n\n\n\n\n\nWenn ihr keine Klassenbreite angebt, w√§hlt ggplot2 etwas Passendes. Ihr k√∂nnt das aber steuern, z. B. mit 50‚ÄëCent‚ÄëKlassen:\n\nsurvey |&gt;\n  filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_histogram(binwidth = 0.5)\n\n\n\n\n\n\n\n\nF√ºr jetzt merken wir uns: Kontinuierliche Variablen sind oft &lt;dbl&gt;, k√∂nnen viele Auspr√§gungen haben und sind empfindlich gegen√ºber Ausrei√üern. Boxplot/Histogramm geben euch schnell ein Gef√ºhl f√ºr die Verteilung.\n\n\n\nZ√§hlvariablen\n\nCount variables are those that, well, count something. Perhaps how many times something happened or how many of something there are. (Huntington-Klein 2026)\n\nDer Unterschied zur kontinuierlichen Variable ist (ganz pragmatisch): Z√§hlvariablen haben keine Nachkommastellen. Typische Beispiele:\n\nAlter (in Jahren)\nAnzahl K√§ufe pro Monat\nAnzahl verkaufter Produkte\n\nZ√§hlvariablen k√∂nnen sehr viele Auspr√§gungen haben und werden dann in der explorativen Analyse oft √§hnlich behandelt wie kontinuierliche Variablen. Trotzdem ist das Messniveau ein anderes: Es sind diskrete, abz√§hlbare Werte.\n\nBeispiel: Alter aus dem Geburtsjahr ableiten\nDas Alter wurde nicht direkt gefragt, steckt aber indirekt in der Frage: ‚ÄûIn welchem Jahr sind Sie geboren?‚Äú.\n\nsurvey |&gt; \n  select(q002geburt)\n\n# A tibble: 2,811 √ó 1\n   q002geburt\n        &lt;dbl&gt;\n 1       1970\n 2       1990\n 3       1963\n 4       1989\n 5       1965\n 6       1957\n 7       1960\n 8       1984\n 9       1974\n10       1954\n# ‚Ñπ 2,801 more rows\n\n\nWenn wir das Geburtsjahr kennen, k√∂nnen wir das Alter (mit kleiner Restunsicherheit) sch√§tzen:\n\nsurvey |&gt;\n  transmute(age = 2025 - q002geburt)\n\n# A tibble: 2,811 √ó 1\n     age\n   &lt;dbl&gt;\n 1    55\n 2    35\n 3    62\n 4    36\n 5    60\n 6    68\n 7    65\n 8    41\n 9    51\n10    71\n# ‚Ñπ 2,801 more rows\n\n\nWie viele unterschiedliche Alterswerte gibt es?\n\nsurvey |&gt;\n  transmute(age = 2025 - q002geburt) |&gt;\n  distinct()\n\n# A tibble: 61 √ó 1\n     age\n   &lt;dbl&gt;\n 1    55\n 2    35\n 3    62\n 4    36\n 5    60\n 6    68\n 7    65\n 8    41\n 9    51\n10    71\n# ‚Ñπ 51 more rows\n\n\nEs sind mit 61 sogar noch mehr Auspr√§gungen als beim Preis. Ein Histogramm mit 5‚ÄëJahres‚ÄëKlassen gibt schnell einen √úberblick:\n\nsurvey |&gt;\n  transmute(age = 2025 - q002geburt) |&gt;\n  ggplot() +\n  aes(x = age) +\n  geom_histogram(binwidth = 5, fill = \"lightblue\", alpha = 0.8) +\n  labs(y = \"H√§ufigkeit\", x = \"Alter\", title = \"Altersverteilung der Probanden\") +\n  theme_bw()\n\n\n\n\n\n\n\n\nHier steckt nebenbei ein wichtiger Punkt: Auch in der explorativen Analyse lohnt es sich manchmal, Visualisierungen kurz lesbarer zu machen (Beschriftungen, Theme, Farben).\n\n\n\n\n\n\nHinweisVisualisierungen polieren\n\n\n\nW√§hrend wir in der explorativen Datenanalyse Wert auf schnelle Ergebnisse legen, wollen wir f√ºr Publikationen ansprechende Visualisierungen im Hochglanzformat erstellen. In Kapitel 15 schauen wir explizit auf die M√∂glichkeiten, Visualisierungen aufzupolieren.\n\n\n\n\nGanze Zahlen (int)\nZ√§hlvariablen bestehen aus ganzen Zahlen (mathematisch: nat√ºrlichen Zahlen). In R gibt es daf√ºr den Datentyp int, der in Abbildung¬†2.1 auch f√ºr Z√§hlvariablen angegeben ist.\nIn der Praxis macht es oft keinen gro√üen Unterschied, ob ihr eine Z√§hlvariable als double oder int speichert. Zwei Vorteile von int sind:\n\nint ben√∂tigt weniger Speicher (bei sehr gro√üen Daten relevant).\nEs signalisiert klar: ‚ÄûHier sind nur ganze Zahlen sinnvoll‚Äú ‚Äì das hilft auch anderen, die den Datensatz sp√§ter nutzen.\n\nWandeln wir das Alter in int um und speichern es als neue Variable im Tibble:\n\nsurvey &lt;- \n  survey |&gt;\n  mutate(Q002age = as.integer(2025 - q002geburt), .after = \"q002geburt\")\n\nMit mutate() erzeugen wir eine neue Spalte. as.integer() klappt nur, wenn der Wert als ganze Zahl darstellbar ist; sonst gibt es einen Fehler. Mit .after steuern wir die Position der neuen Variable.\n\nsurvey |&gt;\n  select(q002geburt, Q002age)\n\n# A tibble: 2,811 √ó 2\n   q002geburt Q002age\n        &lt;dbl&gt;   &lt;int&gt;\n 1       1970      55\n 2       1990      35\n 3       1963      62\n 4       1989      36\n 5       1965      60\n 6       1957      68\n 7       1960      65\n 8       1984      41\n 9       1974      51\n10       1954      71\n# ‚Ñπ 2,801 more rows\n\n\nWie alt ist der √§lteste Teilnehmende?\n\nsurvey |&gt;\n  select(Q002age) |&gt;\n  arrange(desc(Q002age)) |&gt;\n  head(1)\n\n# A tibble: 1 √ó 1\n  Q002age\n    &lt;int&gt;\n1      80\n\n\nUnd der j√ºngste?\n\nsurvey |&gt;\n  select(Q002age) |&gt;\n  arrange(Q002age) |&gt;\n  head(1)\n\n# A tibble: 1 √ó 1\n  Q002age\n    &lt;int&gt;\n1      18\n\n\n\n\nSchneller √úberblick √ºber eine Spalte mit skim()\nEs gibt ein n√ºtzliches Paket namens skimr, das unter anderem die Funktion skim() bereitstellt. Sie gibt euch einen schnellen √úberblick √ºber einzelne Variablen oder sogar den gesamten Datensatz.\n\nlibrary(skimr)\nsurvey |&gt; \n  select(Q002age) |&gt; \n  skim() |&gt;\n  as_tibble()\n\n# A tibble: 1 √ó 12\n  skim_type skim_variable n_missing complete_rate numeric.mean numeric.sd\n  &lt;chr&gt;     &lt;chr&gt;             &lt;int&gt;         &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;\n1 numeric   Q002age               0             1         48.4       14.7\n# ‚Ñπ 6 more variables: numeric.p0 &lt;dbl&gt;, numeric.p25 &lt;dbl&gt;, numeric.p50 &lt;dbl&gt;,\n#   numeric.p75 &lt;dbl&gt;, numeric.p100 &lt;dbl&gt;, numeric.hist &lt;chr&gt;\n\n\nDen letzten Schritt as_tibble() ben√∂tigt ihr nicht ‚Äì er ist nur notwendig, damit in diesem Buch eine Konsolenausgabe entsteht. In RStudio wird die Ausgabe automatisch passend dargestellt.\nskim() erzeugt einen Tibble mit Kennzahlen zur Variable Q002age, z. B.:\n\nDatentyp (skim_type)\nAnzahl fehlender Werte (n_missing) und F√ºllgrad (complete_rate)\nMittelwert, Standardabweichung, Quartile, Minimum/Maximum\nein kleines ASCII‚ÄëHistogramm (numeric.hist)\n\nUnd weil es ein Tibble ist, k√∂nnt ihr damit wie mit jedem anderen Datensatz weiterarbeiten ‚Äì zum Beispiel nur Mittelwert und Median ausw√§hlen:\n\nsurvey |&gt; \n  select(Q002age) |&gt; \n  skim() |&gt;\n  yank(\"numeric\") |&gt;\n  select(mean_age = mean, median_age = p50) \n\nVariable type: numeric\n\n\n\nmean_age\nmedian_age\n\n\n\n\n48.39\n50",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#kategoriale-variablen",
    "href": "project-1-survey/types-of-variables.html#kategoriale-variablen",
    "title": "2¬† Arten von Variablen",
    "section": "2.3 Kategoriale Variablen",
    "text": "2.3 Kategoriale Variablen\nKategoriale Variablen ordnen Beobachtungen in Kategorien ein. Oft sind sie in Umfragen sogar der h√§ufigste Typ.\n\nNominale Variablen\n\nCategorical variables are variables recording which category an observation is in - simple enough! The color of a flower is an example of a categorical variable. Is the flower white, orange, or red? None of those options is ‚Äúmore‚Äù than the others; they‚Äôre just different. (Huntington-Klein 2026)\n\nNominale Variablen haben Kategorien ohne nat√ºrliche Reihenfolge. Typische Beispiele in Umfragen sind Geschlecht, Bundesland oder ‚ÄûHauptverantwortlich f√ºr den Einkauf: ja/nein‚Äú.\nIn R wollt ihr bei nominalen Variablen meist wissen:\n\nWelche Kategorien kommen vor?\nWie h√§ufig sind sie?\n\nDas geht schnell mit distinct() oder (noch praktischer) count():\n\nsurvey |&gt;\n  count(q004geschlecht)\n\n# A tibble: 3 √ó 2\n  q004geschlecht     n\n           &lt;dbl&gt; &lt;int&gt;\n1              1  1328\n2              2  1481\n3              3     2\n\n\nViele nominale Variablen sind als Zahlen kodiert (z. B. 1/2/3). Ohne Codebuch wisst ihr dann noch nicht, welche Zahl f√ºr welche Kategorie steht ‚Äì ihr k√∂nnt aber trotzdem schon pr√ºfen, ob es ‚Äûunerwartete‚Äú Codes gibt.\n\n\nOrdinale Variablen\n\nOrdinal variables are variables where some values are ‚Äúmore‚Äù and others are ‚Äúless,‚Äù but there‚Äôs not necessarily a rule as to how much more ‚Äúmore‚Äù is. (Huntington-Klein 2026)\n\nOrdinale Variablen haben eine Reihenfolge (z. B. Zustimmung von 1 bis 7), aber die Abst√§nde zwischen den Stufen sind nicht zwingend gleich gro√ü. Das ist wichtig f√ºr die Auswertung: H√§ufig sind Median und H√§ufigkeiten sinnvoller als ein Mittelwert, und Visualisierungen sind oft Balkendiagramme.\nIn unserem Datensatz tauchen solche Skalenfragen z. B. in Variablen mit ‚Äû‚Ä¶diff7‚Ä¶‚Äú im Namen auf. Ein schneller Check:\n\nsurvey |&gt;\n  count(ax010midiff7, sort = TRUE)\n\n# A tibble: 8 √ó 2\n  ax010midiff7     n\n         &lt;dbl&gt; &lt;int&gt;\n1           NA   478\n2            5   345\n3            6   341\n4            7   340\n5            1   339\n6            4   329\n7            3   323\n8            2   316\n\n\nWenn ihr ordinale Variablen sp√§ter modellieren oder sauber visualisieren wollt, ist es oft sinnvoll, sie als ordered factor zu behandeln (statt als ‚Äûnormale‚Äú Zahl). Das machen wir an anderer Stelle im Buch noch ausf√ºhrlicher.\n\nSonderfall: Mehrfachauswahl als viele 0/1‚ÄëSpalten\nIn Umfragen werden Mehrfachauswahl‚ÄëFragen h√§ufig als mehrere Dummy‚ÄëSpalten gespeichert (0/1). Inhaltlich sind das kategoriale Informationen ‚Äì gespeichert als Zahlen.\nZum Beispiel gibt es im Datensatz mehrere Spalten, die mit v008ort_ beginnen (Einkaufsorte). Ein erster Blick auf ein paar davon:\n\nsurvey |&gt;\n  select(v008ort_1discount, v008ort_2super, v008ort_9online, v008ort_other) |&gt;\n  glimpse()\n\nRows: 2,811\nColumns: 4\n$ v008ort_1discount &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0‚Ä¶\n$ v008ort_2super    &lt;dbl&gt; 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0‚Ä¶\n$ v008ort_9online   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0‚Ä¶\n$ v008ort_other     &lt;chr&gt; \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0‚Ä¶\n\n\nDie Interpretation ist hier: ‚ÄûHat Person X diese Option gew√§hlt ‚Äì ja/nein?‚Äú.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#qualitative-variablen",
    "href": "project-1-survey/types-of-variables.html#qualitative-variablen",
    "title": "2¬† Arten von Variablen",
    "section": "2.4 Qualitative Variablen",
    "text": "2.4 Qualitative Variablen\n\nQualitative variables are a sort of catch-all category for everything else. They aren‚Äôt numeric in nature, but also they‚Äôre not categorical. The text of a Washington Post headline is an example of a qualitative variable. (Huntington-Klein 2026)\n\nQualitative Variablen sind h√§ufig Freitext: Antworten, die nicht in eine feste Kategorienliste passen. In Umfragen sind das oft ‚ÄûOther‚Äú-Felder. In unserem Datensatz findet ihr solche Spalten z. B. an Namen wie ‚Ä¶_other:\n\nsurvey |&gt;\n  select(v041nofleisch_other)\n\n# A tibble: 2,811 √ó 1\n   v041nofleisch_other\n   &lt;chr&gt;              \n 1 &lt;NA&gt;               \n 2 &lt;NA&gt;               \n 3 &lt;NA&gt;               \n 4 &lt;NA&gt;               \n 5 &lt;NA&gt;               \n 6 &lt;NA&gt;               \n 7 &lt;NA&gt;               \n 8 &lt;NA&gt;               \n 9 &lt;NA&gt;               \n10 &lt;NA&gt;               \n# ‚Ñπ 2,801 more rows\n\n\nF√ºr qualitative Variablen ist in der explorativen Analyse oft ein sinnvoller Start:\n\nzuerst die h√§ufigsten Texte anschauen,\nTippfehler/Varianten vereinheitlichen,\nund dann entscheiden, ob man Kategorien daraus macht oder Textanalyse einsetzt.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#zusammenfassung-welcher-typ-welche-werkzeuge",
    "href": "project-1-survey/types-of-variables.html#zusammenfassung-welcher-typ-welche-werkzeuge",
    "title": "2¬† Arten von Variablen",
    "section": "2.5 Zusammenfassung: Welcher Typ ‚Üí welche Werkzeuge?",
    "text": "2.5 Zusammenfassung: Welcher Typ ‚Üí welche Werkzeuge?\n\nKontinuierlich (dbl): NA/Ausrei√üer pr√ºfen, Histogramm/Boxplot, Median als robuste Erg√§nzung.\nZ√§hlvariable (diskret, oft int): H√§ufig wie kontinuierlich auswerten, aber ‚Äûganzzahlig‚Äú im Kopf behalten.\nNominal (Kategorien): count()/Balkenplot, Kodierungen √ºber Codebuch pr√ºfen.\nOrdinal (geordnete Kategorien): H√§ufigkeiten + Median; vorsichtig mit Mittelwert/Standardabweichung.\nQualitativ (Text): erst sichten/aufr√§umen, dann strukturieren.\n\n\n\n\n\nHuntington-Klein, Nick. 2026. The effect: an introduction to research design and causality. Second edition. A Chapman & Hall Book. CRC Press.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/load.html",
    "href": "project-2-news/load.html",
    "title": "3¬† Laden der Daten",
    "section": "",
    "text": "3.1 Tagesschau-Beitr√§ge\nIn diesem ersten Kapitel des Projekts erkunden wir wie immer den neuen Datensatz. Dazu laden wir ihn mit R, und zwar als Tibble, damit wir auf alle Funktionen des Tidyverse zur√ºkgreifen k√∂nnen. Anschlie√üend lernen wir etwas √ºber die enthaltenen Informationen.\nDie Daten stammen von der Webseite Tagesschau.de, die t√§glich aktuelle Nachrichten ver√∂ffentlicht. F√ºr dieses Projekt wurden f√ºr den Zeitraum 05.01.2006 bis 31.12.2025 insgesamt 59.500 Nachrichtenartikel gesammelt. Wer gerne mehr √ºber den Prozess der Datensammlung erfahren m√∂chte findet im Anhang eine detaillierte Beschreibung der Python-Skripte, die f√ºr die Erstellung dieses Datensatzes verwendet wurden.\nF√ºr unsere Analysen gehen wir wie immer davon aus, dass die Daten bereits vorliegen. In diesem Fall als CSV-Datei, die wir sofort als Tibble in R laden k√∂nnen.\nlibrary(tidyverse)\nts &lt;- read_csv(\"data/tagesschau.csv\")\nMit der Funktion glimpse() bekommen wir einen schnellen √úberblick √ºber die Struktur des Datensatzes.\nts |&gt;\n  glimpse()    \n\nRows: 59,500\nColumns: 21\n$ supertitle     &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Treffen der EU-Inn‚Ä¶\n$ title          &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Grundz√ºge f√ºr geme‚Ä¶\n$ date_time      &lt;dttm&gt; 2006-01-05 10:50:33, 2006-01-13 13:47:00, 2006-01-13 1‚Ä¶\n$ author         &lt;chr&gt; \"J√∂rg Sch√∂nenborn\", \"tagesschau.de\", \"tagesschau.de\", \"‚Ä¶\n$ ressort        &lt;chr&gt; \"inland\", \"ausland\", \"inland\", \"ausland\", \"wirtschaft\",‚Ä¶\n$ url            &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meld‚Ä¶\n$ thumbnail      &lt;chr&gt; \"\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e8‚Ä¶\n$ tag            &lt;chr&gt; NA, NA, \"INTERVIEW\", NA, \"HINTERGRUND\", NA, NA, NA, \"IN‚Ä¶\n$ shorttext      &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amt‚Ä¶\n$ description    &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amt‚Ä¶\n$ keywords       &lt;chr&gt; \"[\\\"DeutschlandTrend\\\"]\", \"[\\\"Meldung\\\"]\", \"[\\\"Intervie‚Ä¶\n$ date_modified  &lt;dttm&gt; 2021-01-28 10:32:31, 2023-03-01 23:51:29, 2023-03-01 1‚Ä¶\n$ canonical_url  &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meld‚Ä¶\n$ language       &lt;chr&gt; \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"‚Ä¶\n$ paragraphs     &lt;chr&gt; \"[\\\"Bundeskanzlerin Angela Merkel hat in den ersten sec‚Ä¶\n$ text           &lt;chr&gt; \"Bundeskanzlerin Angela Merkel hat in den ersten sechs ‚Ä¶\n$ word_count     &lt;dbl&gt; 569, 406, 658, 264, 601, 399, 262, 516, 801, 433, 567, ‚Ä¶\n$ image_urls     &lt;chr&gt; \"[\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e‚Ä¶\n$ image_captions &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,‚Ä¶\n$ related_links  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,‚Ä¶\n$ source_file    &lt;chr&gt; \"2006-01-05-articles.jsonl\", \"2006-01-13-articles.jsonl‚Ä¶\nWir sehen, dass der Datensatz 59.500 Zeilen und 21 Spalten enth√§lt. Jede Zeile entspricht einem Nachrichtenbeitrag, und jede Spalte enth√§lt Informationen √ºber diesen Beitrag, wie zum Beispiel den Titel, den Text, das Ver√∂ffentlichungsdatum und einige interessante Informationen mehr. Lasst uns einen Blick auf ein paar ausgew√§hlte Spalten werfen.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Laden der Daten</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html",
    "href": "project-2-news/factors.html",
    "title": "\n4¬† Faktoren\n",
    "section": "",
    "text": "4.1 √úberblick: Welche Variablen sind gute Faktoren?\nViele Variablen im Tagesschau-Datensatz sind kategorial: ressort, language, author, manchmal auch tag oder supertitle. In R werden solche Kategorien h√§ufig als Faktoren (factors) dargestellt. Ein Faktor ist im Kern ein Vektor mit festen Auspr√§gungen (levels). Das ist in der Datenanalyse n√ºtzlich, weil\nIm Tidyverse ist forcats (Teil von tidyverse) das Werkzeug f√ºr Faktor-Operationen.\nEin schneller Check ist: Welche Spalten sind Text (&lt;chr&gt;) und haben eher wenige unterschiedliche Werte?\n# Anzahl unterschiedlicher Werte je Zeichen-Spalte\nchar_uniques &lt;- ts |&gt;\n  summarise(\n    across(where(is.character), ~ n_distinct(.x, na.rm = TRUE))\n  ) |&gt;\n  pivot_longer(everything(), names_to = \"variable\", values_to = \"n_distinct\") |&gt;\n  arrange(n_distinct)\n\nchar_uniques\n\n# A tibble: 18 √ó 2\n   variable       n_distinct\n   &lt;chr&gt;               &lt;int&gt;\n 1 language                4\n 2 ressort                38\n 3 tag                   375\n 4 author               5216\n 5 source_file          6351\n 6 image_captions       9434\n 7 related_links       17122\n 8 thumbnail           41449\n 9 keywords            41962\n10 supertitle          46474\n11 image_urls          48806\n12 title               58902\n13 paragraphs          58986\n14 text                58986\n15 shorttext           59056\n16 description         59059\n17 canonical_url       59231\n18 url                 59433\nInterpretation:",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#√ºberblick-welche-variablen-sind-gute-faktoren",
    "href": "project-2-news/factors.html#√ºberblick-welche-variablen-sind-gute-faktoren",
    "title": "\n4¬† Faktoren\n",
    "section": "",
    "text": "Kleine n_distinct (z.B. language) ‚Üí sehr gute Kandidaten f√ºr Faktoren.\nGro√üe n_distinct (z.B. title, url) ‚Üí eher Identifikatoren/Free-Text, meistens kein Faktor.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#h√§ufigkeiten-ressorts-z√§hlen-und-visualisieren",
    "href": "project-2-news/factors.html#h√§ufigkeiten-ressorts-z√§hlen-und-visualisieren",
    "title": "\n4¬† Faktoren\n",
    "section": "\n4.2 H√§ufigkeiten: Ressorts z√§hlen und visualisieren",
    "text": "4.2 H√§ufigkeiten: Ressorts z√§hlen und visualisieren\nBei News-Daten ist ressort meist eine der wichtigsten Kategorien.\n\n# H√§ufigkeitstabelle\nressort_counts &lt;- ts |&gt;\n  count(ressort, sort = TRUE)\n\nressort_counts\n\n# A tibble: 39 √ó 2\n   ressort          n\n   &lt;chr&gt;        &lt;int&gt;\n 1 ausland      22675\n 2 wirtschaft   15935\n 3 inland       13463\n 4 wissen        2045\n 5 faktenfinder  1059\n 6 investigativ  1042\n 7 newsticker    1021\n 8 multimedia     650\n 9 kommentar      468\n10 kultur         340\n# ‚Ñπ 29 more rows\n\n\nF√ºr eine Visualisierung ist es hilfreich, ressort als Faktor zu nutzen und nach H√§ufigkeit zu ordnen.\n\nressort_counts |&gt;\n  filter(!is.na(ressort)) |&gt;\n  mutate(ressort = fct_reorder(ressort, n)) |&gt;\n  ggplot(aes(x = ressort, y = n)) +\n  geom_col() +\n  coord_flip() +\n  theme_bw() +\n  labs(x = \"Ressort\", y = \"Anzahl der Beitr√§ge\")\n\n\n\n\n\n\n\nWarum ist das n√ºtzlich?\n\nDu erkennst sofort, welche Ressorts dominieren (wichtig f√ºr Stichproben, Bias, Gewichtung).\nViele weitere Analysen (Zeitreihen, Textfeatures) lassen sich sinnvoll nach Ressort splitten.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#zu-viele-kategorien-lumpen-seltene-werte-zusammenfassen",
    "href": "project-2-news/factors.html#zu-viele-kategorien-lumpen-seltene-werte-zusammenfassen",
    "title": "\n4¬† Faktoren\n",
    "section": "\n4.3 Zu viele Kategorien: Lumpen (seltene Werte zusammenfassen)",
    "text": "4.3 Zu viele Kategorien: Lumpen (seltene Werte zusammenfassen)\nBei Kategorien wie author gibt es oft sehr viele Auspr√§gungen. F√ºr Auswertungen und Plots ist es dann sinnvoll, seltene Werte in Other zusammenzufassen.\n\n# Top-Autor:innen + Other\n# (Falls author sehr oft NA ist: NAs explizit als Kategorie behandeln)\n\nts |&gt;\n  mutate(\n    author = fct_explicit_na(author, na_level = \"(fehlend)\"),\n    author = fct_lump_n(author, n = 15)\n  ) |&gt;\n  count(author, sort = TRUE)\n\n# A tibble: 16 √ó 2\n   author                    n\n   &lt;fct&gt;                 &lt;int&gt;\n 1 Other                 20487\n 2 tagesschau.de         19926\n 3 (fehlend)             16625\n 4 Kai K√ºstner             387\n 5 Martin Bohne            207\n 6 Silvia St√∂ber           201\n 7 Stephan Ueberbach       185\n 8 Helga Schmidt           184\n 9 Ralph Sina              182\n10 Jakob Mayr              177\n11 Karin Bensch            177\n12 Patrick Gensing         176\n13 Frank Br√§utigam         157\n14 Angela G√∂pfert          149\n15 Christoph Pr√∂ssl        148\n16 Jan-Christoph Kitzler   132\n\n\nDas ist ein typischer Schritt in der Datenanalyse:\n\nreduziert visuelle Unordnung,\nverhindert, dass ‚ÄûEinzelf√§lle‚Äú die Story dominieren,\nstabilisiert Modelle (zu viele Kategorien f√ºhren sonst schnell zu Overfitting).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#sinnvolle-reihenfolgen-faktoren-nach-kennzahlen-ordnen",
    "href": "project-2-news/factors.html#sinnvolle-reihenfolgen-faktoren-nach-kennzahlen-ordnen",
    "title": "\n4¬† Faktoren\n",
    "section": "\n4.4 Sinnvolle Reihenfolgen: Faktoren nach Kennzahlen ordnen",
    "text": "4.4 Sinnvolle Reihenfolgen: Faktoren nach Kennzahlen ordnen\nEin Faktor muss nicht alphabetisch sortiert sein. H√§ufig willst du Kategorien nach einer analytischen Kennzahl ordnen.\nBeispiel: Welche Ressorts haben im Median die l√§ngsten Texte (√ºber word_count)?\n\nressort_wordcount &lt;- ts |&gt;\n  filter(!is.na(ressort), !is.na(word_count)) |&gt;\n  group_by(ressort) |&gt;\n  summarise(\n    n = n(),\n    median_word_count = median(word_count),\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(desc(median_word_count))\n\nressort_wordcount\n\n# A tibble: 32 √ó 3\n   ressort                                   n median_word_count\n   &lt;chr&gt;                                 &lt;int&gt;             &lt;dbl&gt;\n 1 incels                                    1             2589 \n 2 newsticker                             1021             1987 \n 3 geschichte                                1             1451 \n 4 ueber-uns                                 2             1010.\n 5 fussball                                  4              864.\n 6 ratgeber                                  2              820.\n 7 investigativ                           1042              804.\n 8 faktenfinder                           1059              754 \n 9 news                                      8              678.\n10 Einstellungen einblenden Pfeil rechts   210              657 \n# ‚Ñπ 22 more rows\n\n\nUnd als Plot, nach Median-Wortanzahl geordnet:\n\nressort_wordcount |&gt;\n  mutate(ressort = fct_reorder(ressort, median_word_count)) |&gt;\n  ggplot(aes(x = ressort, y = median_word_count)) +\n  geom_col() +\n  coord_flip() +\n  theme_bw() +\n  labs(x = \"Ressort\", y = \"Median Wortanzahl\")\n\n\n\n\n\n\n\nSo ein Plot ist ein guter Einstieg, um Hypothesen zu formulieren (z.B. ‚ÄûPolitikartikel sind l√§nger als Sportmeldungen‚Äú).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#kategorien-bereinigen-recoding-und-missingness-sichtbar-machen",
    "href": "project-2-news/factors.html#kategorien-bereinigen-recoding-und-missingness-sichtbar-machen",
    "title": "\n4¬† Faktoren\n",
    "section": "\n4.5 Kategorien bereinigen: Recoding und Missingness sichtbar machen",
    "text": "4.5 Kategorien bereinigen: Recoding und Missingness sichtbar machen\nOft sind Kategorien ‚Äûnicht sauber‚Äú: unterschiedliche Schreibweisen, leere Strings, oder NAs. F√ºr Analytics ist es wichtig, diese F√§lle bewusst zu behandeln.\nBeispiel: language sollte im Datensatz meistens de sein.\n\n# Sprache: NA explizit machen + H√§ufigkeiten\n\nts |&gt;\n  mutate(language = fct_explicit_na(language, na_level = \"(fehlend)\")) |&gt;\n  count(language, sort = TRUE)\n\n# A tibble: 5 √ó 2\n  language      n\n  &lt;fct&gt;     &lt;int&gt;\n1 de        59495\n2 en            2\n3 es            1\n4 it            1\n5 (fehlend)     1\n\n\nWenn du Kategorien zusammenf√ºhren m√∂chtest (z.B. Synonyme), hilft fct_recode():\n\n# Beispiel-Recode (nur als Muster; passe Mapping bei Bedarf an deine Daten an)\n\nts |&gt;\n  mutate(\n    ressort = fct_recode(\n      ressort,\n      inland = \"inland\",\n      ausland = \"ausland\"\n    )\n  ) |&gt;\n  count(ressort, sort = TRUE)\n\n# A tibble: 39 √ó 2\n   ressort          n\n   &lt;fct&gt;        &lt;int&gt;\n 1 ausland      22675\n 2 wirtschaft   15935\n 3 inland       13463\n 4 wissen        2045\n 5 faktenfinder  1059\n 6 investigativ  1042\n 7 newsticker    1021\n 8 multimedia     650\n 9 kommentar      468\n10 kultur         340\n# ‚Ñπ 29 more rows",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#abgeleitete-faktoren-wochentag-und-tageszeit",
    "href": "project-2-news/factors.html#abgeleitete-faktoren-wochentag-und-tageszeit",
    "title": "\n4¬† Faktoren\n",
    "section": "\n4.6 Abgeleitete Faktoren: Wochentag und Tageszeit",
    "text": "4.6 Abgeleitete Faktoren: Wochentag und Tageszeit\nFaktoren entstehen nicht nur aus Textspalten. Gerade Zeitstempel werden in Analytics oft in kategoriale Einheiten transformiert, um Muster sichtbar zu machen.\n\n# Wochentag (deutsche Labels) und Stunde\n# Hinweis: base::weekdays() h√§ngt von der Locale ab; daher nutzen wir lubridate::wday()\n\nts |&gt;\n  mutate(\n    weekday = wday(date_time, label = TRUE, abbr = FALSE, week_start = 1),\n    hour = hour(date_time)\n  ) |&gt;\n  count(weekday, sort = TRUE)\n\n# A tibble: 8 √ó 2\n  weekday        n\n  &lt;ord&gt;      &lt;int&gt;\n1 Donnerstag 10649\n2 Mittwoch   10503\n3 Dienstag   10158\n4 Freitag     9345\n5 Montag      8979\n6 Samstag     5107\n7 Sonntag     4730\n8 &lt;NA&gt;          29\n\n\nWochentage als Faktor sind besonders n√ºtzlich f√ºr:\n\nPublikationsmuster (z.B. weniger Beitr√§ge am Wochenende?),\nKontrollvariablen in Modellen,\nsegmentierte Reports (‚ÄúMo‚ÄìFr‚Äù vs.¬†Wochenende).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html",
    "href": "project-2-news/variables.html",
    "title": "\n5¬† Variablen\n",
    "section": "",
    "text": "5.1 √úbersicht der Variablen\nNachdem wir in Kapitel 3 die Tagesschau-Daten geladen und einen ersten √úberblick √ºber die enthaltenen Informationen gewonnen haben, wollen wir uns nun genauer mit den einzelnen Variablen besch√§ftigen.\nUm eine √úbersicht √ºber die in einem Datensatz enthaltenen Variablen zu bekommen, k√∂nnen wir die Funktion glimpse() verwenden. Sie gibt uns einen schnellen √úberblick √ºber die Struktur des Datensatzes, einschlie√ülich der Namen der Variablen, ihrer Datentypen und einiger Beispielwerte.\nts |&gt;\n  glimpse()\n\nRows: 59,500\nColumns: 21\n$ supertitle     &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Treffen der EU-Inn‚Ä¶\n$ title          &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Grundz√ºge f√ºr geme‚Ä¶\n$ date_time      &lt;dttm&gt; 2006-01-05 10:50:33, 2006-01-13 13:47:00, 2006-01-13 1‚Ä¶\n$ author         &lt;chr&gt; \"J√∂rg Sch√∂nenborn\", \"tagesschau.de\", \"tagesschau.de\", \"‚Ä¶\n$ ressort        &lt;chr&gt; \"inland\", \"ausland\", \"inland\", \"ausland\", \"wirtschaft\",‚Ä¶\n$ url            &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meld‚Ä¶\n$ thumbnail      &lt;chr&gt; \"\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e8‚Ä¶\n$ tag            &lt;chr&gt; NA, NA, \"INTERVIEW\", NA, \"HINTERGRUND\", NA, NA, NA, \"IN‚Ä¶\n$ shorttext      &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amt‚Ä¶\n$ description    &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amt‚Ä¶\n$ keywords       &lt;chr&gt; \"[\\\"DeutschlandTrend\\\"]\", \"[\\\"Meldung\\\"]\", \"[\\\"Intervie‚Ä¶\n$ date_modified  &lt;dttm&gt; 2021-01-28 10:32:31, 2023-03-01 23:51:29, 2023-03-01 1‚Ä¶\n$ canonical_url  &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meld‚Ä¶\n$ language       &lt;chr&gt; \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"‚Ä¶\n$ paragraphs     &lt;chr&gt; \"[\\\"Bundeskanzlerin Angela Merkel hat in den ersten sec‚Ä¶\n$ text           &lt;chr&gt; \"Bundeskanzlerin Angela Merkel hat in den ersten sechs ‚Ä¶\n$ word_count     &lt;dbl&gt; 569, 406, 658, 264, 601, 399, 262, 516, 801, 433, 567, ‚Ä¶\n$ image_urls     &lt;chr&gt; \"[\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e‚Ä¶\n$ image_captions &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,‚Ä¶\n$ related_links  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,‚Ä¶\n$ source_file    &lt;chr&gt; \"2006-01-05-articles.jsonl\", \"2006-01-13-articles.jsonl‚Ä¶",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>√úbersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html#fehlende-werte",
    "href": "project-2-news/variables.html#fehlende-werte",
    "title": "\n5¬† Variablen\n",
    "section": "\n5.2 Fehlende Werte",
    "text": "5.2 Fehlende Werte\nFehlende Werte (missing values) sind in realen Datens√§tzen v√∂llig normal: Manche Informationen sind f√ºr einen Beitrag nicht vorhanden (z.B. kein:e Autor:in), wurden beim Scraping nicht gefunden oder sind nur f√ºr bestimmte Ressorts sinnvoll.\nEin erster, sehr n√ºtzlicher Schritt ist ein ‚ÄûMissingness-Profil‚Äú: Welche Spalten haben √ºberhaupt fehlende Werte ‚Äì und wie viele?\n\nts |&gt;\n  summarise(\n    across(\n      everything(),\n      list(n_missing = ~ sum(is.na(.x)), pct_missing = ~ mean(is.na(.x))),\n      .names = \"{.col}__{.fn}\"\n    )\n  ) |&gt;\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\") |&gt;\n  separate(metric, into = c(\"variable\", \"metric\"), sep = \"__\") |&gt;\n  pivot_wider(names_from = metric, values_from = value) |&gt;\n  arrange(desc(pct_missing))\n\n# A tibble: 21 √ó 3\n   variable       n_missing pct_missing\n   &lt;chr&gt;              &lt;dbl&gt;       &lt;dbl&gt;\n 1 image_captions     49446     0.831  \n 2 related_links      42196     0.709  \n 3 tag                32797     0.551  \n 4 author             16625     0.279  \n 5 image_urls          6140     0.103  \n 6 keywords             638     0.0107 \n 7 date_modified        627     0.0105 \n 8 paragraphs           323     0.00543\n 9 text                 323     0.00543\n10 word_count           323     0.00543\n# ‚Ñπ 11 more rows\n\n\nDas Ergebnis hilft dir analytisch sofort weiter:\n\nSpalten mit sehr vielen fehlenden Werten eignen sich oft eher als optionale Zusatzinformationen.\nSpalten mit wenigen fehlenden Werten sind meist robuste ‚ÄûKernvariablen‚Äú.\nWenn wichtige Variablen viele NAs enthalten, lohnt sich Ursachenforschung (Erhebung, Scraper, Parsing, Definition der Variable).\n\nWenn du eine kompakte, gut lesbare Gesamtsicht m√∂chtest, ist skimr sehr praktisch (inkl. Missingness, Verteilungen, Beispiele). Damit die Kapitel auch ohne das Paket rendern, ist es hier optional:\n\nif (requireNamespace(\"skimr\", quietly = TRUE)) {\n  skimr::skim(ts)\n} else {\n  cat(\"Optional: install.packages('skimr') f√ºr eine kompakte Variable-√úbersicht.\\n\")\n}\n\n\nData summary\n\n\nName\nts\n\n\nNumber of rows\n59500\n\n\nNumber of columns\n21\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n18\n\n\nnumeric\n1\n\n\nPOSIXct\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\nsupertitle\n0\n1.00\n3\n67\n0\n46474\n0\n\n\ntitle\n0\n1.00\n3\n146\n0\n58902\n0\n\n\nauthor\n16625\n0.72\n3\n476\n0\n5216\n0\n\n\nressort\n5\n1.00\n2\n37\n0\n38\n0\n\n\nurl\n0\n1.00\n38\n174\n0\n59433\n0\n\n\nthumbnail\n22\n1.00\n67\n320\n0\n41449\n0\n\n\ntag\n32797\n0.45\n2\n76\n0\n375\n0\n\n\nshorttext\n7\n1.00\n10\n717\n0\n59056\n0\n\n\ndescription\n7\n1.00\n10\n807\n0\n59059\n0\n\n\nkeywords\n638\n0.99\n5\n763\n0\n41962\n0\n\n\ncanonical_url\n6\n1.00\n31\n174\n0\n59231\n0\n\n\nlanguage\n1\n1.00\n2\n2\n0\n4\n0\n\n\nparagraphs\n323\n0.99\n22\n84250\n0\n58986\n0\n\n\ntext\n323\n0.99\n18\n84140\n0\n58986\n0\n\n\nimage_urls\n6140\n0.90\n128\n166482\n0\n48806\n0\n\n\nimage_captions\n49446\n0.17\n10\n4379\n0\n9434\n0\n\n\nrelated_links\n42196\n0.29\n42\n27104\n0\n17122\n0\n\n\nsource_file\n0\n1.00\n25\n25\n0\n6351\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\nword_count\n323\n0.99\n540.12\n402.18\n3\n320\n461\n657\n11165\n‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\ndate_time\n29\n1.00\n2006-01-05 10:50:33\n2025-12-31 20:29:48\n2023-06-05 17:39:28\n59372\n\n\ndate_modified\n627\n0.99\n2007-05-10 14:15:00\n2026-02-09 17:57:43\n2024-11-07 18:20:14\n58867",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>√úbersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html#duplikate",
    "href": "project-2-news/variables.html#duplikate",
    "title": "\n5¬† Variablen\n",
    "section": "\n5.3 Duplikate",
    "text": "5.3 Duplikate\nDuplikate k√∂nnen in News-Daten aus verschiedenen Gr√ºnden entstehen: ein Artikel wurde mehrfach gespeichert, die gleiche URL taucht in mehreren Quellfiles auf, oder Inhalte sind sehr √§hnlich.\nIn der Praxis definieren wir Duplikate √ºber eine eindeutige ID. Bei Webdaten ist das h√§ufig die url (oder canonical_url). Schauen wir zuerst, ob es URLs gibt, die mehrfach vorkommen:\n\nts |&gt;\n  count(url, sort = TRUE) |&gt;\n  filter(!is.na(url), n &gt; 1)\n\n# A tibble: 11 √ó 2\n   url                                                                         n\n   &lt;chr&gt;                                                                   &lt;int&gt;\n 1 https://www.tagesschau.de/multimedia/podcast/11km/11km-feed-100.html       53\n 2 https://www.phoenix.de/livestream.html                                      5\n 3 https://www.tagesschau.de/multimedia/podcasts/podcast-11km-101.html         4\n 4 https://www.tagesschau.de/multimedia/podcast/11km/podcast-11km-2788.ht‚Ä¶     2\n 5 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-corona-s‚Ä¶     2\n 6 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-kontroll‚Ä¶     2\n 7 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-rauchen-‚Ä¶     2\n 8 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-streit-u‚Ä¶     2\n 9 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-tabubruc‚Ä¶     2\n10 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-weltglue‚Ä¶     2\n11 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-wer-mach‚Ä¶     2\n\n\nWenn du wissen willst, welche Datens√§tze dahinterstehen, kannst du dir einzelne F√§lle anzeigen lassen. Das ist ein typischer Debugging-Schritt in der Datenbereinigung:\n\nts |&gt;\n  add_count(url, name = \"n_url\") |&gt;\n  filter(!is.na(url), n_url &gt; 1) |&gt;\n  select(url, date_time, ressort, title, n_url) |&gt;\n  arrange(desc(n_url), url, date_time)\n\n# A tibble: 78 √ó 5\n   url                                   date_time           ressort title n_url\n   &lt;chr&gt;                                 &lt;dttm&gt;              &lt;chr&gt;   &lt;chr&gt; &lt;int&gt;\n 1 https://www.tagesschau.de/multimedia‚Ä¶ 2023-04-25 11:15:00 multim‚Ä¶ 11KM‚Ä¶    53\n 2 https://www.tagesschau.de/multimedia‚Ä¶ 2023-05-30 05:46:00 multim‚Ä¶ 11KM‚Ä¶    53\n 3 https://www.tagesschau.de/multimedia‚Ä¶ 2023-06-28 05:14:00 multim‚Ä¶ 11KM‚Ä¶    53\n 4 https://www.tagesschau.de/multimedia‚Ä¶ 2023-07-07 07:07:00 multim‚Ä¶ 11KM‚Ä¶    53\n 5 https://www.tagesschau.de/multimedia‚Ä¶ 2023-09-26 09:14:00 multim‚Ä¶ 11KM‚Ä¶    53\n 6 https://www.tagesschau.de/multimedia‚Ä¶ 2023-10-19 09:02:00 multim‚Ä¶ 11KM‚Ä¶    53\n 7 https://www.tagesschau.de/multimedia‚Ä¶ 2023-11-30 08:58:00 multim‚Ä¶ 11KM‚Ä¶    53\n 8 https://www.tagesschau.de/multimedia‚Ä¶ 2023-12-19 08:22:00 multim‚Ä¶ 11KM‚Ä¶    53\n 9 https://www.tagesschau.de/multimedia‚Ä¶ 2024-01-31 07:04:00 multim‚Ä¶ 11KM‚Ä¶    53\n10 https://www.tagesschau.de/multimedia‚Ä¶ 2024-02-28 06:29:00 multim‚Ä¶ 11KM‚Ä¶    53\n# ‚Ñπ 68 more rows\n\n\nF√ºr viele Analysen (z.B. Z√§hlen, Zeitreihen) willst du Duplikate entfernen, damit Ergebnisse nicht ‚Äûaufgeblasen‚Äú werden. Wenn url eindeutig sein soll, kannst du eine deduplizierte Version erzeugen:\n\nts_dedup &lt;- ts |&gt;\n  arrange(date_time) |&gt;\n  distinct(url, .keep_all = TRUE)\n\nts |&gt;\n  summarise(n_rows = n()) |&gt;\n  bind_cols(ts_dedup |&gt; summarise(n_rows_dedup = n()))\n\n# A tibble: 1 √ó 2\n  n_rows n_rows_dedup\n   &lt;int&gt;        &lt;int&gt;\n1  59500        59433\n\n\nWichtig: Welche Zeile du bei Duplikaten beh√§ltst (erste/letzte, nach date_modified, nach Datenqualit√§t) ist eine fachliche Entscheidung. arrange() vor distinct() macht diese Entscheidung explizit und reproduzierbar.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>√úbersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html#wertebereiche",
    "href": "project-2-news/variables.html#wertebereiche",
    "title": "\n5¬† Variablen\n",
    "section": "\n5.4 Wertebereiche",
    "text": "5.4 Wertebereiche\nWertebereiche (ranges) sind ein schneller Plausibilit√§tscheck. Gerade numerische Variablen enthalten manchmal Ausrei√üer oder ‚Äûkaputte‚Äú Werte (z.B. negative L√§ngen, extrem gro√üe Z√§hlwerte), die aus Parsing- oder Scraping-Problemen stammen.\nIm Datensatz gibt es z.B. word_count (Wortanzahl) und oft auch paragraphs (Absatzanzahl). Wir schauen uns typische Kennzahlen und Ausrei√üer an:\n\nts |&gt;\n  summarise(\n    n = n(),\n    word_count_min = min(word_count, na.rm = TRUE),\n    word_count_p25 = quantile(word_count, 0.25, na.rm = TRUE),\n    word_count_median = median(word_count, na.rm = TRUE),\n    word_count_p75 = quantile(word_count, 0.75, na.rm = TRUE),\n    word_count_max = max(word_count, na.rm = TRUE),\n    paragraphs_min = min(paragraphs, na.rm = TRUE),\n    paragraphs_median = median(paragraphs, na.rm = TRUE),\n    paragraphs_max = max(paragraphs, na.rm = TRUE)\n  )\n\n# A tibble: 1 √ó 9\n      n word_count_min word_count_p25 word_count_median word_count_p75\n  &lt;int&gt;          &lt;dbl&gt;          &lt;dbl&gt;             &lt;dbl&gt;          &lt;dbl&gt;\n1 59500              3            320               461            657\n# ‚Ñπ 4 more variables: word_count_max &lt;dbl&gt;, paragraphs_min &lt;chr&gt;,\n#   paragraphs_median &lt;chr&gt;, paragraphs_max &lt;chr&gt;\n\n\nEine Visualisierung macht Verteilungen und Ausrei√üer noch schneller greifbar. Ein Histogramm zeigt dir, wie ‚Äûlang‚Äú Tagesschau-Beitr√§ge typischerweise sind:\n\nts |&gt;\n  ggplot(aes(x = word_count)) +\n  geom_histogram(bins = 50, na.rm = TRUE) +\n  theme_bw() +\n  labs(x = \"Wortanzahl\", y = \"Anzahl der Beitr√§ge\")\n\n\n\n\n\n\n\nUnd ein Boxplot nach Ressort ist n√ºtzlich, um Unterschiede zwischen Kategorien sichtbar zu machen (z.B. sind Wirtschaftsartikel im Schnitt l√§nger?):\n\nts |&gt;\n  filter(!is.na(ressort), !is.na(word_count)) |&gt;\n  mutate(ressort = fct_lump_n(ressort, n = 10)) |&gt;\n  ggplot(aes(x = ressort, y = word_count)) +\n  geom_boxplot(outlier.alpha = 0.2) +\n  coord_flip() +\n  theme_bw() +\n  labs(x = \"Ressort (Top 10 + Other)\", y = \"Wortanzahl\")\n\n\n\n\n\n\n\nWarum ist das f√ºr Data Analytics hilfreich?\n\nDu bekommst ein Gef√ºhl f√ºr ‚Äûtypische‚Äú Inhalte (Baseline), bevor du Modelle baust.\nAusrei√üer-F√§lle sind oft inhaltlich spannend (Breaking News) oder Datenprobleme.\nKategorienvergleiche liefern schnell Hypothesen f√ºr tiefergehende Analysen (z.B. Trends je Ressort).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>√úbersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/time.html",
    "href": "project-2-news/time.html",
    "title": "\n6¬† Zeit\n",
    "section": "",
    "text": "6.1 Verteilung der Beitr√§ge √ºber die Zeit\nNachrichten haben einen inh√§renten zeitlichen Charakter, da sie sich auf aktuelle Ereignisse beziehen. Es ist daher interessant zu sehen, wie die Anzahl der ver√∂ffentlichten Nachrichtenbeitr√§ge √ºber die Zeit verteilt ist. Die entsprechende Spalte f√ºr den Zeitbezug erkennen wir in der Ausgabe der glimpse()-Funktion oben am Datentyp &lt;dttm&gt;, was f√ºr datetime steht. Schauen wir uns ein paar Beispiele an:\nts |&gt;\n  select(date_time)\n\n# A tibble: 59,500 √ó 1\n   date_time          \n   &lt;dttm&gt;             \n 1 2006-01-05 10:50:33\n 2 2006-01-13 13:47:00\n 3 2006-01-13 10:18:00\n 4 2006-01-14 14:24:00\n 5 2006-01-15 14:44:00\n 6 2006-01-18 19:30:00\n 7 2006-01-25 17:37:00\n 8 2006-02-02 10:52:26\n 9 2006-02-02 08:39:00\n10 2006-02-14 14:20:00\n# ‚Ñπ 59,490 more rows\nWir erkennen an der Ausgabe der ersten Zeilen wie genau ein Wert vom datetime-Datentyp aufgebaut ist. Es handelt sich um ein standardisiertes Format mit dem Namen ISO-8601, das einer festen Syntax folgt. Der erste Teil stellt das Datum mit seinen Bestandteilen Jahr, Monat und Tag dar, jeweils als vierstellige (Jahr) und zweistellige (Monat, Tag) Zahlen, getrennt mit einem Bindestrich. Danach folgt, getrennt durch ein Leerzeichen, die Uhrzeitangabe. Hier ist das Format wie gewohnt: HH:MM:ss, also jeweils zwei Ziffern f√ºr die Stunde, Minute und Sekunde, jeweils durch einen Doppelpunkt getrennt.\nWeil das Format standardisiert ist, gibt es entsprechende Funktionen, mit denen wir jeden Bestandteil extrahieren wollen. Mit der Funktion year() bekommen wir etwa nur das Jahr als Zahl. Ensprechende Funktionen gibt es auch f√ºr andere Datums- und Zeitbestandteile. Details zur Arbeit mit Datum und Zeit findet ihr im Kapitel Dates and times aus Wickham u.¬†a. (2023).\nGleichzeitig k√∂nnen wir ein Datum abrunden - klingt komisch? Dabei schneiden wir einfach den Teil des Zeitstempels ab, der unseren gew√ºnschten Detailgrad √ºberschreitet. Wenn wir etwa eine Analyse auf Monatsbasis erstellen wollen, dann k√∂nnen wir jedes Datum auf den jeweils ersten des Monats runden, im dem sich der Zeitstempel befindet:\nts |&gt;\n  mutate(date_month = floor_date(date_time, unit = \"month\"), .keep = \"used\")\n\n# A tibble: 59,500 √ó 2\n   date_time           date_month         \n   &lt;dttm&gt;              &lt;dttm&gt;             \n 1 2006-01-05 10:50:33 2006-01-01 00:00:00\n 2 2006-01-13 13:47:00 2006-01-01 00:00:00\n 3 2006-01-13 10:18:00 2006-01-01 00:00:00\n 4 2006-01-14 14:24:00 2006-01-01 00:00:00\n 5 2006-01-15 14:44:00 2006-01-01 00:00:00\n 6 2006-01-18 19:30:00 2006-01-01 00:00:00\n 7 2006-01-25 17:37:00 2006-01-01 00:00:00\n 8 2006-02-02 10:52:26 2006-02-01 00:00:00\n 9 2006-02-02 08:39:00 2006-02-01 00:00:00\n10 2006-02-14 14:20:00 2006-02-01 00:00:00\n# ‚Ñπ 59,490 more rows\nIn der Ausgabe seht ihr links das Originaldatum mit allen Details und rechts das abgeschnittene und auf den ersten des jeweiligen Monats gerundete Datum. Das Sch√∂ne an floor_date() ist, dass es als Ergebnis einen Wert vom gleichen Datentyp erzeugt, also auch ein datetime. Warum ist das gut? Weil wir damit in der Visualisieurung gut klarkommen, wie ihr im n√§chsten Schritt sehen werdet:\nts |&gt;\n  mutate(date_month = floor_date(date_time, \"month\")) |&gt;\n  ggplot() +\n  aes(x = date_month) +\n  geom_bar() +\n  theme_bw() +\n  labs(x = \"Monat\", y = \"Anzahl der Beitr√§ge\")\nSchaut mal auf die x-Achse. F√§llt euch was auf?",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Zeit</span>"
    ]
  },
  {
    "objectID": "project-2-news/time.html#verteilung-der-beitr√§ge-√ºber-die-zeit",
    "href": "project-2-news/time.html#verteilung-der-beitr√§ge-√ºber-die-zeit",
    "title": "\n6¬† Zeit\n",
    "section": "",
    "text": "Wickham, Hadley, Mine √áetinkaya-Rundel, und Garrett Grolemund. 2023. R for data science: import, tidy, transform, visualize, and model data. 2nd edition. O‚ÄôReilly Media, Inc.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Zeit</span>"
    ]
  },
  {
    "objectID": "r-basics/ide.html",
    "href": "r-basics/ide.html",
    "title": "\n7¬† Entwicklungsumgebung\n",
    "section": "",
    "text": "7.1 Positron installieren\nZum Programmieren reicht theoretisch ein einfacher Texteditor, denn Code ist am Ende nur Text. In der Praxis wollt ihr aber Unterst√ºtzung beim Schreiben, beim Ausf√ºhren und beim Organisieren eurer Dateien. Genau daf√ºr gibt es integrierte Entwicklungsumgebungen, kurz IDEs (das steht f√ºr Integrated Development Environment).\nIn diesem Buch arbeiten wir mit Positron. Das ist eine moderne Entwicklungsumgebung f√ºr Data Science, die sich in vielen Dingen wie Visual Studio Code anf√ºhlt. Installiert Positron jetzt einmal, dann nutzen wir es direkt f√ºr eure ersten Schritte in R.\nLadet Positron in der neuesten Version herunter und installiert es auf eurem Rechner: positron.posit.co/download.html. Startet Positron danach direkt. Wenn es ge√∂ffnet ist, geht es mit dem n√§chsten Abschnitt weiter.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Entwicklungsumgebung</span>"
    ]
  },
  {
    "objectID": "r-basics/ide.html#projekte-und-ordner",
    "href": "r-basics/ide.html#projekte-und-ordner",
    "title": "\n7¬† Entwicklungsumgebung\n",
    "section": "\n7.2 Projekte und Ordner",
    "text": "7.2 Projekte und Ordner\nIn Positron arbeitet ihr in Projekten. Ein Projekt ist schlicht ein Ordner, in dem alles liegt, was zusammengeh√∂rt: Skripte, Daten, Abbildungen und Ergebnisse.\nEine einfache Regel hilft euch, sauber zu bleiben: Legt f√ºr jedes neue Vorhaben einen eigenen Projektordner an. Viele erstellen daf√ºr einen √ºbergeordneten Ordner wie R-Projekte und legen darin pro Projekt einen Unterordner an. So findet ihr Dinge schneller wieder und mischt Dateien nicht aus Versehen.\n\n\n\n\n\n\nTippSicherung eurer Projekte\n\n\n\nWenn ihr regelm√§√üig an Projekten arbeitet, lohnt sich eine Strategie f√ºr Backups. Eine gute Kombination ist ein Ordner, der automatisch synchronisiert wird, plus Versionsverwaltung f√ºr wichtige Projekte. Ich nutze daf√ºr einen Projektordner in OneDrive und lege wichtige Codeprojekte zus√§tzlich auf GitHub ab.\n\n\n\n\nMeine Projekte liegen in einem gemeinsamen Ordner.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Entwicklungsumgebung</span>"
    ]
  },
  {
    "objectID": "r-basics/ide.html#projekt-√∂ffnen",
    "href": "r-basics/ide.html#projekt-√∂ffnen",
    "title": "\n7¬† Entwicklungsumgebung\n",
    "section": "\n7.3 Projekt √∂ffnen",
    "text": "7.3 Projekt √∂ffnen\nLegt zuerst euren Projektordner im Datei-Explorer an. √ñffnet anschlie√üend diesen Ordner in Positron. Sobald der Ordner ge√∂ffnet ist, seht ihr links die Projektstruktur, in der Mitte euren Editor und unten die Konsole.\nAb jetzt gilt: Alles, was zu eurem Projekt geh√∂rt, landet in diesem Ordner. Wenn ihr sp√§ter mit Daten arbeitet, speichert ihr sie ebenfalls dort oder ihr ladet sie aus einer Quelle, die ihr nachvollziehbar dokumentiert.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Entwicklungsumgebung</span>"
    ]
  },
  {
    "objectID": "r-basics/ide.html#dateien-anlegen",
    "href": "r-basics/ide.html#dateien-anlegen",
    "title": "\n7¬† Entwicklungsumgebung\n",
    "section": "\n7.4 Dateien anlegen",
    "text": "7.4 Dateien anlegen\nIn Positron k√∂nnt ihr neue Dateien √ºber das Men√º (File &gt; New File) oder √ºber das Kontextmen√º im Projektbaum anlegen. W√§hlt einen sprechenden Namen und achtet auf die Dateiendung, denn daran erkennt Positron, welche Sprache ihr nutzt und welche Funktionen es anbieten soll:\n\n\n.R f√ºr R-Skripte\n\n.qmd f√ºr Quarto-Dateien\n\n.py f√ºr Python-Skripte\n\nF√ºr den Start gen√ºgt ein leeres R-Skript. Legt es an, √∂ffnet es im Editor und schreibt diesen Code hinein:\n\nsqrt(64)",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Entwicklungsumgebung</span>"
    ]
  },
  {
    "objectID": "r-basics/ide.html#hilfe-beim-tippen",
    "href": "r-basics/ide.html#hilfe-beim-tippen",
    "title": "\n7¬† Entwicklungsumgebung\n",
    "section": "\n7.5 Hilfe beim Tippen",
    "text": "7.5 Hilfe beim Tippen\nWenn ihr Code schreibt, unterst√ºtzt euch Positron mit Autovervollst√§ndigung. Tippt einmal sqr und achtet auf das Vorschlagsfenster. Mit den Pfeiltasten k√∂nnt ihr einen Vorschlag ausw√§hlen und mit der Tab-Taste vervollst√§ndigen.\nNach dem Einf√ºgen von sqrt() springt der Cursor in die Klammern. Oft blendet Positron zus√§tzlich Hinweise zu Funktionsargumenten ein. Bei sqrt() ist das nur x, bei anderen Funktionen sind es mehrere. Das spart Zeit und verhindert Tippfehler.\n\n\n\n\n\n\nTippAutovervollst√§ndigung √∂ffnen\n\n\n\nWenn keine Vorschl√§ge erscheinen, √∂ffnet ihr sie manuell mit Strg+Space unter Windows oder mit Cmd+Space unter macOS.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Entwicklungsumgebung</span>"
    ]
  },
  {
    "objectID": "r-basics/ide.html#speichern",
    "href": "r-basics/ide.html#speichern",
    "title": "\n7¬† Entwicklungsumgebung\n",
    "section": "\n7.6 Speichern",
    "text": "7.6 Speichern\nSobald ihr eine Datei ver√§ndert, markiert Positron sie als noch nicht gespeichert. Speichert regelm√§√üig, zum Beispiel √ºber das Disketten-Symbol oder mit Strg+S unter Windows oder Cmd+S unter macOS. Danach ist der aktuelle Stand sicher in eurem Projektordner.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Entwicklungsumgebung</span>"
    ]
  },
  {
    "objectID": "r-basics/ide.html#code-ausf√ºhren",
    "href": "r-basics/ide.html#code-ausf√ºhren",
    "title": "\n7¬† Entwicklungsumgebung\n",
    "section": "\n7.7 Code ausf√ºhren",
    "text": "7.7 Code ausf√ºhren\nUm einen Befehl auszuf√ºhren, setzt den Cursor in die Zeile und nutzt Strg+Enter unter Windows oder Cmd+Enter unter macOS. Das Ergebnis erscheint unten in der Konsole. Probiert es mit sqrt(64) aus. Dort sollte 8 ausgegeben werden.\nF√ºr ganze Skripte gibt es im Editor au√üerdem ein Start-Symbol. Dahinter stecken typischerweise diese Optionen:\n\n\nSource R File with Echo: F√ºhrt das gesamte Skript aus und zeigt den Code in der Konsole.\n\nSource R File: F√ºhrt das gesamte Skript aus, ohne den Code in der Konsole zu zeigen.\n\nExecute Code: F√ºhrt nur den aktuellen Befehl aus, wie Strg+Enter oder Cmd+Enter.\n\n\n\n\n\n\n\nTippDateien und Ordner organisieren\n\n\n\nIm Projektbaum k√∂nnt ihr Dateien und Ordner anlegen, umbenennen, verschieben und l√∂schen. Wenn ihr einmal ein Projekt sauber angelegt habt, m√ºsst ihr Positron daf√ºr meist nicht mehr verlassen.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Entwicklungsumgebung</span>"
    ]
  },
  {
    "objectID": "r-basics/loading-data.html",
    "href": "r-basics/loading-data.html",
    "title": "8¬† Daten laden",
    "section": "",
    "text": "8.1 Dateiformate\nJeder Analyseprozess beginnt mit dem Laden der Daten (s. Abbildung¬†8.1). In diesem Abschnitt schauen wir uns an, wie wir die g√§ngigsten Datenformate in R laden k√∂nnen. Dabei werden wir uns auf die Funktionen aus dem readr-Paket konzentrieren, das Teil des tidyverse ist.\nDaten im Computer speichern wir √ºblicherweise in Dateien. Eimn Datensatz kann so aus einer oder mehreren Dateien bestehen. Eine Datei enth√§lt auf der untersten Ebene Daten in Form von Nullen und Einsen, denn der Computer arbitet mit Bits und dem Bin√§rsystem. Somit ist auch jeder Datensatz grunds√§tzlich als Nullen und Einsen gespeichert.\nIn der Arbeit mit Daten unterscheiden wir zwei grundlegende Ideen, wie wir einen Datensatz als Datei speichern:\nWas ist der Unterschied? Eine Textdatei speichert die Daten in einem Format, das f√ºr Menschen lesbar ist. Das bedeutet, dass die Daten in einer Textdatei als Zeichenfolge (String) gespeichert werden, die von Menschen verstanden werden kann. Dazu verwendet man ein g√§ngiges Kodierungssystem wie etwa UTF-8, im dem jedes Symbol (Buchstaben, Zahlen, Satzzeichen etc.) einer Fole von Nullen und Einsen zugewiesen wird. Beispiele f√ºr textbasierte Formate sind CSV (Comma-Separated Values), TSV (Tab-Separated Values) und JSON (JavaScript Object Notation). Textbasierte Formate k√∂nnen wir in jedem beliebigen Texteditor √∂ffnen und lesen, wie zum Beispiel Notepad, dem Windows Editor oder auch Word. Eine Textdatei enth√§lt die Information, mit welchem Kodierungssystem sie erstellt wurde, und der Texteditor kann die Bitfolgen damit in Zeichen umwandeln und uns Menschen anzeigen. Und das ist auch der gro√üe Vorteil von textbasierten Formaten: Sie sind einfach zu verstehen und zu bearbeiten, da sie in einem menschenlesbaren Format vorliegen.\nBin√§re Formate sind solche Formate, die die Daten nicht als Texte kodieren, sondern in einem Format, das f√ºr Computer effizienter zu lesen und zu schreiben ist. Beispiele f√ºr bin√§re Formate sind Excel-Dateien (.xlsx), RData-Dateien (.RData) und Parquet-Dateien (.parquet). Bin√§re Formate sind in der Regel schneller zu lesen und zu schreiben als textbasierte Formate, da sie weniger Speicherplatz ben√∂tigen und schneller verarbeitet werden k√∂nnen. Allerdings sind sie nicht direkt von Menschen lesbar und erfordern spezielle Software oder Bibliotheken, um sie zu √∂ffnen und zu bearbeiten.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Daten laden</span>"
    ]
  },
  {
    "objectID": "r-basics/loading-data.html#dateiformate",
    "href": "r-basics/loading-data.html#dateiformate",
    "title": "8¬† Daten laden",
    "section": "",
    "text": "Als Textdatei\nAls Bin√§rdatei\n\n\n\nDateiformate f√ºr Daten sind entweder textbasierte Formate oder propriet√§re bin√§re Formate.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Daten laden</span>"
    ]
  },
  {
    "objectID": "r-basics/loading-data.html#textbasierte-formate",
    "href": "r-basics/loading-data.html#textbasierte-formate",
    "title": "8¬† Daten laden",
    "section": "\n8.2 Textbasierte Formate",
    "text": "8.2 Textbasierte Formate\nEines der g√§ngisten Datenformate, das auf textueller Basis arbeitet, ist das CSV-Format. CSV steht f√ºr ‚ÄúComma-Separated Values‚Äù und ist ein einfaches Format, das Daten in tabellarischer Form speichert. Jede Zeile in einer CSV-Datei entspricht einer Zeile in der Tabelle, und die Werte in jeder Zeile werden durch Kommatas getrennt. CSV-Dateien k√∂nnen von vielen Anwendungen erstellt und gelesen werden, einschlie√ülich Tabellenkalkulationsprogrammen wie Microsoft Excel und Google Sheets.\nIn R k√∂nnen wir CSV-Dateien mit der Funktion read_csv() aus dem readr-Paket laden. Hier ist ein Beispiel, wie wir eine CSV-Datei laden k√∂nnen:\n\ntweets &lt;- read_csv(\"data/orders.csv\")\ntweets |&gt; \n    head(5)\n\n# A tibble: 5 √ó 68\n      order_id name  order_number app_id created_at          updated_at         \n         &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             \n1      1.13e12 B1014         1014 580111 2019-05-24 12:59:16 2019-06-19 13:23:26\n2      1.13e12 B1015         1015 580111 2019-05-24 13:09:08 2019-06-21 14:40:07\n3      1.13e12 B1016         1016 580111 2019-05-24 13:22:41 2019-06-21 12:35:23\n4      1.13e12 B1017         1017 580111 2019-05-24 13:27:43 2019-06-21 14:27:18\n5      1.13e12 B1018         1018 580111 2019-05-24 13:36:46 2019-06-21 12:11:57\n# ‚Ñπ 62 more variables: test &lt;lgl&gt;, current_subtotal_price &lt;dbl&gt;,\n#   current_total_price &lt;dbl&gt;, current_total_discounts &lt;dbl&gt;,\n#   current_total_duties_set &lt;dbl&gt;, total_discounts &lt;dbl&gt;,\n#   total_line_items_price &lt;dbl&gt;, total_outstanding &lt;dbl&gt;, total_price &lt;dbl&gt;,\n#   total_tax &lt;dbl&gt;, total_tip_received &lt;dbl&gt;, taxes_included &lt;lgl&gt;,\n#   discount_codes &lt;chr&gt;, financial_status &lt;chr&gt;, fulfillment_status &lt;chr&gt;,\n#   source_name &lt;chr&gt;, landing_site &lt;chr&gt;, landing_site_ref &lt;chr&gt;, ‚Ä¶\n\n\nDas hat offensichtlich funktioniert. Es gibt bei CSV-Dateien Dinge, die sich unterscheiden k√∂nnen und die wir ber√ºcksichtigen m√ºssen, wenn wir sie laden.\nDas Trennzeichen\nIn einigen L√§ndern, wie zum Beispiel Deutschland, wird anstelle eines Kommas h√§ufig ein Semikolon als Trennzeichen verwendet. In diesem Fall k√∂nnen wir die Funktion read_csv2() verwenden, die speziell f√ºr dieses Format entwickelt wurde. Ob das Trennzeichen falsch eingestellt ist, erkennt man sofort am Ergebnis beim Laden der Daten: Alle Werte werden in einer einzigen Spalte zusammengefasst, anstatt in mehreren Spalten verteilt zu sein. Schauen wir uns das kurz an:\n\norders_wrong &lt;- read_csv2(\"data/orders.csv\")\n\nWie in der Ausgabe zu sehen, wurde genau eine Spalte erkannt. Wenn wir uns noch Beispielwere ausgeben lassen, sehen wir, dass alle Werte in dieser einen Spalte zusammengefasst wurden:\n\nhead(orders_wrong)\n\n# A tibble: 6 √ó 1\n  order_id,name,order_number,app_id,created_at,updated_at,test,current_subtota‚Ä¶¬π\n  &lt;chr&gt;                                                                         \n1 \"1130007101519,B1014,1014,580111,2019-05-24T14:59:16+02:00,2019-06-19T15:23:2‚Ä¶\n2 \"1130014965839,B1015,1015,580111,2019-05-24T15:09:08+02:00,2019-06-21T16:40:0‚Ä¶\n3 \"1130026958927,B1016,1016,580111,2019-05-24T15:22:41+02:00,2019-06-21T14:35:2‚Ä¶\n4 \"1130030563407,B1017,1017,580111,2019-05-24T15:27:43+02:00,2019-06-21T16:27:1‚Ä¶\n5 \"1130038853711,B1018,1018,580111,2019-05-24T15:36:46+02:00,2019-06-21T14:11:5‚Ä¶\n6 \"1130045964367,B1019,1019,580111,2019-05-24T15:44:41+02:00,2019-06-21T16:37:2‚Ä¶\n# ‚Ñπ abbreviated name:\n#   ¬π‚Äã`order_id,name,order_number,app_id,created_at,updated_at,test,current_subtotal_price,current_total_price,current_total_discounts,current_total_duties_set,total_discounts,total_line_items_price,total_outstanding,total_price,total_tax,total_tip_received,taxes_included,discount_codes,financial_status,fulfillment_status,source_name,landing_site,landing_site_ref,location_id,note,tags,processed_at,processing_method,payment_details_gateway,payment_details_credit_card_company,customer_id,customer_accepts_marketing,customer_accepts_marketing_updated_at,customer_marketing_opt_in_level,customer_sms_marketing_consent,customer_created_at,customer_updated_at,customer_gender,customer_is_hsos,customer_state,customer_orders_count,customer_total_spent,customer_last_order_id,customer_note,customer_verified_email,customer_tax_exempt,customer_tags,customer_last_order_name,campaign_tag,shipping_address_city,shipping_address_zip,shipping_address_country,shipping_address_latitude,shipping_address_longitude,billing_address_city,billing_address_zip,billing_address_country,billing_address_company,billing_address_latitude,billing_address_longitude,client_details_browser_ip,client_details_browser_height,client_details_browser_width,client_details_user_agent,cancel_reason,cancelled_at,closed_at`\n\n\nDie Funktion read_csv2 verwenden wir nur, wenn wirklich ein Semikolon als Trennzeichen verwendet wird. Bei einem Komma als Trennzeichen m√ºssen wir read_csv() verwenden, damit die Werte korrekt in Spalten aufgeteilt werden.\nEs gibt mit den Tabulator-Zeichen noch ein weiteres g√§ngiges Trennzeichen, das ebenfalls durch eine eigene Funktion angedeckt wird. Sollte es ein ganz anderes Trennzeichen sein, k√∂nnen wir die allgemeine Funktion read_delim() verwenden, bei der wir das Trennzeichen explizit angeben k√∂nnen. Die Tabelle gibt einen √úberblick.\n\n\nFunktion\nTrennzeichen\n\n\n\nread_csv()\nKomma (,)\n\n\nread_csv2()\nSemikolon (;)\n\n\nread_tsv()\nTabulator (\\t)\n\n\nread_delim()\nBeliebiges Trennzeichen (muss angegeben werden)\n\n\n\nHier ein Beispiel f√ºr die Verwendung von read_delim(), wenn das Trennzeichen ein Pipe-Symbol w√§re, was auch vorkommt:\n\norders_delim &lt;- read_delim(\"data/orders.csv\", delim = \"|\")\n\nDie Zeichenkodierung\nWie bereits erw√§hnt, speichern Textdateien die Daten in einem bestimmten Kodierungsformat. In Deutschland ist es √ºblich, das Kodierungsformat ‚ÄúISO-8859-1‚Äù oder ‚ÄúLatin-1‚Äù zu verwenden, w√§hrend in anderen L√§ndern h√§ufig ‚ÄúUTF-8‚Äù verwendet wird. Wenn die CSV-Datei in einem anderen Kodierungsformat vorliegt, m√ºssen wir dies beim Laden der Datei angeben, damit die Daten korrekt interpretiert werden k√∂nnen.\nDa die meisten Dateien heute im UTF-8-Format vorliegen, ist dies auch die Standardeinstellung in den Funktionen von readr. Mit UTF-8 k√∂nnen wir auch das h√§ufig √§ltere, aber immernoch verwendete ASCII-Zeichenset abdecken, weil UTF-8 r√ºckw√§rtskompatibel ist. Wenn die CSV-Datei jedoch in einem anderen Kodierungsformat vorliegt, m√ºssen wir dies explizit angeben. Hier ein Beispiel, wie wir eine CSV-Datei mit einem anderen Kodierungsformat laden k√∂nnen:\n\norders_iso &lt;- read_csv(\n    \"data/orders.csv\", \n    locale = locale(encoding = \"ISO-8859-1\")\n)\n\nDas ISO-8859-1-Kodierungsformat ist eine Erweiterung des ASCII-Zeichensatzes und unterst√ºtzt die meisten westeurop√§ischen Sprachen, einschlie√ülich Deutsch mit seinen Umlauten, und ist daher eine h√§ufige Wahl f√ºr CSV-Dateien in Deutschland. Wenn die CSV-Datei in diesem Format vorliegt, m√ºssen wir dies beim Laden der Datei angeben, damit die Daten korrekt interpretiert werden k√∂nnen. UTF-8 ist leider nicht vollst√§ndig r√ºckw√§rtskompatibel mit ISO-8859-1.\nDas Dezimaltrennzeichen\nIn einigen L√§ndern, wie zum Beispiel Deutschland, wird anstelle eines Punktes h√§ufig ein Komma als Dezimaltrennzeichen verwendet. In diesem Fall k√∂nnen wir die Funktion read_csv2() verwenden, die speziell f√ºr dieses Format entwickelt wurde. Wir k√∂nnen das Dezimaltrennzeichen aber auch explizit angeben √ºber den Parameter locale.\nOb das Dezimaltrennzeichen falsch eingestellt ist, erkennt man sofort am Ergebnis beim Laden der Daten: Alle Zahlen, die ein Dezimaltrennzeichen enthalten, werden als Zeichen (Strings) interpretiert, anstatt als numerische Werte. Das liegt daran, dass R das Komma als Trennzeichen f√ºr Spalten erwartet und nicht als Dezimaltrennzeichen. Wenn das Komma als Dezimaltrennzeichen verwendet wird, wird die gesamte Zahl als Text interpretiert, da R das Komma nicht als Teil einer Zahl erkennt.\nHier ein Beispiel, wie das aussieht, wenn das Dezimaltrennzeichen falsch eingestellt ist:\n\norders_wrong_decimal &lt;- read_csv(\n    \"data/orders.csv\", \n    locale = locale(decimal_mark = \",\")\n)\n\nIm Beispiel oben haben wir absichtlich ein falsches Dezimaltrennzeichen angegeben. Schauen wir uns jetzt die Spalte total_price, an die eigentlich eine Dezimalzahl ein m√ºsste:\n\norders_wrong_decimal |&gt; \n    select(total_price) |&gt; \n    head(5)\n\n# A tibble: 5 √ó 1\n  total_price\n  &lt;chr&gt;      \n1 94.66      \n2 32.22      \n3 30.22      \n4 32.22      \n5 30.22      \n\n\nAchtet auf die Angabe des Datentyps chr, was f√ºr ‚Äúcharacter‚Äù steht, also Zeichen oder Text. Wir sollten als schleunigst das richtige Dezimaltrennzeichen verwenden.\nManchnal hat nur eine Spalte ein anderes Dezimaltrennzeichen als die anderen Spalten. Dann k√∂nnn wir uns damit behelfen, die Spalte nachtr√§glich in den korrekten Datentyp umzuwandeln. Hier ein Beispiel, wie das geht:\n\norders_fixed_decimal &lt;- orders_wrong_decimal |&gt; \n    mutate(total_price = as.double(total_price))\n\nJetzt ist die Spalte total_price in einen numerischen Wert √ºberf√ºhrt worden, da wir das Dezimaltrennzeichen in der Funktion parse_number() explizit angegeben haben. Schauen wir uns jetzt die Spalte total_price an:\n\norders_fixed_decimal |&gt; \n    select(total_price) |&gt; \n    head(5)\n\n# A tibble: 5 √ó 1\n  total_price\n        &lt;dbl&gt;\n1        94.7\n2        32.2\n3        30.2\n4        32.2\n5        30.2\n\n\nDie Funktion as-double() sucht standardm√§√üig nach einem Punkt als Dezimaltrennzeichen. Sollte es in der Spalte total_price tats√§chlich ein Komma als Dezimaltrennzeichen geben, m√ºssen wir die Funktion parse_number verwenden und das Dezimaltrennzeichen explizit angeben. Hier ein Beispiel, wie das geht:\n\norders_fixed_decimal &lt;- orders_wrong_decimal |&gt; \n    mutate(total_price = parse_number(total_price, locale = locale(decimal_mark = \",\")))\n\nVorhandensein von Kopfzeilen\nCSV-Dateien enthalten in der Regel eine Kopfzeile, die die Namen der Spalten angibt. Die Funktionen aus dem Tidyverse und speziell readr gehen davon aus, dass diese Zeile vorhanden ist. Wenn die CSV-Datei jedoch keine Kopfzeile enth√§lt, m√ºssen wir dies beim Laden der Datei angeben, damit die Daten korrekt interpretiert werden k√∂nnen. Hier ein Beispiel, wie wir eine CSV-Datei ohne Kopfzeile laden k√∂nnen:\n\norders_no_header &lt;- read_csv(\n    \"data/orders.csv\", \n    col_names = FALSE\n)\n\nSchaut euch das Ergebnis nun an:\n\norders_no_header |&gt; \n    head(5)\n\n# A tibble: 5 √ó 68\n  X1     X2    X3    X4    X5    X6    X7    X8    X9    X10   X11   X12   X13  \n  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 order‚Ä¶ name  orde‚Ä¶ app_‚Ä¶ crea‚Ä¶ upda‚Ä¶ test  curr‚Ä¶ curr‚Ä¶ curr‚Ä¶ curr‚Ä¶ tota‚Ä¶ tota‚Ä¶\n2 11300‚Ä¶ B1014 1014  5801‚Ä¶ 2019‚Ä¶ 2019‚Ä¶ False 94.66 94.66 2.0   0.0   2.0   96.66\n3 11300‚Ä¶ B1015 1015  5801‚Ä¶ 2019‚Ä¶ 2019‚Ä¶ False 32.22 32.22 0.0   0.0   0.0   32.22\n4 11300‚Ä¶ B1016 1016  5801‚Ä¶ 2019‚Ä¶ 2019‚Ä¶ False 30.22 30.22 2.0   0.0   2.0   32.22\n5 11300‚Ä¶ B1017 1017  5801‚Ä¶ 2019‚Ä¶ 2019‚Ä¶ False 32.22 32.22 0.0   0.0   0.0   32.22\n# ‚Ñπ 55 more variables: X14 &lt;chr&gt;, X15 &lt;chr&gt;, X16 &lt;chr&gt;, X17 &lt;chr&gt;, X18 &lt;chr&gt;,\n#   X19 &lt;chr&gt;, X20 &lt;chr&gt;, X21 &lt;chr&gt;, X22 &lt;chr&gt;, X23 &lt;chr&gt;, X24 &lt;chr&gt;,\n#   X25 &lt;chr&gt;, X26 &lt;chr&gt;, X27 &lt;chr&gt;, X28 &lt;chr&gt;, X29 &lt;chr&gt;, X30 &lt;chr&gt;,\n#   X31 &lt;chr&gt;, X32 &lt;chr&gt;, X33 &lt;chr&gt;, X34 &lt;chr&gt;, X35 &lt;chr&gt;, X36 &lt;chr&gt;,\n#   X37 &lt;chr&gt;, X38 &lt;chr&gt;, X39 &lt;chr&gt;, X40 &lt;chr&gt;, X41 &lt;chr&gt;, X42 &lt;chr&gt;,\n#   X43 &lt;chr&gt;, X44 &lt;chr&gt;, X45 &lt;chr&gt;, X46 &lt;chr&gt;, X47 &lt;chr&gt;, X48 &lt;chr&gt;,\n#   X49 &lt;chr&gt;, X50 &lt;chr&gt;, X51 &lt;chr&gt;, X52 &lt;chr&gt;, X53 &lt;chr&gt;, X54 &lt;chr&gt;, ‚Ä¶\n\n\nWas ist passiert? Die Variablen (Spalten) wurden automatisch mit generischen Namen wie X1, X2, X3 usw. benannt, da keine Kopfzeile vorhanden war, die die Spaltennamen angibt. Dazu wurde die erste Zeile der CSV-Datei als Datenzeile interpretiert, anstatt als Kopfzeile.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Daten laden</span>"
    ]
  },
  {
    "objectID": "r-basics/loading-data.html#bin√§re-formate",
    "href": "r-basics/loading-data.html#bin√§re-formate",
    "title": "8¬† Daten laden",
    "section": "\n8.3 Bin√§re Formate",
    "text": "8.3 Bin√§re Formate\nR-Data-Serialization (RDS)",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Daten laden</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html",
    "href": "r-basics/pipe.html",
    "title": "9¬† Pipe-Operator",
    "section": "",
    "text": "9.1 Was macht die Pipe eigentlich?\nWenn ihr Daten analysiert, arbeitet ihr fast nie mit einem Befehl. Stattdessen baut ihr eine kleine Kette aus vielen Schritten: Spalten ausw√§hlen, Zeilen filtern, neue Variablen berechnen, sortieren, zusammenfassen und zwischendurch kurz pr√ºfen, ob alles so aussieht wie gedacht.\nOhne Pipe werden solche Schrittketten schnell un√ºbersichtlich. Mit der Pipe schreibt ihr eure Analyse so, dass ihr sie wie einen Text von oben nach unten lesen k√∂nnt.\nIn diesem Kapitel kl√§ren wir drei Fragen:\nDie wichtigste Regel ist kurz:\nSchauen wir uns das in einem kleinen Beispiel an. Die Funktion nrow() gibt euch die Anzahl Zeilen eines Datensatzes zur√ºck. Ohne Pipe schreibt ihr:\nMit Pipe r√ºckt der Datensatz nach links und wird rechts automatisch in nrow() eingesetzt:\nDas Ergebnis einer Pipe muss √ºbrigens nicht immer ein Tibble bleiben. Nach nrow() ist das Ergebnis eine Zahl, in diesem Datensatz also 58.421. Diese Zahl k√∂nnt ihr direkt in den n√§chsten Schritt weiterreichen:\nInhaltlich ist das Beispiel etwas k√ºnstlich. Es zeigt aber gut, dass die Pipe einfach Ergebnisse weiterreicht, egal ob es ein Tibble, eine Zahl oder ein Text ist.\nIn Abbildung¬†9.1 seht ihr das typische Muster, das euch im ganzen Buch immer wieder begegnet: Am Anfang steht ein Datensatz als Tibble, danach folgen mehrere Schritte, am Ende kommt oft eine kurze Ausgabe zur Kontrolle.\nIn Listing¬†9.1 ist tweets der Startpunkt. select() nimmt den Tibble und reduziert ihn auf die gew√ºnschten Spalten. glimpse() bekommt dann das Ergebnis und zeigt euch schnell Struktur und erste Werte.\nWenn ihr es formeller m√∂gt, k√∂nnt ihr euch eine Pipe-Kette wie eine verschachtelte Funktionsanwendung vorstellen:",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html#was-macht-die-pipe-eigentlich",
    "href": "r-basics/pipe.html#was-macht-die-pipe-eigentlich",
    "title": "9¬† Pipe-Operator",
    "section": "",
    "text": "Die Pipe nimmt das Ergebnis links und setzt es rechts als erstes Argument ein.\n\nDas sieht zum Beispiel so aus:\nx |&gt; f(a, b)\nund bedeutet:\nf(x, a, b)\n\n\n\n\nnrow(tweets)\n\n[1] 58421\n\n\n\n\n\n\ntweets |&gt;\n  nrow()\n\n[1] 58421\n\n\n\n\n\n\ntweets |&gt;\n  nrow() |&gt;\n  sqrt()\n\n[1] 241.7044\n\n\n\n\n\n\n\n\n\n\nAbbildung¬†9.1: Die Pipe leitet das Ergebnis des ersten Befehls an den zweiten Befehl weiter.\n\n\n\n\n\n\n\n\nListing¬†9.1: Am Anfang steht immer ein Tibble, der durch die Pipe weitergereicht wird.\n\ntweets |&gt;\n  select(screen_name, favorite_count, retweet_count) |&gt;\n  glimpse()\n\n\n\n\nRows: 58,421\nColumns: 3\n$ screen_name    &lt;chr&gt; \"cem_oezdemir\", \"W_Schmidt_\", \"lisapaus\", \"lisapaus\", \"‚Ä¶\n$ favorite_count &lt;dbl&gt; 0, 0, 3, 11, 25, 93, 154, 448, 0, 1, 2, 2, 58, 103, 266‚Ä¶\n$ retweet_count  &lt;dbl&gt; 23, 10659, 1, 1, 6, 9, 15, 56, 29, 1, 1, 1, 10, 13, 26,‚Ä¶\n\n\n\n\n\n\n\n\nOhne Pipe\nMit Pipe\n\n\nf(g(h(x)))\nx |&gt; h() |&gt; g() |&gt; f()",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html#warum-die-pipe-euren-code-besser-macht",
    "href": "r-basics/pipe.html#warum-die-pipe-euren-code-besser-macht",
    "title": "9¬† Pipe-Operator",
    "section": "\n9.2 Warum die Pipe euren Code besser macht",
    "text": "9.2 Warum die Pipe euren Code besser macht\nDie Pipe hilft euch vor allem bei drei Dingen:\n\n\n\nLesbarkeit: Ihr k√∂nnt den Code von oben nach unten lesen.\n\nWartbarkeit: Ihr k√∂nnt einzelne Schritte leicht austauschen.\n\nStruktur: Jeder Schritt steht in einer eigenen Zeile.\n\n\nDas merkt ihr sp√§testens dann, wenn eine Transformation etwas l√§nger wird. Ohne Pipe wird daraus schnell ein Klammermonster:\n\n\n\n\nListing¬†9.2: Ohne die Pipe werden komplexe Transformationen schnell un√ºbersichtlich.\n\nhead(\n  arrange(\n    select(\n      filter(\n        mutate(\n          filter(tweets, !is_retweet),\n          is_top_tweet = retweet_count &gt;= quantile(retweet_count, 0.99)\n        ),\n        is_top_tweet\n      ),\n      retweet_count, screen_name, text\n    ),\n    -retweet_count\n  ),\n  5\n)\n\n\n\n\n# A tibble: 5 √ó 3\n  retweet_count screen_name     text                                            \n          &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;                                           \n1         12652 Bundeskanzler   Der russische √úberfall markiert eine Zeitenwend‚Ä¶\n2          8032 Bundeskanzler   The Russian invasion marks a turning point. It ‚Ä¶\n3          7152 ABaerbockArchiv Klimakrise ist jetzt. H√∂ren wir auf, nur zu red‚Ä¶\n4          5407 ABaerbock       #MohammadMehdiKarami &amp; #MohammadHosseini - ‚Ä¶\n5          5363 Karl_Lauterbach Ich m√∂chte mich bei allen bedanken, die mich al‚Ä¶\n\n\n\nBeim ersten Blick wirkt das wie ein R√§tsel. Der Code funktioniert, aber um zu verstehen, was passiert, m√ºsst ihr von innen nach au√üen lesen. Die eigentliche Schrittfolge ist:\nfilter (6) ‚Üí mutate (5) ‚Üí filter (4) ‚Üí select (3) ‚Üí arrange (2) ‚Üí head (1)\nMit Pipe schreibt ihr genau diese Reihenfolge direkt so auf, wie ihr sie gedanklich sowieso abarbeitet:\n\n\n\n\nListing¬†9.3: Die Pipe gibt eine klare Struktur, macht den Code lesbar und erlaubt schnelle √Ñnderungen.\n\ntweets |&gt;\n  filter(!is_retweet) |&gt;\n  mutate(is_top_tweet = retweet_count &gt;= quantile(retweet_count, 0.99)) |&gt;\n  filter(is_top_tweet) |&gt;\n  select(retweet_count, screen_name, text) |&gt;\n  arrange(-retweet_count) |&gt;\n  head(5)\n\n\n\n\n# A tibble: 5 √ó 3\n  retweet_count screen_name     text                                            \n          &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;                                           \n1         12652 Bundeskanzler   Der russische √úberfall markiert eine Zeitenwend‚Ä¶\n2          8032 Bundeskanzler   The Russian invasion marks a turning point. It ‚Ä¶\n3          7152 ABaerbockArchiv Klimakrise ist jetzt. H√∂ren wir auf, nur zu red‚Ä¶\n4          5407 ABaerbock       #MohammadMehdiKarami &amp; #MohammadHosseini - ‚Ä¶\n5          5363 Karl_Lauterbach Ich m√∂chte mich bei allen bedanken, die mich al‚Ä¶\n\n\n\nDas Ergebnis ist identisch, aber ihr k√∂nnt jetzt jeden Schritt einzeln lesen. Au√üerdem k√∂nnt ihr sehr schnell ausprobieren, welchen Effekt ein Schritt hat. Kommentiert ihn daf√ºr einfach tempor√§r aus:\n\n\ntweets |&gt;\n  # filter(!is_retweet) |&gt;\n  mutate(is_top_tweet = retweet_count &gt;= quantile(retweet_count, 0.99)) |&gt;\n  filter(is_top_tweet) |&gt;\n  select(retweet_count, screen_name, text) |&gt;\n  arrange(-retweet_count) |&gt;\n  head(5)\n\n# A tibble: 5 √ó 3\n  retweet_count screen_name     text                                            \n          &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;                                           \n1        434571 cem_oezdemir    RT @Schwarzenegger: I love the Russian people. ‚Ä¶\n2        276452 klara_geywitz   RT @Twitter: Twitter is built by immigrants of ‚Ä¶\n3        271059 SteffiLemke     RT @KamalaHarris: While I may be the first woma‚Ä¶\n4        188454 ABaerbockArchiv RT @verygooster: every woman in this pic tho ht‚Ä¶\n5        169437 W_Schmidt_      RT @MarcusRashford: https://t.co/bs9lksGM4q     \n\n\n\nWenn ihr Retweets nicht herausfiltert, landet ein geteilter Tweet von Cem √ñzdemir auf Platz 1. Genau solche schnellen Checks sind in der explorativen Datenanalyse Gold wert.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html#sonderf√§lle-wenn-es-nicht-das-erste-argument-ist",
    "href": "r-basics/pipe.html#sonderf√§lle-wenn-es-nicht-das-erste-argument-ist",
    "title": "9¬† Pipe-Operator",
    "section": "\n9.3 Sonderf√§lle: wenn es nicht das erste Argument ist",
    "text": "9.3 Sonderf√§lle: wenn es nicht das erste Argument ist\nIm Tidyverse klappt die Pipe fast immer reibungslos, weil die Funktionen so gestaltet sind, dass der Datensatz als erstes Argument kommt. Manchmal ist das aber anders, vor allem bei Base-R-Funktionen.\nNehmen wir an, ihr wollt einen Text aus einem Online-Fragebogen bereinigen. Da entstehen schnell doppelte Leerzeichen, die euch sp√§ter beim Auswerten nerven k√∂nnen.\n\n\ntext &lt;- \"Jemand  hat unsaubere Werte   eingegeben. \"\n\ntext |&gt;\n  trimws() |&gt;\n  tolower() |&gt;\n  (\\(x) gsub(\"[[:punct:]]+\", \"\", x))() |&gt;\n  (\\(x) gsub(\"[[:space:]]+\", \" \", x))()\n\n[1] \"jemand hat unsaubere werte eingegeben\"\n\n\n\ngsub() (global substitute) ersetzt alle Vorkommnisse eines gesuchten Teilstrings durch einen anderen String. Im Beispiel entfernt die erste Ersetzung Satzzeichen. Die zweite fasst mehrere Leerzeichen zu einem einzelnen zusammen.\nDer Haken ist: Bei gsub() ist der Text, in dem ersetzt werden soll, das dritte Argument. Die Pipe kann ihn also nicht automatisch als erstes Argument einsetzen. Die L√∂sung ist eine anonyme Funktion \\(x) ..., in der ihr selbst festlegt, wo x eingesetzt wird.\nWenn ihr solche Dinge h√§ufiger macht, lohnt sich oft der Griff zu einer Tidyverse-Variante. Das Paket stringr bietet daf√ºr Funktionen, bei denen der zu bearbeitende Text als erstes Argument kommt:\n\n\ntext |&gt;\n  str_trim() |&gt;\n  str_to_lower() |&gt;\n  str_remove_all(\"[[:punct:]]+\") |&gt;\n  str_replace_all(\"[[:space:]]+\", \" \")\n\n[1] \"jemand hat unsaubere werte eingegeben\"\n\n\n\nMerkt euch: Wenn es eine passende Tidyverse-Funktion gibt, ist das Piping meistens am angenehmsten. Wenn nicht, k√∂nnt ihr mit anonymen Funktionen trotzdem sauber weiter pipen.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html#kurz-zusammengefasst",
    "href": "r-basics/pipe.html#kurz-zusammengefasst",
    "title": "9¬† Pipe-Operator",
    "section": "\n9.4 Kurz zusammengefasst",
    "text": "9.4 Kurz zusammengefasst\n\n\nDie Pipe |&gt; reicht das Ergebnis links an den n√§chsten Schritt rechts weiter.\nStandardm√§√üig wird der linke Wert als erstes Argument eingesetzt.\nIn l√§ngeren Transformationen bringt die Pipe Lesbarkeit und macht Experimente leicht.\nWenn eine Funktion den Wert nicht als erstes Argument erwartet, helfen anonyme Funktionen oder Tidyverse-Alternativen.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "appendix/appendix-a-scraping.html",
    "href": "appendix/appendix-a-scraping.html",
    "title": "Anhang A: Scraping",
    "section": "",
    "text": "In diesem Anhang findest du eine detaillierte Beschreibung der Python-Skripte, die f√ºr die Erstellung des Datensatzes aus Tagesschau-Beitr√§ge verwendet wurden. Diese Skripte wurden entwickelt, um die Nachrichtenbeitr√§ge von Tagesschau.de zu sammeln und in einem strukturierten Format zu speichern.",
    "crumbs": [
      "Anhang A: Scraping"
    ]
  },
  {
    "objectID": "appendix/appendix-b-supplemental.html",
    "href": "appendix/appendix-b-supplemental.html",
    "title": "Anhang A: Material",
    "section": "",
    "text": "Slides",
    "crumbs": [
      "Anhang A: Material"
    ]
  },
  {
    "objectID": "appendix/appendix-b-supplemental.html#slides",
    "href": "appendix/appendix-b-supplemental.html#slides",
    "title": "Anhang A: Material",
    "section": "",
    "text": "Projekt 1: Umfragen\n\nUmfragedaten\n\n\n\nGrundlagen\n\nDer Pipe-Operator",
    "crumbs": [
      "Anhang A: Material"
    ]
  },
  {
    "objectID": "appendix/appendix-b-supplemental.html#online",
    "href": "appendix/appendix-b-supplemental.html#online",
    "title": "Anhang A: Material",
    "section": "Online",
    "text": "Online\n\nPosit Cheatsheets",
    "crumbs": [
      "Anhang A: Material"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Quellen",
    "section": "",
    "text": "Huntington-Klein, Nick. 2026. The Effect: An Introduction to\nResearch Design and Causality. Second edition. A\nChapman & Hall Book. CRC\nPress.\n\n\nWickham, Hadley, Mine √áetinkaya-Rundel, and Garrett Grolemund. 2023.\nR for Data Science: Import, Tidy, Transform, Visualize, and Model\nData. 2nd edition. O‚ÄôReilly Media, Inc.",
    "crumbs": [
      "Quellen"
    ]
  }
]