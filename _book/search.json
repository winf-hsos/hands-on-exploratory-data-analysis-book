[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Exploratory Data Analytics",
    "section": "",
    "text": "Vorwort\nDieses Buch führt in die Werkzeuge der explorativen Datenanalyse ein. Konkretes Werzeug, mit dem wir unsere Analysen erstellen, ist R in Kombination mit dem Tidyverse. Für manche Aufgaben im Buch verwenden wir auch Python, insbesondere für die Anwendung von Werkzeugen aus dem Bereich des maschinellen Lernens.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html",
    "href": "project-1-survey/survey-data.html",
    "title": "1  Umfragedaten",
    "section": "",
    "text": "1.1 Daten laden mit R\nIn diesem Projekt geht es um die Analyse eines Umfragedatensatzes. Umfragen sind ein geeignetes Mittel für unterschiedliche Forschungsfragen und kommen in der Praxis häufig zum Einsatz, um etwas über Präferenzen von Menschen herauszufinden. Umfrageergebnisse analysieren zu können stellt deshalb eine wichtige Kompetenz dar. Die Werkzeuge, die wir dafür kennenlernen, lassen sich ohne Weiteres auf andere, anders geartete Daten, übertragen.\nIn jedem Projekt steht am Anfang das Laden der Daten. In diesem Buch gehen wir davon aus, dass ein Datensatz vorliegt, der bereits erhoben wurde. Die Datenerhebung ist nicht direkt Bestandteil dieses Buches, es geht primär um die Datenanalyse.\nDie Umfrageergebnisse wurden mit der Software Limesurvey erhoben und als CSV-Datei exportiert. Wenn ihr das GitHub-Repository für dieses Buch auf euren Rechner heruntergeladen habt, dann liegen die Daten im Ordner /data und können so geladen werden:\nlibrary(tidyverse)\nsurvey &lt;- read_csv(\"data/mds12_schoko_milch.csv\")\nNach Ausführung des Codeblocks stehen die Daten auf dem Objekt mit dem Namen survey als Tibble bereit. Es ist eine gute Idee, für Objekte, die wir häufig verwenden, möglichst kurze Namen zu vergeben. Gleichzeitig sollten Namen sprechend sein, damit man anhand des Namens schnell erkennt, worum es sich handelt. Beim Objektnamen survey wurde beides berücksichtigt.\nZum Laden der Daten gehört auch eine Prüfung, ob es alles geklappt hat. Insbesodere zu wissen, ob alle Beobachtungen und alle Variablen geladen wurden, ist essenziell, um mit den Daten weiterzuarbeiten. Beovr wir uns damit beschäftigen schauen wir uns an, was man abseits von den Möglichkeiten, mit R etwas über die Daten zu erfahren, sonst noch wissen sollte.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#daten-laden-mit-r",
    "href": "project-1-survey/survey-data.html#daten-laden-mit-r",
    "title": "1  Umfragedaten",
    "section": "",
    "text": "WarnungAchtet auf den Unterstrich\n\n\n\nBitte achtet auf die Verwendung der richtigen Funktion read_csv. Es gibt in R auch eine Funktion mit dem Namen read.csv, die sehr ähnlich ist, aber keinen Tibble erzeugt. Wir verwenden in diesem Buch durchgehend das Tidyverse und Tibbles.\n\n\n\n\n\n\n\n\n\n\nHinweisDaten laden\n\n\n\nAn dieser Stelle gehen wir nicht tiefer auf das Laden von Daten aus verschiedenen Formaten ein. Einen detaillierten Einblick findet ihr in Kapitel 7.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#metainformationen-eines-datensatzes",
    "href": "project-1-survey/survey-data.html#metainformationen-eines-datensatzes",
    "title": "1  Umfragedaten",
    "section": "1.2 Metainformationen eines Datensatzes",
    "text": "1.2 Metainformationen eines Datensatzes\nDer verwendete Datensatz wurde am Fachgebiet Agrarökonomie der Hochschule Osnabrück unter Leitung von Prof. Dr. Ulrich Enneking im Jahr 2025 erhoben. In einer umfangreichen, mehrteiligen Online-Umfrage wurden deutschlandweit Menschen zu Einstellungen und Kaufverhalten bei Lebensmitteln befragt. An der Umfrage haben 2.811 Personen teilgenommen.\nDer vorherige Absatz enthält wichtige Informationen über den vorliegenden Datensatz. Wir nennen diese Art von Information auch Metainformation (meta = über) oder Kontexinformation. Schauen wir mal drauf, welche Informationen in dem Absatz stecken. Tabelle 1.1 fasst das zusammen:\n\n\n\nTabelle 1.1: Metainformationen zum Umfragedatensatz\n\n\n\n\n\n\n\n\n\nW‑Frage\nAntwort\n\n\n\n\nWer hat die Daten erhoben?\nProfessor Enneking\n\n\nWie wurden die Daten erhoben?\nOnline-Umfrage\n\n\nWann wurden die Daten erhoben?\n2025\n\n\nWo wurden die Daten erhoben?\nonline\n\n\nWer wurde befragt?\n2.811 Menschen deutschlandweit\n\n\nWas wurde erhoben?\nEinstellungen und Kaufverhalten bei Lebensmitteln\n\n\n\n\n\n\nIhr seht es handelt sich um eine Reihe von W-Fragen, auf die sich die Kontextinformationen beziehen. Warum sind diese Informationen überhaupt wichtig? Dazu werden wir später noch mehr erfahren, aber hier verdeutlichen wir es uns anhand einer Frage, auf die wir in der obigen Tabelle 1.1 noch keine Antwort finden, die aber extrem wichtig ist: Was repräsentiert eine Zeile in den Daten?\nWas sehen wir eigentlich, wenn wir eine Zeile betrachten? Auf diese Frage benötigen wir eine Antwort, bevor wir mit der Datenanalyse beginnen. Zwar können wir oft durch scharfes Hinsehen diese Frage selbst beantworten, aber der Schein kann trügen. Wenn wir nicht selbst Urheber der Daten sind, dann sollten wir diese Information aus sicherer Quelle erfragen. Im vorliegenden Beispiel habe ich das getan und habe meinen geschätzen Kollegn gefragt. Ich weiß nun, dass eine Zeile im Datensatz den Antworten einer Person auf die Online-Umfrage entspricht. Allgemein sprechen wir in der empirischen Forschung von Beobachtungen. Eine Beobachtung in unserem Fall ist also eine ausgefüllte Umfrage, die uns in einer Zeile vorliegt. Systematisch zu beobachten und diese Beobachtungen für die Beantwortung von Forschungsfragen zu analysieren ist der Kern der emprischen Forschung.\n\nEmpirical research is any research that uses structured observations from the real world to attempt to answer questions. (Huntington-Klein 2026)\n\nWenn wir wissen, was eine Zeile bedeutet, dann können wir auch herausfinden, wie viele Personen teilgenommen haben. Oder allgemein, wie viele Beobachtungen wir vorliegen haben. Wie? Mit der Funktion count, die einfach die Anzahl der Zeilen (oder Beobachtungen) im Datensatz zählt. Dazu muss man wissen, dass jede Zeile einer Person entspricht, die an der Umfrage teilgenommen hat.\n\nsurvey |&gt;\n1  count()\n\n\n1\n\nDer Befehl count zählt die Beobachtungen (oder Zeilen) in einem Datensatz.\n\n\n\n\n# A tibble: 1 × 1\n      n\n  &lt;int&gt;\n1  2811\n\n\nEs gibt weitere Möglichkeiten, die Anzahl der Beobachtungen zu ermitteln. Eine ganz einfache ist es, einfach den Namen des Objekts einzugeben, das den Datensatz in R repräsentiert:\n\n\n\n\nListing 1.1: Wir können einfach den Namen des Tibbles aufrufen, um an wichtige Informationen zu kommen.\n\n\nsurvey\n\n\n\n\n# A tibble: 2,811 × 813\n   q001hheinkauf q002geburt q003land q004geschlecht q005os v041nofleisch\n           &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1             2       1970        1              1      0             0\n 2             1       1990        7              1      0             0\n 3             2       1963        6              1      0             0\n 4             2       1989       13              2      0             1\n 5             2       1965        4              1      0             1\n 6             2       1957        2              1      0             0\n 7             2       1960       14              2      0             1\n 8             2       1984       13              1      0             0\n 9             2       1974        1              2      0             0\n10             2       1954       13              2      0             0\n# ℹ 2,801 more rows\n# ℹ 807 more variables: v041nofleisch_other &lt;chr&gt;, v041diaet_0nodiaet &lt;dbl&gt;,\n#   v041diaet_1lowcarb &lt;dbl&gt;, v041diaet_2laktose &lt;dbl&gt;,\n#   v041diaet_3gluten &lt;dbl&gt;, v041diaet_4paleo &lt;dbl&gt;, v041diaet_5ketogen &lt;dbl&gt;,\n#   v041diaet_6rohkost &lt;dbl&gt;, v041diaet_7makro &lt;dbl&gt;, v041diaet_8trenn &lt;dbl&gt;,\n#   v041diaet_9frutarisch &lt;dbl&gt;, v041diaet_10fleisch &lt;dbl&gt;,\n#   v041diaet_11mediterran &lt;dbl&gt;, v041diaet_12histaminarm &lt;dbl&gt;, …\n\n\nDurch die Verwendung des Tidyverse und den dazugehörigen Tibbles bekommen wir diese kompakte und informative Ausgabe. Die erste Zeile der Ausgabe enthält die Dimensionierung der Daten in der Form Zeilen x Spalten. Wir bekommen also nicht nur die Information, wie viele Beobachtungen (2.811), sodnern auch, wie viele Spalten (813). Dazu gibt uns ein Tibble gleich noch eine Vorschau seiner ersten zehn Zeilen aus, die so viele Variablen beinhaltet, wie auf die aktuelle Größe der Konsole passen. Die restlichen Variablennamen werden darunter aufgelistet, zumindest ein Teil davon. Ein Tibble achtet darauf, die Konsole nicht komplett mit Text zu fluten und schneidet daher irgendwann ab.\nEs gibt dedizierte Werkzeuge, um mehr über die Variablen herauszufinden. Die schauen wir uns jetzt an.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#variablen-spalten",
    "href": "project-1-survey/survey-data.html#variablen-spalten",
    "title": "1  Umfragedaten",
    "section": "1.3 Variablen (Spalten)",
    "text": "1.3 Variablen (Spalten)\n\nWas ist eine Variable?\n\nA variable, in the context of empirical research, is a bunch of observations of the same measurement. (Huntington-Klein 2026)\n\nNeben der Frage, was eine Zeile darstellt, sollten wir auch wissen, was jede Variable genau misst. Während wir Beobachtungen typischerweise horizontal, also in Zeilen, darstellen, sind Variablen das, was wir vertikal, also in Spalten, darstellen.\n\n\n\n\n\n\nAbbildung 1.1: Beobachtungen repräsentieren wir als Zeilen, Variablen als Spalten.\n\n\n\nAuch die Informationen über die gemessenen Variablen gehören zu den Metainformationen eines Datensatzes. Und im besten Fall gibt es ein so genanntes Data Dictionary, eine Art Wörterbuch, in dem jede Variable aufgeführt und inhaltlich erläutert ist. Leider ist das nicht immer der Fall, in diesem Beispiel jedoch schon, wie wir später sehen werden.\nUnabhängig davon, ob es ein Data Dictionary gibt, wollen wir uns im Folgenden anschauen, wie wir mit R an wichtige Informationen zu den Variablen kommen. Folgende Fragen solltet ihr euch zu Beginn stellen:\n\nWie viele Variablen gibt es?\nWelche Arten von Variablen gibt es?\nWelchen Wertebereiche hat eine Variable?\n\n\n\nWie viele Variablen?\nWie viele Variablen der Datensatz hat wissen wir bereits aus Listing 1.1. Die Anzahl der Variablen ist im vorliegenden Datensatz mit 813 verhältnismäßig hoch. Das ist typisch für Umfragen, insbesondere wenn viele Fragen enthalten sind. Denn jede Antwortoption und deren Ausprägung wird im Ergebnis mit einer eigenen Variable abgebildet, da kommt schnell was zusammen.\nÜbrigens können wir mit folgendem Befehl die Anzahl Variablen (oder Spalten) ganz konkret als Wert auslesen, und nicht nur auf der Konsole ausgeben:\n\nsurvey |&gt;\n  ncol()\n\n[1] 813\n\n\nDiesen Wert können wir auf einem neuen Objekt speichern und später in unserem R-Skript wieder verwenden, was häufig nützlich ist:\n\nvariable_count &lt;- ncol(survey)\n1print(str_glue(\"Es haben {variable_count} Menschen teilgenommen.\"))\n\n\n1\n\nMit str_glue können wir Zeichenketten mit Platzhaltern versehen, die zur Ausführung mit den Werten ersetzt werden.\n\n\n\n\nEs haben 813 Menschen teilgenommen.\n\n\n\n\nWelche Arten von Variablen gibt es?\nSchauen wir uns fürs erste nur die ersten 10 Variablen im Datensatz genauer an:\n\nsurvey |&gt;\n1    select(1:10) |&gt;\n2    glimpse()\n\n\n1\n\nMit select können wir Variablen auswählen. Die Notation 1:10 bedeutet so viel wie: Variablen an Stelle 1 bis 10.\n\n2\n\nMit glimpse bekommen wir schnell eine Übersicht der Namen, Datentypen und ersten Werte der Variablen.\n\n\n\n\nRows: 2,811\nColumns: 10\n$ q001hheinkauf       &lt;dbl&gt; 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1,…\n$ q002geburt          &lt;dbl&gt; 1970, 1990, 1963, 1989, 1965, 1957, 1960, 1984, 19…\n$ q003land            &lt;dbl&gt; 1, 7, 6, 13, 4, 2, 14, 13, 1, 13, 5, 14, 9, 4, 3, …\n$ q004geschlecht      &lt;dbl&gt; 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1,…\n$ q005os              &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ v041nofleisch       &lt;dbl&gt; 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,…\n$ v041nofleisch_other &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ v041diaet_0nodiaet  &lt;dbl&gt; 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1,…\n$ v041diaet_1lowcarb  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ v041diaet_2laktose  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,…\n\n\nIm Codeblock oben lernen wir mit select und glimpse gleich 2 zwei wichtige Funktionen kennen. Beide werden wir in diesem Buch noch sehr häufig verwenden. Mit select können wir aus den vielen Spalten genau die auswählen, an denen wir momentan interessiert sind. Das kann etwa für die Auswertung einer bestimmten Frage sinnvoll sein, bei der wir nur die Variablen benötigen, die sich auf die betroffene Frage beziehen. Die Notation 1:10 in den Klammern der select-Funktion bedeutet übersetzt wähle die Variablen 1 bis 10 aus. Dazu muss man wissen, dass Variablen in einem Datensatz eine feste Reihenfolge haben. Wir bekommen damit also die ersten 10 Variablen im Datensatz.\nMit der Flexibilität einer Programmiersprache wie R können wir jede beliebige Menge an Spalten auswählen. Zum Beispiel auch die letzten 10:\n\nsurvey |&gt;\n  select(tail(everything(), 10))\n\n# A tibble: 2,811 × 10\n   M070handeldiff3_1hochwertig M070handeldiff3_2regio M070handeldiff3_3preis\n                         &lt;dbl&gt;                  &lt;dbl&gt;                  &lt;dbl&gt;\n 1                          NA                     NA                     NA\n 2                          -1                      1                      2\n 3                          NA                     NA                     NA\n 4                          NA                     NA                     NA\n 5                          NA                     NA                     NA\n 6                          NA                     NA                     NA\n 7                          NA                     NA                     NA\n 8                          NA                     NA                     NA\n 9                           2                      2                     -2\n10                          NA                     NA                     NA\n# ℹ 2,801 more rows\n# ℹ 7 more variables: M070handeldiff3_4tierwohl &lt;dbl&gt;,\n#   M070handeldiff3_5vielfalt &lt;dbl&gt;, M070handeldiff3_6vetrauen &lt;dbl&gt;,\n#   M070handeldiff3_7nachhaltig &lt;dbl&gt;, M070handeldiff3_8gesund &lt;dbl&gt;,\n#   M070handeldiff3_9kauf &lt;dbl&gt;, M070handeldiff3_10trends &lt;dbl&gt;\n\n\nMit tail ermitteln wir die letzen n Elemente einer Liste. everything gibt uns die Liste aller Spalten zurück, wenn es innerhalb der select-Funktion aufgerufen wird. Somit kann man den Befehl übersetzen mit Gib mir die letzten 10 Elemente (tail) aus der Liste aller Spalten (everything). Wir werden später noch Werkzeuge im Detail lernen, wie wir geanu die Spalten finden und auswählen, die wir brauchen. Das ist gerade bei Umfragen mit vielen Spalten extrem nützlich.\n\n\n\n\n\n\nHinweisVariablen haben eine feste Position\n\n\n\nVariablen (oder Spalten) haben eine feste Reihenfolge und Position in einem Datensatz. Wir können also jede Spalte statt über ihren Namen auch über ihre Position ansprechen.\n\n\nDie Funktion glimpse wird unmittelbar nach dem select aufgerufen und bekommt das Ergebnis übergeben. Dafür sorgt das etwas merkwürdig aussehende Symbol |&gt;, das wir den Pipe-Operator oder einfach nur die Pipe nennen. Es sorgt dafür, dass das Ergebnis des ersten Befehls (vor der Pipe) an den nächsten Befehl (nach der Pipe) übergeben wird. Auf diese Weise können wir Ketten von Befehlen aufbauen, in der jeder Befehl sein eigenes Ergebnis an den nächsten übergibt. Eine dedizierte Einfürhung in den Pipe-Operator findet ihr in Kapitel 8.\n\n\nWelchen Wertebereich hat eine Variable?\nZurück zur Ausgabe vom glimpse oben. Was genau bedeutet das, was wir auf der Konsole sehen? Die ersten beiden Zeilen geben Auskunft über die Anzahl an Zeilen und Spalten im Datensatz. Warum sind es hier nur 10 Zeilen, statt der 813 Spalten, wie oben geschrieben? Weil wir glimpse nicht mehr für den ursprünglichen Datensatz aufrufen, sondern für den, der als Ergebnis des vorgelagerten select(1:10) entsteht. Und der hat nur noch 10 Spalten, was wir aber genau so wollten.\nDarunter folgen Zeilenweise die Spalten mit den Informationen Spaltenname, Datentyp und Auflistung der ersten Werte für jede Spalte. Was genau die Datentypen wie &lt;dbl&gt; oder &lt;chr&gt; bedeuten lernen wir später noch. Nach dem Datentyp sehen wir eine komma-getrennte Liste der ersten Werte, soweit sie auf die Konsole passen. Für die erste Spalte im Datensatz, q001hheinkauf, sind die ersten Werte also 2, 1, 2, 2 usw. Was das genau bedeutet können wir nicht wissen, sondern müssen es nachschlagen. Dazu gibt es üblicherweise zu einem Fragebogen ein entsprechendes Codebuch, in dem die Antwortkodierungen in sprechende Werte übersetzt werden. Das ist meistens Teil des Data Dictionary.\nBei der ersten Frage, zu der die Spalte q001hheinkauf gehört, geht es um die Frage, ob die teilnehmende Person für den Lebensmitteleinkauf hauptverantwortlich ist oder ob die Aufgabe mit einer anderen Person geteilt wird. Der Wert 1 steht hier kurz gesagt für “allein verantwortlich” und 2 für “geteilte Verantwortung”. Aber sind das die einzigen Werte, die die Variable annimmt? Das können wir aus der Ausgabe der glimpse-Funktion nicht ableiten.\nWir könnten die Spalte einfach auswählen und uns das Ergebnis ausgeben lassen:\n\nsurvey |&gt;\n  select(q001hheinkauf)\n\n# A tibble: 2,811 × 1\n   q001hheinkauf\n           &lt;dbl&gt;\n 1             2\n 2             1\n 3             2\n 4             2\n 5             2\n 6             2\n 7             2\n 8             2\n 9             2\n10             2\n# ℹ 2,801 more rows\n\n\nDas Ergebnis ist ein Tibble, der auf der Konsole standardmäßig seine ersten 10 Werte ausgibt. Dieses Verhalten können wir ändern und den Tibble um mehr Werte bitten:\n\nsurvey |&gt;\n  select(q001hheinkauf) |&gt;\n  print(n = 20)\n\n# A tibble: 2,811 × 1\n   q001hheinkauf\n           &lt;dbl&gt;\n 1             2\n 2             1\n 3             2\n 4             2\n 5             2\n 6             2\n 7             2\n 8             2\n 9             2\n10             2\n11             2\n12             1\n13             2\n14             1\n15             2\n16             2\n17             1\n18             1\n19             2\n20             1\n# ℹ 2,791 more rows\n\n\nDamit sind des schon doppelt so viele Beobachtungen für die Variable q001hheinkauf, und immernoch sehen wir nur die Ausprägungen 1 und 2. Um wirklich sicher zu wissen, welche Werteausprägungen existieren, geben wir die eindeutigen Werte aus:\n\nsurvey |&gt;\n  distinct(q001hheinkauf)\n\n# A tibble: 2 × 1\n  q001hheinkauf\n          &lt;dbl&gt;\n1             2\n2             1\n\n\nUnd siehe da: Es ist tatsächlich so, dass nur diese beiden Werte vorkommen. Wie oft? Auch das bekommen wir schnell raus:\n\nsurvey |&gt;\n  count(q001hheinkauf)\n\n# A tibble: 2 × 2\n  q001hheinkauf     n\n          &lt;dbl&gt; &lt;int&gt;\n1             1   919\n2             2  1892\n\n\nDie Funktion count kennen wir bereits von oben. Wenn wir ihr eine Variable übergeben, dann ermittelt sie, wie häufig jede Ausprägung der Variable in den Daten vorkommt. Technisch gruppiert sie die Daten nach der übergebenen Variable und zählt die Beobachtungen für jede Gruppe.\n\n\n\n\n\n\nHinweisAggregieren von Daten\n\n\n\nDie Funktion count zählt zu den Aggregationsfunktionen. Eine dedizierte Einführung, wie man mit R und dem dplyr-Paket Daten zusammenfasst, findet ihr in Kapitel 10",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#beobachtungen-zeilen",
    "href": "project-1-survey/survey-data.html#beobachtungen-zeilen",
    "title": "1  Umfragedaten",
    "section": "1.4 Beobachtungen (Zeilen)",
    "text": "1.4 Beobachtungen (Zeilen)\nWas für Variablen gilt, gilt auch für Zeilen. Jede hat eine feste Position. Bei den Zeilen nennen wir das auch die row number (Zeilennummer), und es gibt eine Funktion, um diese zu ermitteln:\n\nsurvey |&gt;\n  select(1:10) |&gt;\n1  filter(row_number() &lt;= 10)\n\n\n1\n\nMit row_number bekommen wir die Position (oder Nummer) für eine Zeile.\n\n\n\n\n# A tibble: 10 × 10\n   q001hheinkauf q002geburt q003land q004geschlecht q005os v041nofleisch\n           &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1             2       1970        1              1      0             0\n 2             1       1990        7              1      0             0\n 3             2       1963        6              1      0             0\n 4             2       1989       13              2      0             1\n 5             2       1965        4              1      0             1\n 6             2       1957        2              1      0             0\n 7             2       1960       14              2      0             1\n 8             2       1984       13              1      0             0\n 9             2       1974        1              2      0             0\n10             2       1954       13              2      0             0\n# ℹ 4 more variables: v041nofleisch_other &lt;chr&gt;, v041diaet_0nodiaet &lt;dbl&gt;,\n#   v041diaet_1lowcarb &lt;dbl&gt;, v041diaet_2laktose &lt;dbl&gt;\n\n\nDie Funktion filter verwenden wir, um die Beobachtungen nach bestimmten Kriterien einzugrenzen. Zum Beispiel um nur weibliche Personen zu betrachten. Wir können mit der row_number-Funktion die Beobachtungen auch nach ihrer Position im Datensatz eingrenzen. Das obige Beispiel behält nur jene Zeilen im Ergebnis, deren Position kleiner oder gleich (&lt;=) 10 ist.\nStatt kleiner-gleich können wir auch andere Operatoren verwenden:\n\nsurvey |&gt;\n  filter(row_number() == 42) |&gt;\n  select(q004geschlecht)\n\n# A tibble: 1 × 1\n  q004geschlecht\n           &lt;dbl&gt;\n1              2\n\n\n\n\n\n\nHuntington-Klein, Nick. 2026. The effect: an introduction to research design and causality. Second edition. A Chapman & Hall Book. Boca Raton London New York: CRC Press.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html",
    "href": "project-1-survey/types-of-variables.html",
    "title": "2  Arten von Variablen",
    "section": "",
    "text": "2.1 Ein Schema zur Orientierung\nWie haben in Kapitel 1 schon Beispiele für eine Arten von Variablen gesehen. In Umfragen begegnen wir häufig nominalskalierten Variablen, seltener sind numerische oder gar qualitative Variablen. Aber was genau unterscheidet diese Variablentypen?\nUm das besser zu verstehen wollen wir katgeoriale Variablen gegenüber anderen Arten von Variablen abgrenzen. Laut Huntington-Klein (2026) unterscheiden wir in der empirischen Forschung zwischen den folgenden Typen von Variablen:\nIch finde diese Einteilung trifft es sehr gut und verwende sie daher in diesem Buch weiter. Man kann noch eine Ebene darüber einziehen und kontinuierliche Variablen und Zählvariablen als numerische Variablen zusammenfassen. Parallel dazu sind ordinale Variablen genau genommen eine Form von kategorialen Variablen und eine weitere wären die nominalskalierten Variablen.\nSchauen wir uns für jeden Typ Beispiele an, um ihn besser zu verstehen.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#ein-schema-zur-orientierung",
    "href": "project-1-survey/types-of-variables.html#ein-schema-zur-orientierung",
    "title": "2  Arten von Variablen",
    "section": "",
    "text": "Kontinuierliche Variablen\nZählvariablen\nOrdinale Variablen\nKategoriale Variablen\nQualitative Variablen\n\n\n\n\n\n\n\n\nAbbildung 2.1: Arten von Variablen und typische verwendete Datentypen in R.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#numerische-variablen",
    "href": "project-1-survey/types-of-variables.html#numerische-variablen",
    "title": "2  Arten von Variablen",
    "section": "2.2 Numerische Variablen",
    "text": "2.2 Numerische Variablen\nBei den numerischen Variablen könnte man auch von quantitativen Variablen sprechen. Wir unterscheiden dabei solche, die prinzipiell jeden beliebigen Wert als reelle Zahl annehmen können und solche, die nur ganze, also natürliche, Zahlen annehmen können. Erstere nennen wir kontinuierlich, weil jeder Wert auf einem Kontinuum möglich ist.\n\nKontinuierliche Variablen\n\nContinuous variables are variables that could take any value (perhaps within some range). (Huntington-Klein 2026)\n\nIm vorliegenden Umfragedatensatz fragt die Frage 13 nach der Eingabe eines Preises, den die Teilnehmenden bereit wären, für einen Liter Milch vorgegebener Marken auszugeben:\n“Geben Sie für die 3 Marken bitte den Preis an, den Sie für angemessen halten und bei dem Sie zugreifen würden! Als Dezimaltrennzeichen verwenden Sie bitte das Komma.”\nSchauen wir auf ein paar Beobachtungen zu dieser Frage. Wie sehen die Antworten aus?\n\nsurvey |&gt;\n    select(u013pzahl_1weihen)\n\n# A tibble: 2,811 × 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              1.49\n 2             NA   \n 3             NA   \n 4             NA   \n 5             NA   \n 6             NA   \n 7             NA   \n 8             NA   \n 9            150   \n10             NA   \n# ℹ 2,801 more rows\n\n\nAnhand der Ausgabe sehen wir 3 Dinge:\n\nDer Datentyp der Spalte ist als &lt;dbl&gt; angegeben. Das ist typisch für kontinuierliche Varialen, denn das steht für den Datentyp double, der in der Programmierung für Dezimalzahlen (mit Nachkommastellen) verwendet wird.\nViele Werte sind mit NA angegeben, was bedeutet, dass hier kein Wert existiert. In der Auswertung der Daten stellt sich die Frage, was das im Kontext des Datensatzes bedeutet und wie wir damit umgehen.\nDie beiden einzigen Werte sind 1,49 € und 150 €. Letzteres dürfte ein Tippfehler sein und wirft auch hier die Frage auf, wie wir damit umgehen.\n\nDen zweiten Punkt in der Liste könnten wir einfach abhaken, indem wir die NA-Werte herausfiltern (auch wenn das kein Patentrezept ist). Dafür gibt es die drop_na-Funktion:\n\nsurvey |&gt;\n    select(u013pzahl_1weihen) |&gt;\n    drop_na()\n\n# A tibble: 231 × 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              1.49\n 2            150   \n 3              1.19\n 4              3   \n 5              2   \n 6              1.6 \n 7              1.09\n 8              3   \n 9              1.8 \n10              2.2 \n# ℹ 221 more rows\n\n\nDie Ausgabe enthält jetzt keine fehlenden Werte mehr und wir bekommen ein paar mehr “echte” Werte angezeigt. Wir zu erwarten gibt es fast beliebige Werte mit zwei Nachkommastellen, die als Antwort auf die Frage zulässig sind. Solche Daten sind typisch für kontinuierliche Variablen; es gibt keine feste Liste an Werten, sondern theoretisch existiert jeder Wert auf einem Kontinuum. Das kann man sich verdeutlichen, wenn man versucht, die eindeutigen Werte zu ermitteln. Dafür haben wir in Kapitel 1 die Funktion distinct kennengelernt:\n\nsurvey |&gt;\n    select(u013pzahl_1weihen) |&gt;\n    drop_na() |&gt;\n    distinct()\n\n# A tibble: 48 × 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              1.49\n 2            150   \n 3              1.19\n 4              3   \n 5              2   \n 6              1.6 \n 7              1.09\n 8              1.8 \n 9              2.2 \n10            120   \n# ℹ 38 more rows\n\n\nZwar sieht es hier so aus, als wären die eindeutigen Werte mit 48 nicht so viele, als das sie nicht auch eine feste Menge an Kategorien darstellen könnten. Allerdings ist es klar, dass theoretisch viel mehr unterschiedliche Preise hätten eingegeben werden können und dass es sich bei der Abfrage eines Preises von Natur her um eine numerische Größe handelt.\n\nAusreißer\nBei kontinuierlichen Variablen spielt häufig das Problem der Ausreißer eine Rolle. Es gibt verschiedene Gründe für Ausreißer, bei Umfragen kommt etwa ein einfacher Tippfehler als Ursache infrage. Je nach Ursprung sind unterschiedliche Maßnahmen möglich. Tippfehler sollten wir entweder korrigieren, oder, wenn wir das nicht können, herausfiltern. Veranschaulichen wir uns die Problematik kurz an einem Beispiel und berechnen den Durchschnittspreis, den die Probanden eingegeben haben:\n\nsurvey |&gt;\n    summarize(avg_price = mean(u013pzahl_1weihen))\n\n# A tibble: 1 × 1\n  avg_price\n      &lt;dbl&gt;\n1        NA\n\n\nDie mean-Funktion berechnet das arithemtische Mittel und mit summarize erzeugen wir eine neue, aggregierte Spalte. Die neue Spalte avg_price sollte also den Durchschnittspreis (als arithmetisches Mittel) über alle Probanden enthalten. Wie wir sehen, ist der Wert aber NA.\nDer Grund dafür ist einfach: R weiß nicht, wie es NA-Werte in einer Berechnung behandeln soll. Daher wird jede Berechnung, in der ein NA vorkommt, im Ergebnis sofort auch NA. Die Lösung: Die NA-Werte müssen weg:\n\nsurvey |&gt;\n1    drop_na(u013pzahl_1weihen) |&gt;\n    summarize(avg_price = mean(u013pzahl_1weihen))\n\n\n1\n\nDie drop_na-Funktion entfernt alle Zeilen mit NA-Werten. Wenn eine oder mehrere Spalten übergeben werden, dann bezieht sich die NA-Filterung nur auf diese. Sobald eine in der Liste den Wert NA aufweist, wird die Zeile entfernt.\n\n\n\n\n# A tibble: 1 × 1\n  avg_price\n      &lt;dbl&gt;\n1      4.58\n\n\nUnd schon funktioniert es! Was sagt uns der Wert? Im Durchschnitt halten die Probanden also einen Preis von 4,58 € für einen Liter Milch für gerechtfertigt. Kann das sein? Haben die alle zu viel Geld? Berechnen wir den Durchschnitt mit einer anderen Kenngröße, dem Median:\n\nsurvey |&gt;\n    drop_na(u013pzahl_1weihen) |&gt;\n    summarize(avg_price = median(u013pzahl_1weihen))\n\n# A tibble: 1 × 1\n  avg_price\n      &lt;dbl&gt;\n1      1.49\n\n\nOha! Der Median ist mit 1,49 € deutlich kleiner. Wie kommt es dazu? Die Antwort ist einfach: Der Median ist robust gegenüber Ausreißern, das arithmetische Mittel dagegen nicht. Das arithmetische Mittel ist einfach die Summe aller Werte geteilt durch die Anzahl Werte:\n\\[\n\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i\n\\]\nDer Median ist dagegen einfach der mittlere Wert der sortierten Preise; bei geradem \\(n\\) ist er der Mittelwert der beiden mittleren Werte. Und ihm ist es egal, ob am Ende der Liste ein paar riesige Werte folgen.\n\\[\n\\tilde{x} =\n\\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, & \\text{falls } n \\text{ ungerade ist},\\\\[6pt]\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & \\text{falls } n \\text{ gerade ist}.\n\\end{cases}\n\\]\nWas also tun? Da wir nicht wissen können, was die Probanden eigentlich eingeben wollten, filtern wir die unangemessen hohen Werte heraus. Schauen wir zunächst einmal, welche das überhaupt sind:\n\nsurvey |&gt;\n    select(u013pzahl_1weihen) |&gt;\n    arrange(desc(u013pzahl_1weihen))\n\n# A tibble: 2,811 × 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1               150\n 2               150\n 3               129\n 4               120\n 5               109\n 6                50\n 7                 7\n 8                 4\n 9                 4\n10                 3\n# ℹ 2,801 more rows\n\n\nWas meint ihr? Gar nicht so einfach, zu entscheiden, welche Werte ernst gemeint sind und welche auf Tippfehler schließen lassen. Pragmatisch entscheiden wir uns für die 10 € als Grenze:\n\nsurvey |&gt;\n    filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n    summarize(avg_price = mean(u013pzahl_1weihen))\n\n# A tibble: 1 × 1\n  avg_price\n      &lt;dbl&gt;\n1      1.56\n\n\nDurch das Herausfiltern der Ausreißer nähert sich das arithmetische Mittel dem Median deutlich an. Jetzt haben wir die Ausreißer nach oben, also die extrem hohen Werte, betrachtet und behandelt. Gibt es auch Ausreißer nach unten?\n\nsurvey |&gt;\n    select(u013pzahl_1weihen) |&gt;\n    arrange(u013pzahl_1weihen)\n\n# A tibble: 2,811 × 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              0   \n 2              0   \n 3              0   \n 4              0.09\n 5              0.89\n 6              0.95\n 7              0.99\n 8              0.99\n 9              0.99\n10              0.99\n# ℹ 2,801 more rows\n\n\nDie desc-Funktion hat zuvor dafür gesorgt, dass die Werte absteigend sortiert werden (descending = absteigend). Lassen wir sie weg, dann wird standardmäßig aufsteigend sortiert. Die kleinsten Werte sind jetzt oben in der Liste und wir können erkennen, dass auch hier offensichtlich unplausible Werte existieren. Ein Preis von Null Euro oder nur 9 Cent? Auch die sollten wir vielleicht herausfiltern. Biedes zusammen sieht dann so aus:\n\nsurvey |&gt;\n    filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n    filter(u013pzahl_1weihen &gt; 0.1) |&gt;\n    summarize(avg_price = mean(u013pzahl_1weihen))\n\n# A tibble: 1 × 1\n  avg_price\n      &lt;dbl&gt;\n1      1.59\n\n\nDurch den Aufbau einer Pipeline von filter-Anweisungen werden diese nacheinander angewendet. Zuerst fliegen alle Preise raus, die über 10 € liegen, danach alle, die kleiner als 10 Cent sind. Am Ende berechnen wir auf Basis der gefilterten Werte erneut das arithmetische Mittel.\n\n\n\n\n\n\nHinweisFiltern von Daten\n\n\n\nDie Funktion filter ist zentral für die Auswahl der richtigen Beobachtungen. Eine Einführung, wie man mit R und dem dplyr-Paket Daten filtert, findet ihr in Kapitel 9\n\n\nÜbrigens stellt die Visualisierung eine geeignete Methode dar, um Ausreißer schnell zu erkennen. Ein Boxplot etwa stellt Ausreißer als Punkte außerhalb der Box dar:\n\nsurvey |&gt;\n    ggplot() +\n    aes(x = u013pzahl_1weihen) +\n    geom_boxplot()\n\n\n\n\n\n\n\n\nMan erkennt hier sehr schön die handvoll Ausreißer ab der 50€-Marke. Die Box des Plots ist durch die Ausreißer nur als dicker Strich zu erkennen. Was tun? Ein einfaches Filtern ist im Fall eines Boxplots nicht zulässig, nur um den Plot besser zu sehen. Das liegt daran, dass der Boxplot verschiedene Werte berechnet und als Größen der Box darstellt. Darunter auch der Median. Filtern wir aber Werte heraus und berechnen dann den Median, dann ändert sich dadurch die Grundlage für die Berechnung, und damit auch der Plot selbst. Was also tun, damit wir dennoch eine sinnvolle Visualisierung bekommen?\nDie Anwort ist: Reinzoomem statt filtern! Reinzoomen bedeutet, wir betrachten nur den Teil der x-Achse, in dem der wichtigste Teil des Plots liegt. Versuchen wir es und legen einen Bereich zwischen 0 und 10 € fest:\n\nsurvey |&gt;\n    ggplot() +\n    aes(x = u013pzahl_1weihen) +\n    geom_boxplot() +\n    coord_cartesian(xlim = c(0, 10))\n\n\n\n\n\n\n\n\nSchon besser, die Box wird sichtbar. Allerdings ist rechts daneben noch immer viel Platz, den wir in der Visualisierung für die Darstellung der Box verwenden könnten. Wenn man sich vergegegwärtigt, dass die Begrenzungen der Box den 25% bzw. 75%-Punkt der Werte bedeuten, und er Strich in der Mitte der 50%-Punkt (Median), dann liegt die Hälfte der Werte in der Box selbst. Ein Viertel liegt jeweils links und rechts von der Box. Die sogenannten Whisker, also die Linien die aus der Box herauslaufen, stellen Werte dar, die noch 1,5-fachen Interquartilsabstand zu den Punkten \\(Q_1\\) und \\(Q_3\\) liegen:\n\\[\n\\left[\\, Q_1 - 1.5\\cdot\\mathrm{IQR},\\; Q_3 + 1.5\\cdot\\mathrm{IQR} \\,\\right]\n\\]\nWobei gilt:\n\\[\n\\mathrm{IQR} = Q_3 - Q_1\n\\]\nZoomen wir also noch ein Stück weiter hinein:\n\nsurvey |&gt;\n    ggplot() +\n    aes(x = u013pzahl_1weihen) +\n    geom_boxplot() +\n    coord_cartesian(xlim = c(0, 5))\n\n\n\n\n\n\n\n\nEine Alternative für die Darstellung der Verteilung einer kontinuierlichen Variable ist das Histogram:\n\nsurvey |&gt;\n    ggplot() +\n    aes(x = u013pzahl_1weihen) +\n    geom_histogram()\n\n\n\n\n\n\n\n\nAuch hier leiden wir erneut unter den Ausreißern. Anders als beim Boxplot können wir hier aber einfach filtern, schließlich berechnet das Histogramm lediglich die Häufigkeiten pro Klasse, die wir dadurch nicht verändern:\n\nsurvey |&gt;\n    filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n    ggplot() +\n    aes(x = u013pzahl_1weihen) +\n    geom_histogram()\n\n\n\n\n\n\n\n\nWenn wir nichts angeben, dann wählt ggplot2 für uns eine passende Klassengröße basierend auf den Daten. Diese können wir beeinflussen, vielleicht wollen wir Klassengrößen von 50 Cent betrachten:\n\nsurvey |&gt;\n    filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n    ggplot() +\n    aes(x = u013pzahl_1weihen) +\n    geom_histogram(binwidth = 0.5)\n\n\n\n\n\n\n\n\nWir kommen im Verlauf des Projekts auf unterschiedliche kontinuierliche Variablen zurück. Für jetzt merken wir uns, dass bei ihen Vorsicht mit Ausreißern geboten ist und dass wir mit Boxplots und Histogrammen ihre Verteilung schnell überblicken können.\n\n\n\nZählvariablen\n\nCount variables are those that, well, count something. Perhaps how many times something happened or how many of something there are. (Huntington-Klein 2026)\n\nKurz gesagt sind der Unterschied zwischen kontinuierlichen Variablen und Zählvariablen die Stellen nach dem Komma. Letztere haben keine. Und das ist typisch für Dinge, die einfach abzählbar sind:\n\nDie Jahre, die ein Mensch schon lebt (Alter)\nDie Häufigkeit, wie oft man im Jahr im Fitnessstudio war\nDie Anzahl Produkte, die verkauft wurden\n\nZählvariablen können sehr viele unterschiedliche Ausprägungen haben und unterscheiden sich dann oft nicht großartig von kontinuierlichen Variablen. Zumindest nicht in der Auswertung. Dennoch gibt es wichtig Unterschiede. Betrachten wir ein Beispiel aus dem Umfragedaten: Das Alter der Probanden.\nDas Alter ist keine Variable, die direkt in der Umfrage gemessen wurde. Es steckt aber indirekt in der Antwort auf die Frage 2: “In welchem Jahr sind Sie geboren?” Wenn wir das Geburtsjahr kennen, dann können wir das Alter mit einer kleinen Restunsicherheit schätzen.\n\nsurvey |&gt; \n  select(q002geburt)\n\n# A tibble: 2,811 × 1\n   q002geburt\n        &lt;dbl&gt;\n 1       1970\n 2       1990\n 3       1963\n 4       1989\n 5       1965\n 6       1957\n 7       1960\n 8       1984\n 9       1974\n10       1954\n# ℹ 2,801 more rows\n\n\nDas Geburtsjahr ist numerisch (&lt;dbl&gt;), wir müssen es nur noch von der Jahreszahl abziehen, in der die Umfrage stattgefunden hat:\n\nsurvey |&gt;\n  transmute(age = 2025 - q002geburt)\n\n# A tibble: 2,811 × 1\n     age\n   &lt;dbl&gt;\n 1    55\n 2    35\n 3    62\n 4    36\n 5    60\n 6    68\n 7    65\n 8    41\n 9    51\n10    71\n# ℹ 2,801 more rows\n\n\nSehr schön, wir haben unsere Zählvariable age! Wie verschaffen wir uns einen Überblick? Wir könnten für die Variable age die selben Analysen durchführen, wie wir sie oben für die kontinuierliche Variable eines Preises angewendet haben. Schließlich gibt es ähnlich viele Ausprägungen für das Alter einer Person:\n\nsurvey |&gt;\n  transmute(age = 2025 - q002geburt) |&gt;\n  distinct()\n\n# A tibble: 61 × 1\n     age\n   &lt;dbl&gt;\n 1    55\n 2    35\n 3    62\n 4    36\n 5    60\n 6    68\n 7    65\n 8    41\n 9    51\n10    71\n# ℹ 51 more rows\n\n\nEs sind mit 61 sogar noch mehr Ausprägungen als für den Preis. Betrachten wir also auch hier ein Histogramm, um einen Eindruck über die Alterverteilung der Probanden im Datensatz zu bekommen. Eine Klassenbreite von 5 Jahren erscheint mir sinnvoll:\n\nsurvey |&gt;\n  transmute(age = 2025 - q002geburt) |&gt;\n  ggplot() +\n  aes(x = age) +\n  geom_histogram(binwidth = 5, fill = \"lightblue\", alpha = 0.8) +\n  labs(y = \"Häufigeit\", x = \"Alter\", title = \"Altersverteilung der Probanden\") +\n  theme_bw()\n\n\n\n\n\n\n\n\nIch habe mir in diesem Plot etwas mehr Mühe gemacht und ganz nebenbei ein paar Extras eingebaut, um das Ergebnis ansprechender zu gestalten:\n\nFüllfarbe Hellblau (fill) mit 80%-iger Deckkraft (alpha) für die Balken des Histogramms.\nBeschriftungen der Achsen und ein sprechender Titel mittels der labs-Funktion.\nAnwendung eines Themes mithilfe von theme_bw, was einen helleren Hintergrund bewirkt.\n\n\n\n\n\n\n\nHinweisVisualisierungen polieren\n\n\n\nWährend wir in der explorativen Datenanalyse Wert auf schnelle Ergebnisse legen, wollen wir für Publikationen ansprechende Visualisierungen im Hochglanzformat erstellen. In Kapitel 11 schauen wir explizit auf die Möglichkeiten, Visualisierungen aufzupolieren.\n\n\n\nGanze Zahlen (int)\nZählvariablen besitzen verglichen mit kontinuierlichen Variablen einen wesentlichen Unterschied. Es handelt sich um so genannte ganze Zahlen, die wir in der Mathematik auch natürliche Zahlen nennen. Normalerweise würden wir eine Variable, die nur ganze Zahlen annehmen kann, als diskret und nicht als kontinuierlich bezeichnen. Mit diskret meinen wir gang einfach, dass es eine abzählbare Menge an möglichen Werten gibt und nicht unendlich viele denkbare. Beim Alter sind das die ganzen Zahlen zwischen 0 und dem maximalen Alter, das Menschen erreichen können. Pragmatisch nehmen wir hier mal 140 an, meines Wissens gab es bis jetzt keinen Menschen, der so alt wurde.\nFür diskrete Variablen würden wir in der Regel keinen Boxplot und auch kein Histogramm verwenden, weil diese für kontinuierliche Variablen entwickelt wurden. Wie oben schon beschrieben gibt es bei Zählvariablen Fälle, bei denen wir sie ganz ähnlich wie kontinuierliche Variablen behandeln. Die Variable Alter ist so ein Fall, weil es hier sehr viele Ausprägungen gibt, die zwar diskret sind, aber dennoch eher einer kontinuierlichen Größe ähneln.\nFür ganze Zahlen gibt es in R den Datentyp int, der in der Abbildung 2.1 auch für Zählvariablen angegeben ist. In der Praxis macht es fast keinen Unterschied, ob wir eine Zählvariable als double oder als int speichern. Die einzeigen beiden, die mir einfallen, sind:\n\nDer Datentyp int benötigt weniger Speicherplatz, was bei sehr großen Datensätzen interessant werden könnte.\nDurch die Verwendung des Datentyps int stellen wir auf der Ebene von R sicher, dass die Variable nur ganze Zahlen annehmen kann. Und es macht es für Personen, die mit dem Datensatz nicht vertraut sind, ein Stück transparenter und einfacher zu verstehen.\n\nMachen wir uns die Mühe und wandeln das Alter in den Datentyp int um. In dem Zuge speichern wir ihn auch gleich als neue Variable im existierenden Tibble:\n\nsurvey &lt;- \n    survey |&gt;\n        mutate(Q002age = as.integer(2025 - q002geburt), .after = \"q002geburt\")\n\nEine neue Spalte können wir mit mutate erzeugen. Eine Umwandlung in eine ganze Zahl klappt mit der as.integer-Funktion, allerdings nur, wenn der übergebene Wert als ganze Zahl darstellbar ist. Ansonsten gibt es einen Fehler. Mit dem Parameter .after können wir die Position der neuen Variable bestimmen, nämlich direkt hinter der Urpsrungsvariable des Geburtsjahres.\nÜberprüfen wir das Ganze einmal und geben die neue Spalte aus:\n\nsurvey |&gt;\n    select(q002geburt, Q002age)\n\n# A tibble: 2,811 × 2\n   q002geburt Q002age\n        &lt;dbl&gt;   &lt;int&gt;\n 1       1970      55\n 2       1990      35\n 3       1963      62\n 4       1989      36\n 5       1965      60\n 6       1957      68\n 7       1960      65\n 8       1984      41\n 9       1974      51\n10       1954      71\n# ℹ 2,801 more rows\n\n\nWie alt ist der älteste Teilnehmende?\n\nsurvey |&gt;\n    select(Q002age) |&gt;\n    arrange(desc(Q002age)) |&gt;\n    head(1)\n\n# A tibble: 1 × 1\n  Q002age\n    &lt;int&gt;\n1      80\n\n\nUnd der jüngste?\n\nsurvey |&gt;\n    select(Q002age) |&gt;\n    arrange(Q002age) |&gt;\n    head(1)\n\n# A tibble: 1 × 1\n  Q002age\n    &lt;int&gt;\n1      18\n\n\n\n\nSchneller Überblick über eine Spalte mit skim\nEs gibt ein nützliches Paket mit dem Nmen skimr, das unter anderem die gleichnamige Funktion skim bereitstellt. Sie gibt uns einen schnellen Überblick über einzelne Variablen oder sogar den gesamten Datensatz.\n\nlibrary(skimr)\nsurvey |&gt; \n  select(Q002age) |&gt; \n  skim() |&gt;\n  as_tibble()\n\n# A tibble: 1 × 12\n  skim_type skim_variable n_missing complete_rate numeric.mean numeric.sd\n  &lt;chr&gt;     &lt;chr&gt;             &lt;int&gt;         &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;\n1 numeric   Q002age               0             1         48.4       14.7\n# ℹ 6 more variables: numeric.p0 &lt;dbl&gt;, numeric.p25 &lt;dbl&gt;, numeric.p50 &lt;dbl&gt;,\n#   numeric.p75 &lt;dbl&gt;, numeric.p100 &lt;dbl&gt;, numeric.hist &lt;chr&gt;\n\n\nDen letzten Schritt as_tibble() benötigt ihr nicht, er ist nur notwendig, um die Ausgabe in diesem Buch als Konsolenausgabe zu erzeugen. Wenn ihr skim in eurerm RStudio verwendet, dann wir automatisch eine Konsolenausgabe erzeugt.\nWas sehen wir? Die Funktion skim erzeugt einen Tibble, der eine Reihe von berechneten Variablen in Bezug auf die von uns genannte Spalte Q002age hat:\n\nDen Datentyp (skim_type), der als numeric erkannt wurde\nAnzahl fehlender Werte (n_missing) - hier fehlt kein Wert\nFüllgrad (complete_rate), hier dementsprechend 1 oder 100%\nArithmetisches Mittel: numeric.mean\nStandardabweichung: numeric.sd\nKleinster Wert: numeric.p0\nUnteres Quartil (Q1 oder 25%-Wert): numeric.p25\nMedian (Q2 oder 50%-Wert): numeric.p50\nOberes Quartil (Q3 oder 75%-Wert): numeric.p75\nGrößter Wert: numeric.p100\nASCII-Histogram: numeric.hist\n\nDas sind eine ganze Menge interessanter Werte, die wir mit einem Befehl errechnen können. Und es wird noch besser: Dadurch, dass es sich im Ergebnis um einen Tibble handelt, also einen weiteren Datensatz, können wir mit ihm wie mit jedem anderen Tibble arbeiten. Zum Beispiel nur die beiden Varianten des Durchschnitts auswwählen:\n\nsurvey |&gt; \n  select(Q002age) |&gt; \n  skim() |&gt;\n  yank(\"numeric\") |&gt;\n  select(mean_age = mean, median_age = p50) \n\nVariable type: numeric\n\n\n\nmean_age\nmedian_age\n\n\n\n\n48.39\n50",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#kategoriale-variablen",
    "href": "project-1-survey/types-of-variables.html#kategoriale-variablen",
    "title": "2  Arten von Variablen",
    "section": "2.3 Kategoriale Variablen",
    "text": "2.3 Kategoriale Variablen\n\nNominale Variablen\n\nCategorical variables are variables recording which category an observation is in - simple enough! The color of a flower is an example of a categorical variable. Is the flower white, orange, or red? None of those options is “more” than the others; they’re just different. (Huntington-Klein 2026)\n\nWie der Name schon sagt verwenden wir kategoriale Variablen dann, wenn es definierte Kategorien gibt, in die eine Messung eingruppiert werden kann. Gleichzeitig ist keine Gruppe besser oder schlechter als die andere, sie sind nur unterschiedlich.\n\n\nOrdinale Variablen\n\nOrdinal variables are variables where some values are “more” and others are “less,” but there’s not necessarily a rule as to how much more “more” is. (Huntington-Klein 2026)",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#qualitative-variablen",
    "href": "project-1-survey/types-of-variables.html#qualitative-variablen",
    "title": "2  Arten von Variablen",
    "section": "2.4 Qualitative Variablen",
    "text": "2.4 Qualitative Variablen\n\nQualitative variables are a sort of catch-all category for everything else. They aren’t numeric in nature, but also they’re not categorical. The text of a Washington Post headline is an example of a qualitative variable. (Huntington-Klein 2026)\n\n\n\n\n\nHuntington-Klein, Nick. 2026. The effect: an introduction to research design and causality. Second edition. A Chapman & Hall Book. Boca Raton London New York: CRC Press.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/load.html",
    "href": "project-2-news/load.html",
    "title": "3  Laden der Daten",
    "section": "",
    "text": "3.1 Tagesschau-Beiträge\nIn diesem ersten Kapitel des Projekts erkunden wir wie immer den neuen Datensatz. Dazu laden wir ihn mit R, und zwar als Tibble, damit wir auf alle Funktionen des Tidyverse zurükgreifen können. Anschließend lernen wir etwas über die enthaltenen Informationen.\nDie Daten stammen von der Webseite Tagesschau.de, die täglich aktuelle Nachrichten veröffentlicht. Für dieses Projekt wurden für den Zeitraum 05.01.2006 bis 31.12.2025 insgesamt 59.500 Nachrichtenartikel gesammelt. Wer gerne mehr über den Prozess der Datensammlung erfahren möchte findet im Anhang eine detaillierte Beschreibung der Python-Skripte, die für die Erstellung dieses Datensatzes verwendet wurden.\nFür unsere Analysen gehen wir wie immer davon aus, dass die Daten bereits vorliegen. In diesem Fall als CSV-Datei, die wir sofort als Tibble in R laden können.\nlibrary(tidyverse)\nts &lt;- read_csv(\"data/tagesschau.csv\")\nMit der Funktion glimpse() bekommen wir einen schnellen Überblick über die Struktur des Datensatzes.\nts |&gt;\n  glimpse()    \n\nRows: 59,500\nColumns: 21\n$ supertitle     &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Treffen der EU-Inn…\n$ title          &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Grundzüge für geme…\n$ date_time      &lt;dttm&gt; 2006-01-05 10:50:33, 2006-01-13 13:47:00, 2006-01-13 1…\n$ author         &lt;chr&gt; \"Jörg Schönenborn\", \"tagesschau.de\", \"tagesschau.de\", \"…\n$ ressort        &lt;chr&gt; \"inland\", \"ausland\", \"inland\", \"ausland\", \"wirtschaft\",…\n$ url            &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meld…\n$ thumbnail      &lt;chr&gt; \"\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e8…\n$ tag            &lt;chr&gt; NA, NA, \"INTERVIEW\", NA, \"HINTERGRUND\", NA, NA, NA, \"IN…\n$ shorttext      &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amt…\n$ description    &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amt…\n$ keywords       &lt;chr&gt; \"[\\\"DeutschlandTrend\\\"]\", \"[\\\"Meldung\\\"]\", \"[\\\"Intervie…\n$ date_modified  &lt;dttm&gt; 2021-01-28 10:32:31, 2023-03-01 23:51:29, 2023-03-01 1…\n$ canonical_url  &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meld…\n$ language       &lt;chr&gt; \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"…\n$ paragraphs     &lt;chr&gt; \"[\\\"Bundeskanzlerin Angela Merkel hat in den ersten sec…\n$ text           &lt;chr&gt; \"Bundeskanzlerin Angela Merkel hat in den ersten sechs …\n$ word_count     &lt;dbl&gt; 569, 406, 658, 264, 601, 399, 262, 516, 801, 433, 567, …\n$ image_urls     &lt;chr&gt; \"[\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e…\n$ image_captions &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ related_links  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ source_file    &lt;chr&gt; \"2006-01-05-articles.jsonl\", \"2006-01-13-articles.jsonl…\nWir sehen, dass der Datensatz 59.500 Zeilen und 21 Spalten enthält. Jede Zeile entspricht einem Nachrichtenbeitrag, und jede Spalte enthält Informationen über diesen Beitrag, wie zum Beispiel den Titel, den Text, das Veröffentlichungsdatum und einige interessante Informationen mehr. Lasst uns einen Blick auf ein paar ausgewählte Spalten werfen.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Laden der Daten</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html",
    "href": "project-2-news/factors.html",
    "title": "4  Faktoren",
    "section": "",
    "text": "4.1 Überblick: Welche Variablen sind gute Faktoren?\nViele Variablen im Tagesschau-Datensatz sind kategorial: ressort, language, author, manchmal auch tag oder supertitle. In R werden solche Kategorien häufig als Faktoren (factors) dargestellt. Ein Faktor ist im Kern ein Vektor mit festen Ausprägungen (levels). Das ist in der Datenanalyse nützlich, weil\nIm Tidyverse ist forcats (Teil von tidyverse) das Werkzeug für Faktor-Operationen.\nEin schneller Check ist: Welche Spalten sind Text (&lt;chr&gt;) und haben eher wenige unterschiedliche Werte?\n# Anzahl unterschiedlicher Werte je Zeichen-Spalte\nchar_uniques &lt;- ts |&gt;\n  summarise(\n    across(where(is.character), ~ n_distinct(.x, na.rm = TRUE))\n  ) |&gt;\n  pivot_longer(everything(), names_to = \"variable\", values_to = \"n_distinct\") |&gt;\n  arrange(n_distinct)\n\nchar_uniques\n\n# A tibble: 18 × 2\n   variable       n_distinct\n   &lt;chr&gt;               &lt;int&gt;\n 1 language                4\n 2 ressort                38\n 3 tag                   375\n 4 author               5216\n 5 source_file          6351\n 6 image_captions       9434\n 7 related_links       17122\n 8 thumbnail           41449\n 9 keywords            41962\n10 supertitle          46474\n11 image_urls          48806\n12 title               58902\n13 paragraphs          58986\n14 text                58986\n15 shorttext           59056\n16 description         59059\n17 canonical_url       59231\n18 url                 59433\nInterpretation:",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#überblick-welche-variablen-sind-gute-faktoren",
    "href": "project-2-news/factors.html#überblick-welche-variablen-sind-gute-faktoren",
    "title": "4  Faktoren",
    "section": "",
    "text": "Kleine n_distinct (z.B. language) → sehr gute Kandidaten für Faktoren.\nGroße n_distinct (z.B. title, url) → eher Identifikatoren/Free-Text, meistens kein Faktor.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#häufigkeiten-ressorts-zählen-und-visualisieren",
    "href": "project-2-news/factors.html#häufigkeiten-ressorts-zählen-und-visualisieren",
    "title": "4  Faktoren",
    "section": "4.2 Häufigkeiten: Ressorts zählen und visualisieren",
    "text": "4.2 Häufigkeiten: Ressorts zählen und visualisieren\nBei News-Daten ist ressort meist eine der wichtigsten Kategorien.\n\n# Häufigkeitstabelle\nressort_counts &lt;- ts |&gt;\n  count(ressort, sort = TRUE)\n\nressort_counts\n\n# A tibble: 39 × 2\n   ressort          n\n   &lt;chr&gt;        &lt;int&gt;\n 1 ausland      22675\n 2 wirtschaft   15935\n 3 inland       13463\n 4 wissen        2045\n 5 faktenfinder  1059\n 6 investigativ  1042\n 7 newsticker    1021\n 8 multimedia     650\n 9 kommentar      468\n10 kultur         340\n# ℹ 29 more rows\n\n\nFür eine Visualisierung ist es hilfreich, ressort als Faktor zu nutzen und nach Häufigkeit zu ordnen.\n\nressort_counts |&gt;\n  filter(!is.na(ressort)) |&gt;\n  mutate(ressort = fct_reorder(ressort, n)) |&gt;\n  ggplot(aes(x = ressort, y = n)) +\n  geom_col() +\n  coord_flip() +\n  theme_bw() +\n  labs(x = \"Ressort\", y = \"Anzahl der Beiträge\")\n\n\n\n\n\n\n\n\nWarum ist das nützlich?\n\nDu erkennst sofort, welche Ressorts dominieren (wichtig für Stichproben, Bias, Gewichtung).\nViele weitere Analysen (Zeitreihen, Textfeatures) lassen sich sinnvoll nach Ressort splitten.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#zu-viele-kategorien-lumpen-seltene-werte-zusammenfassen",
    "href": "project-2-news/factors.html#zu-viele-kategorien-lumpen-seltene-werte-zusammenfassen",
    "title": "4  Faktoren",
    "section": "4.3 Zu viele Kategorien: Lumpen (seltene Werte zusammenfassen)",
    "text": "4.3 Zu viele Kategorien: Lumpen (seltene Werte zusammenfassen)\nBei Kategorien wie author gibt es oft sehr viele Ausprägungen. Für Auswertungen und Plots ist es dann sinnvoll, seltene Werte in Other zusammenzufassen.\n\n# Top-Autor:innen + Other\n# (Falls author sehr oft NA ist: NAs explizit als Kategorie behandeln)\n\nts |&gt;\n  mutate(\n    author = fct_explicit_na(author, na_level = \"(fehlend)\"),\n    author = fct_lump_n(author, n = 15)\n  ) |&gt;\n  count(author, sort = TRUE)\n\n# A tibble: 16 × 2\n   author                    n\n   &lt;fct&gt;                 &lt;int&gt;\n 1 Other                 20487\n 2 tagesschau.de         19926\n 3 (fehlend)             16625\n 4 Kai Küstner             387\n 5 Martin Bohne            207\n 6 Silvia Stöber           201\n 7 Stephan Ueberbach       185\n 8 Helga Schmidt           184\n 9 Ralph Sina              182\n10 Jakob Mayr              177\n11 Karin Bensch            177\n12 Patrick Gensing         176\n13 Frank Bräutigam         157\n14 Angela Göpfert          149\n15 Christoph Prössl        148\n16 Jan-Christoph Kitzler   132\n\n\nDas ist ein typischer Schritt in der Datenanalyse:\n\nreduziert visuelle Unordnung,\nverhindert, dass „Einzelfälle“ die Story dominieren,\nstabilisiert Modelle (zu viele Kategorien führen sonst schnell zu Overfitting).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#sinnvolle-reihenfolgen-faktoren-nach-kennzahlen-ordnen",
    "href": "project-2-news/factors.html#sinnvolle-reihenfolgen-faktoren-nach-kennzahlen-ordnen",
    "title": "4  Faktoren",
    "section": "4.4 Sinnvolle Reihenfolgen: Faktoren nach Kennzahlen ordnen",
    "text": "4.4 Sinnvolle Reihenfolgen: Faktoren nach Kennzahlen ordnen\nEin Faktor muss nicht alphabetisch sortiert sein. Häufig willst du Kategorien nach einer analytischen Kennzahl ordnen.\nBeispiel: Welche Ressorts haben im Median die längsten Texte (über word_count)?\n\nressort_wordcount &lt;- ts |&gt;\n  filter(!is.na(ressort), !is.na(word_count)) |&gt;\n  group_by(ressort) |&gt;\n  summarise(\n    n = n(),\n    median_word_count = median(word_count),\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(desc(median_word_count))\n\nressort_wordcount\n\n# A tibble: 32 × 3\n   ressort                                   n median_word_count\n   &lt;chr&gt;                                 &lt;int&gt;             &lt;dbl&gt;\n 1 incels                                    1             2589 \n 2 newsticker                             1021             1987 \n 3 geschichte                                1             1451 \n 4 ueber-uns                                 2             1010.\n 5 fussball                                  4              864.\n 6 ratgeber                                  2              820.\n 7 investigativ                           1042              804.\n 8 faktenfinder                           1059              754 \n 9 news                                      8              678.\n10 Einstellungen einblenden Pfeil rechts   210              657 \n# ℹ 22 more rows\n\n\nUnd als Plot, nach Median-Wortanzahl geordnet:\n\nressort_wordcount |&gt;\n  mutate(ressort = fct_reorder(ressort, median_word_count)) |&gt;\n  ggplot(aes(x = ressort, y = median_word_count)) +\n  geom_col() +\n  coord_flip() +\n  theme_bw() +\n  labs(x = \"Ressort\", y = \"Median Wortanzahl\")\n\n\n\n\n\n\n\n\nSo ein Plot ist ein guter Einstieg, um Hypothesen zu formulieren (z.B. „Politikartikel sind länger als Sportmeldungen“).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#kategorien-bereinigen-recoding-und-missingness-sichtbar-machen",
    "href": "project-2-news/factors.html#kategorien-bereinigen-recoding-und-missingness-sichtbar-machen",
    "title": "4  Faktoren",
    "section": "4.5 Kategorien bereinigen: Recoding und Missingness sichtbar machen",
    "text": "4.5 Kategorien bereinigen: Recoding und Missingness sichtbar machen\nOft sind Kategorien „nicht sauber“: unterschiedliche Schreibweisen, leere Strings, oder NAs. Für Analytics ist es wichtig, diese Fälle bewusst zu behandeln.\nBeispiel: language sollte im Datensatz meistens de sein.\n\n# Sprache: NA explizit machen + Häufigkeiten\n\nts |&gt;\n  mutate(language = fct_explicit_na(language, na_level = \"(fehlend)\")) |&gt;\n  count(language, sort = TRUE)\n\n# A tibble: 5 × 2\n  language      n\n  &lt;fct&gt;     &lt;int&gt;\n1 de        59495\n2 en            2\n3 es            1\n4 it            1\n5 (fehlend)     1\n\n\nWenn du Kategorien zusammenführen möchtest (z.B. Synonyme), hilft fct_recode():\n\n# Beispiel-Recode (nur als Muster; passe Mapping bei Bedarf an deine Daten an)\n\nts |&gt;\n  mutate(\n    ressort = fct_recode(\n      ressort,\n      inland = \"inland\",\n      ausland = \"ausland\"\n    )\n  ) |&gt;\n  count(ressort, sort = TRUE)\n\n# A tibble: 39 × 2\n   ressort          n\n   &lt;fct&gt;        &lt;int&gt;\n 1 ausland      22675\n 2 wirtschaft   15935\n 3 inland       13463\n 4 wissen        2045\n 5 faktenfinder  1059\n 6 investigativ  1042\n 7 newsticker    1021\n 8 multimedia     650\n 9 kommentar      468\n10 kultur         340\n# ℹ 29 more rows",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#abgeleitete-faktoren-wochentag-und-tageszeit",
    "href": "project-2-news/factors.html#abgeleitete-faktoren-wochentag-und-tageszeit",
    "title": "4  Faktoren",
    "section": "4.6 Abgeleitete Faktoren: Wochentag und Tageszeit",
    "text": "4.6 Abgeleitete Faktoren: Wochentag und Tageszeit\nFaktoren entstehen nicht nur aus Textspalten. Gerade Zeitstempel werden in Analytics oft in kategoriale Einheiten transformiert, um Muster sichtbar zu machen.\n\n# Wochentag (deutsche Labels) und Stunde\n# Hinweis: base::weekdays() hängt von der Locale ab; daher nutzen wir lubridate::wday()\n\nts |&gt;\n  mutate(\n    weekday = wday(date_time, label = TRUE, abbr = FALSE, week_start = 1),\n    hour = hour(date_time)\n  ) |&gt;\n  count(weekday, sort = TRUE)\n\n# A tibble: 8 × 2\n  weekday        n\n  &lt;ord&gt;      &lt;int&gt;\n1 Donnerstag 10649\n2 Mittwoch   10503\n3 Dienstag   10158\n4 Freitag     9345\n5 Montag      8979\n6 Samstag     5107\n7 Sonntag     4730\n8 &lt;NA&gt;          29\n\n\nWochentage als Faktor sind besonders nützlich für:\n\nPublikationsmuster (z.B. weniger Beiträge am Wochenende?),\nKontrollvariablen in Modellen,\nsegmentierte Reports (“Mo–Fr” vs. Wochenende).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html",
    "href": "project-2-news/variables.html",
    "title": "5  Variablen",
    "section": "",
    "text": "5.1 Übersicht der Variablen\nNachdem wir in Kapitel 3 die Tagesschau-Daten geladen und einen ersten Überblick über die enthaltenen Informationen gewonnen haben, wollen wir uns nun genauer mit den einzelnen Variablen beschäftigen.\nUm eine Übersicht über die in einem Datensatz enthaltenen Variablen zu bekommen, können wir die Funktion glimpse() verwenden. Sie gibt uns einen schnellen Überblick über die Struktur des Datensatzes, einschließlich der Namen der Variablen, ihrer Datentypen und einiger Beispielwerte.\nts |&gt;\n  glimpse()\n\nRows: 59,500\nColumns: 21\n$ supertitle     &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Treffen der EU-Inn…\n$ title          &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Grundzüge für geme…\n$ date_time      &lt;dttm&gt; 2006-01-05 10:50:33, 2006-01-13 13:47:00, 2006-01-13 1…\n$ author         &lt;chr&gt; \"Jörg Schönenborn\", \"tagesschau.de\", \"tagesschau.de\", \"…\n$ ressort        &lt;chr&gt; \"inland\", \"ausland\", \"inland\", \"ausland\", \"wirtschaft\",…\n$ url            &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meld…\n$ thumbnail      &lt;chr&gt; \"\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e8…\n$ tag            &lt;chr&gt; NA, NA, \"INTERVIEW\", NA, \"HINTERGRUND\", NA, NA, NA, \"IN…\n$ shorttext      &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amt…\n$ description    &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amt…\n$ keywords       &lt;chr&gt; \"[\\\"DeutschlandTrend\\\"]\", \"[\\\"Meldung\\\"]\", \"[\\\"Intervie…\n$ date_modified  &lt;dttm&gt; 2021-01-28 10:32:31, 2023-03-01 23:51:29, 2023-03-01 1…\n$ canonical_url  &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meld…\n$ language       &lt;chr&gt; \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"…\n$ paragraphs     &lt;chr&gt; \"[\\\"Bundeskanzlerin Angela Merkel hat in den ersten sec…\n$ text           &lt;chr&gt; \"Bundeskanzlerin Angela Merkel hat in den ersten sechs …\n$ word_count     &lt;dbl&gt; 569, 406, 658, 264, 601, 399, 262, 516, 801, 433, 567, …\n$ image_urls     &lt;chr&gt; \"[\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e…\n$ image_captions &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ related_links  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ source_file    &lt;chr&gt; \"2006-01-05-articles.jsonl\", \"2006-01-13-articles.jsonl…",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Übersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html#fehlende-werte",
    "href": "project-2-news/variables.html#fehlende-werte",
    "title": "5  Variablen",
    "section": "5.2 Fehlende Werte",
    "text": "5.2 Fehlende Werte\nFehlende Werte (missing values) sind in realen Datensätzen völlig normal: Manche Informationen sind für einen Beitrag nicht vorhanden (z.B. kein:e Autor:in), wurden beim Scraping nicht gefunden oder sind nur für bestimmte Ressorts sinnvoll.\nEin erster, sehr nützlicher Schritt ist ein „Missingness-Profil“: Welche Spalten haben überhaupt fehlende Werte – und wie viele?\n\nts |&gt;\n  summarise(\n    across(\n      everything(),\n      list(n_missing = ~ sum(is.na(.x)), pct_missing = ~ mean(is.na(.x))),\n      .names = \"{.col}__{.fn}\"\n    )\n  ) |&gt;\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\") |&gt;\n  separate(metric, into = c(\"variable\", \"metric\"), sep = \"__\") |&gt;\n  pivot_wider(names_from = metric, values_from = value) |&gt;\n  arrange(desc(pct_missing))\n\n# A tibble: 21 × 3\n   variable       n_missing pct_missing\n   &lt;chr&gt;              &lt;dbl&gt;       &lt;dbl&gt;\n 1 image_captions     49446     0.831  \n 2 related_links      42196     0.709  \n 3 tag                32797     0.551  \n 4 author             16625     0.279  \n 5 image_urls          6140     0.103  \n 6 keywords             638     0.0107 \n 7 date_modified        627     0.0105 \n 8 paragraphs           323     0.00543\n 9 text                 323     0.00543\n10 word_count           323     0.00543\n# ℹ 11 more rows\n\n\nDas Ergebnis hilft dir analytisch sofort weiter:\n\nSpalten mit sehr vielen fehlenden Werten eignen sich oft eher als optionale Zusatzinformationen.\nSpalten mit wenigen fehlenden Werten sind meist robuste „Kernvariablen“.\nWenn wichtige Variablen viele NAs enthalten, lohnt sich Ursachenforschung (Erhebung, Scraper, Parsing, Definition der Variable).\n\nWenn du eine kompakte, gut lesbare Gesamtsicht möchtest, ist skimr sehr praktisch (inkl. Missingness, Verteilungen, Beispiele). Damit die Kapitel auch ohne das Paket rendern, ist es hier optional:\n\nif (requireNamespace(\"skimr\", quietly = TRUE)) {\n  skimr::skim(ts)\n} else {\n  cat(\"Optional: install.packages('skimr') für eine kompakte Variable-Übersicht.\\n\")\n}\n\n\nData summary\n\n\nName\nts\n\n\nNumber of rows\n59500\n\n\nNumber of columns\n21\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n18\n\n\nnumeric\n1\n\n\nPOSIXct\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nsupertitle\n0\n1.00\n3\n67\n0\n46474\n0\n\n\ntitle\n0\n1.00\n3\n146\n0\n58902\n0\n\n\nauthor\n16625\n0.72\n3\n476\n0\n5216\n0\n\n\nressort\n5\n1.00\n2\n37\n0\n38\n0\n\n\nurl\n0\n1.00\n38\n174\n0\n59433\n0\n\n\nthumbnail\n22\n1.00\n67\n320\n0\n41449\n0\n\n\ntag\n32797\n0.45\n2\n76\n0\n375\n0\n\n\nshorttext\n7\n1.00\n10\n717\n0\n59056\n0\n\n\ndescription\n7\n1.00\n10\n807\n0\n59059\n0\n\n\nkeywords\n638\n0.99\n5\n763\n0\n41962\n0\n\n\ncanonical_url\n6\n1.00\n31\n174\n0\n59231\n0\n\n\nlanguage\n1\n1.00\n2\n2\n0\n4\n0\n\n\nparagraphs\n323\n0.99\n22\n84250\n0\n58986\n0\n\n\ntext\n323\n0.99\n18\n84140\n0\n58986\n0\n\n\nimage_urls\n6140\n0.90\n128\n166482\n0\n48806\n0\n\n\nimage_captions\n49446\n0.17\n10\n4379\n0\n9434\n0\n\n\nrelated_links\n42196\n0.29\n42\n27104\n0\n17122\n0\n\n\nsource_file\n0\n1.00\n25\n25\n0\n6351\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nword_count\n323\n0.99\n540.12\n402.18\n3\n320\n461\n657\n11165\n▇▁▁▁▁\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ndate_time\n29\n1.00\n2006-01-05 10:50:33\n2025-12-31 20:29:48\n2023-06-05 17:39:28\n59372\n\n\ndate_modified\n627\n0.99\n2007-05-10 14:15:00\n2026-02-09 17:57:43\n2024-11-07 18:20:14\n58867",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Übersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html#duplikate",
    "href": "project-2-news/variables.html#duplikate",
    "title": "5  Variablen",
    "section": "5.3 Duplikate",
    "text": "5.3 Duplikate\nDuplikate können in News-Daten aus verschiedenen Gründen entstehen: ein Artikel wurde mehrfach gespeichert, die gleiche URL taucht in mehreren Quellfiles auf, oder Inhalte sind sehr ähnlich.\nIn der Praxis definieren wir Duplikate über eine eindeutige ID. Bei Webdaten ist das häufig die url (oder canonical_url). Schauen wir zuerst, ob es URLs gibt, die mehrfach vorkommen:\n\nts |&gt;\n  count(url, sort = TRUE) |&gt;\n  filter(!is.na(url), n &gt; 1)\n\n# A tibble: 11 × 2\n   url                                                                         n\n   &lt;chr&gt;                                                                   &lt;int&gt;\n 1 https://www.tagesschau.de/multimedia/podcast/11km/11km-feed-100.html       53\n 2 https://www.phoenix.de/livestream.html                                      5\n 3 https://www.tagesschau.de/multimedia/podcasts/podcast-11km-101.html         4\n 4 https://www.tagesschau.de/multimedia/podcast/11km/podcast-11km-2788.ht…     2\n 5 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-corona-s…     2\n 6 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-kontroll…     2\n 7 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-rauchen-…     2\n 8 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-streit-u…     2\n 9 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-tabubruc…     2\n10 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-weltglue…     2\n11 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-wer-mach…     2\n\n\nWenn du wissen willst, welche Datensätze dahinterstehen, kannst du dir einzelne Fälle anzeigen lassen. Das ist ein typischer Debugging-Schritt in der Datenbereinigung:\n\nts |&gt;\n  add_count(url, name = \"n_url\") |&gt;\n  filter(!is.na(url), n_url &gt; 1) |&gt;\n  select(url, date_time, ressort, title, n_url) |&gt;\n  arrange(desc(n_url), url, date_time)\n\n# A tibble: 78 × 5\n   url                                   date_time           ressort title n_url\n   &lt;chr&gt;                                 &lt;dttm&gt;              &lt;chr&gt;   &lt;chr&gt; &lt;int&gt;\n 1 https://www.tagesschau.de/multimedia… 2023-04-25 11:15:00 multim… 11KM…    53\n 2 https://www.tagesschau.de/multimedia… 2023-05-30 05:46:00 multim… 11KM…    53\n 3 https://www.tagesschau.de/multimedia… 2023-06-28 05:14:00 multim… 11KM…    53\n 4 https://www.tagesschau.de/multimedia… 2023-07-07 07:07:00 multim… 11KM…    53\n 5 https://www.tagesschau.de/multimedia… 2023-09-26 09:14:00 multim… 11KM…    53\n 6 https://www.tagesschau.de/multimedia… 2023-10-19 09:02:00 multim… 11KM…    53\n 7 https://www.tagesschau.de/multimedia… 2023-11-30 08:58:00 multim… 11KM…    53\n 8 https://www.tagesschau.de/multimedia… 2023-12-19 08:22:00 multim… 11KM…    53\n 9 https://www.tagesschau.de/multimedia… 2024-01-31 07:04:00 multim… 11KM…    53\n10 https://www.tagesschau.de/multimedia… 2024-02-28 06:29:00 multim… 11KM…    53\n# ℹ 68 more rows\n\n\nFür viele Analysen (z.B. Zählen, Zeitreihen) willst du Duplikate entfernen, damit Ergebnisse nicht „aufgeblasen“ werden. Wenn url eindeutig sein soll, kannst du eine deduplizierte Version erzeugen:\n\nts_dedup &lt;- ts |&gt;\n  arrange(date_time) |&gt;\n  distinct(url, .keep_all = TRUE)\n\nts |&gt;\n  summarise(n_rows = n()) |&gt;\n  bind_cols(ts_dedup |&gt; summarise(n_rows_dedup = n()))\n\n# A tibble: 1 × 2\n  n_rows n_rows_dedup\n   &lt;int&gt;        &lt;int&gt;\n1  59500        59433\n\n\nWichtig: Welche Zeile du bei Duplikaten behältst (erste/letzte, nach date_modified, nach Datenqualität) ist eine fachliche Entscheidung. arrange() vor distinct() macht diese Entscheidung explizit und reproduzierbar.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Übersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html#wertebereiche",
    "href": "project-2-news/variables.html#wertebereiche",
    "title": "5  Variablen",
    "section": "5.4 Wertebereiche",
    "text": "5.4 Wertebereiche\nWertebereiche (ranges) sind ein schneller Plausibilitätscheck. Gerade numerische Variablen enthalten manchmal Ausreißer oder „kaputte“ Werte (z.B. negative Längen, extrem große Zählwerte), die aus Parsing- oder Scraping-Problemen stammen.\nIm Datensatz gibt es z.B. word_count (Wortanzahl) und oft auch paragraphs (Absatzanzahl). Wir schauen uns typische Kennzahlen und Ausreißer an:\n\nts |&gt;\n  summarise(\n    n = n(),\n    word_count_min = min(word_count, na.rm = TRUE),\n    word_count_p25 = quantile(word_count, 0.25, na.rm = TRUE),\n    word_count_median = median(word_count, na.rm = TRUE),\n    word_count_p75 = quantile(word_count, 0.75, na.rm = TRUE),\n    word_count_max = max(word_count, na.rm = TRUE),\n    paragraphs_min = min(paragraphs, na.rm = TRUE),\n    paragraphs_median = median(paragraphs, na.rm = TRUE),\n    paragraphs_max = max(paragraphs, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 9\n      n word_count_min word_count_p25 word_count_median word_count_p75\n  &lt;int&gt;          &lt;dbl&gt;          &lt;dbl&gt;             &lt;dbl&gt;          &lt;dbl&gt;\n1 59500              3            320               461            657\n# ℹ 4 more variables: word_count_max &lt;dbl&gt;, paragraphs_min &lt;chr&gt;,\n#   paragraphs_median &lt;chr&gt;, paragraphs_max &lt;chr&gt;\n\n\nEine Visualisierung macht Verteilungen und Ausreißer noch schneller greifbar. Ein Histogramm zeigt dir, wie „lang“ Tagesschau-Beiträge typischerweise sind:\n\nts |&gt;\n  ggplot(aes(x = word_count)) +\n  geom_histogram(bins = 50, na.rm = TRUE) +\n  theme_bw() +\n  labs(x = \"Wortanzahl\", y = \"Anzahl der Beiträge\")\n\n\n\n\n\n\n\n\nUnd ein Boxplot nach Ressort ist nützlich, um Unterschiede zwischen Kategorien sichtbar zu machen (z.B. sind Wirtschaftsartikel im Schnitt länger?):\n\nts |&gt;\n  filter(!is.na(ressort), !is.na(word_count)) |&gt;\n  mutate(ressort = fct_lump_n(ressort, n = 10)) |&gt;\n  ggplot(aes(x = ressort, y = word_count)) +\n  geom_boxplot(outlier.alpha = 0.2) +\n  coord_flip() +\n  theme_bw() +\n  labs(x = \"Ressort (Top 10 + Other)\", y = \"Wortanzahl\")\n\n\n\n\n\n\n\n\nWarum ist das für Data Analytics hilfreich?\n\nDu bekommst ein Gefühl für „typische“ Inhalte (Baseline), bevor du Modelle baust.\nAusreißer-Fälle sind oft inhaltlich spannend (Breaking News) oder Datenprobleme.\nKategorienvergleiche liefern schnell Hypothesen für tiefergehende Analysen (z.B. Trends je Ressort).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Übersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/time.html",
    "href": "project-2-news/time.html",
    "title": "6  Zeit",
    "section": "",
    "text": "6.1 Verteilung der Beiträge über die Zeit\nNachrichten haben einen inhärenten zeitlichen Charakter, da sie sich auf aktuelle Ereignisse beziehen. Es ist daher interessant zu sehen, wie die Anzahl der veröffentlichten Nachrichtenbeiträge über die Zeit verteilt ist. Die entsprechende Spalte für den Zeitbezug erkennen wir in der Ausgabe der glimpse()-Funktion oben am Datentyp &lt;dttm&gt;, was für datetime steht. Schauen wir uns ein paar Beispiele an:\nts |&gt;\n  select(date_time)\n\n# A tibble: 59,500 × 1\n   date_time          \n   &lt;dttm&gt;             \n 1 2006-01-05 10:50:33\n 2 2006-01-13 13:47:00\n 3 2006-01-13 10:18:00\n 4 2006-01-14 14:24:00\n 5 2006-01-15 14:44:00\n 6 2006-01-18 19:30:00\n 7 2006-01-25 17:37:00\n 8 2006-02-02 10:52:26\n 9 2006-02-02 08:39:00\n10 2006-02-14 14:20:00\n# ℹ 59,490 more rows\nWir erkennen an der Ausgabe der ersten Zeilen wie genau ein Wert vom datetime-Datentyp aufgebaut ist. Es handelt sich um ein standardisiertes Format mit dem Namen ISO-8601, das einer festen Syntax folgt. Der erste Teil stellt das Datum mit seinen Bestandteilen Jahr, Monat und Tag dar, jeweils als vierstellige (Jahr) und zweistellige (Monat, Tag) Zahlen, getrennt mit einem Bindestrich. Danach folgt, getrennt durch ein Leerzeichen, die Uhrzeitangabe. Hier ist das Format wie gewohnt: HH:MM:ss, also jeweils zwei Ziffern für die Stunde, Minute und Sekunde, jeweils durch einen Doppelpunkt getrennt.\nWeil das Format standardisiert ist, gibt es entsprechende Funktionen, mit denen wir jeden Bestandteil extrahieren wollen. Mit der Funktion year() bekommen wir etwa nur das Jahr als Zahl. Ensprechende Funktionen gibt es auch für andere Datums- und Zeitbestandteile. Details zur Arbeit mit Datum und Zeit findet ihr im Kapitel Dates and times aus Wickham, Çetinkaya-Rundel, und Grolemund (2023).\nGleichzeitig können wir ein Datum abrunden - klingt komisch? Dabei schneiden wir einfach den Teil des Zeitstempels ab, der unseren gewünschten Detailgrad überschreitet. Wenn wir etwa eine Analyse auf Monatsbasis erstellen wollen, dann können wir jedes Datum auf den jeweils ersten des Monats runden, im dem sich der Zeitstempel befindet:\nts |&gt;\n  mutate(date_month = floor_date(date_time, unit = \"month\"), .keep = \"used\")\n\n# A tibble: 59,500 × 2\n   date_time           date_month         \n   &lt;dttm&gt;              &lt;dttm&gt;             \n 1 2006-01-05 10:50:33 2006-01-01 00:00:00\n 2 2006-01-13 13:47:00 2006-01-01 00:00:00\n 3 2006-01-13 10:18:00 2006-01-01 00:00:00\n 4 2006-01-14 14:24:00 2006-01-01 00:00:00\n 5 2006-01-15 14:44:00 2006-01-01 00:00:00\n 6 2006-01-18 19:30:00 2006-01-01 00:00:00\n 7 2006-01-25 17:37:00 2006-01-01 00:00:00\n 8 2006-02-02 10:52:26 2006-02-01 00:00:00\n 9 2006-02-02 08:39:00 2006-02-01 00:00:00\n10 2006-02-14 14:20:00 2006-02-01 00:00:00\n# ℹ 59,490 more rows\nIn der Ausgabe seht ihr links das Originaldatum mit allen Details und rechts das abgeschnittene und auf den ersten des jeweiligen Monats gerundete Datum. Das Schöne an floor_date() ist, dass es als Ergebnis einen Wert vom gleichen Datentyp erzeugt, also auch ein datetime. Warum ist das gut? Weil wir damit in der Visualisieurung gut klarkommen, wie ihr im nächsten Schritt sehen werdet:\nts |&gt;\n  mutate(date_month = floor_date(date_time, \"month\")) |&gt;\n  ggplot() +\n  aes(x = date_month) +\n  geom_bar() +\n  theme_bw() +\n  labs(x = \"Monat\", y = \"Anzahl der Beiträge\")\nSchaut mal auf die x-Achse. Fällt euch was auf?",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Zeit</span>"
    ]
  },
  {
    "objectID": "project-2-news/time.html#verteilung-der-beiträge-über-die-zeit",
    "href": "project-2-news/time.html#verteilung-der-beiträge-über-die-zeit",
    "title": "6  Zeit",
    "section": "",
    "text": "Wickham, Hadley, Mine Çetinkaya-Rundel, und Garrett Grolemund. 2023. R for data science: import, tidy, transform, visualize, and model data. 2nd edition. Sebastopol, CA: O’Reilly Media, Inc.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Zeit</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html",
    "href": "r-basics/pipe.html",
    "title": "8  Pipe-Operator",
    "section": "",
    "text": "Abbildung 8.1: Die Pipe leitet das Ergebnis des ersten Befehls an den zweiten Befehl weiter.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "appendix/appendix-a-scraping.html",
    "href": "appendix/appendix-a-scraping.html",
    "title": "Anhang A: Scraping",
    "section": "",
    "text": "In diesem Anhang findest du eine detaillierte Beschreibung der Python-Skripte, die für die Erstellung des Datensatzes aus Tagesschau-Beiträge verwendet wurden. Diese Skripte wurden entwickelt, um die Nachrichtenbeiträge von Tagesschau.de zu sammeln und in einem strukturierten Format zu speichern.",
    "crumbs": [
      "Anhang A: Scraping"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Quellen",
    "section": "",
    "text": "Huntington-Klein, Nick. 2026. The Effect: An Introduction to\nResearch Design and Causality. Second edition. A\nChapman & Hall Book. Boca\nRaton London New York: CRC Press.\n\n\nWickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023.\nR for Data Science: Import, Tidy, Transform, Visualize, and Model\nData. 2nd edition. Sebastopol, CA: O’Reilly Media, Inc.",
    "crumbs": [
      "Quellen"
    ]
  }
]