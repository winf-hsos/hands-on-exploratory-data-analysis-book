[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Exploratory Data Analytics",
    "section": "",
    "text": "Vorwort\nDieses Buch fÃ¼hrt in die Werkzeuge der explorativen Datenanalyse ein. Konkretes Werzeug, mit dem wir unsere Analysen erstellen, ist R in Kombination mit dem Tidyverse. FÃ¼r manche Aufgaben im Buch verwenden wir auch Python, insbesondere fÃ¼r die Anwendung von Werkzeugen aus dem Bereich des maschinellen Lernens.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html",
    "href": "project-1-survey/survey-data.html",
    "title": "1Â  Umfragedaten",
    "section": "",
    "text": "1.1 Daten laden mit R\nIn diesem Projekt geht es um die Analyse eines Umfragedatensatzes. Umfragen sind ein praktisches Werkzeug, wenn wir etwas Ã¼ber Einstellungen, PrÃ¤ferenzen oder Verhalten von Menschen herausfinden wollen â€“ und genau solche DatensÃ¤tze begegnen euch spÃ¤ter auch im Job ziemlich hÃ¤ufig.\nBevor wir loslegen, eine Leitfrage: Wenn ihr eine Tabelle mit hunderten Spalten vor euch habt â€“ woher wisst ihr eigentlich, was ihr da seht? Was ist eine Zeile? Was ist eine Spalte? Und wie kÃ¶nnt ihr schnell prÃ¼fen, ob die Daten Ã¼berhaupt korrekt in R angekommen sind? Genau darum geht es in diesem Abschnitt.\nIn jedem Projekt steht am Anfang das Laden der Daten. In diesem Buch gehen wir davon aus, dass ein Datensatz bereits erhoben wurde. Die Datenerhebung ist nicht direkt Bestandteil dieses Buches â€“ es geht primÃ¤r um die Datenanalyse.\nDie Umfrageergebnisse wurden mit der Software Limesurvey erhoben und als CSV-Datei exportiert. Wenn ihr das GitHub-Repository fÃ¼r dieses Buch auf euren Rechner heruntergeladen habt, dann liegen die Daten im Ordner /data und kÃ¶nnen so geladen werden:\nlibrary(tidyverse)\nsurvey &lt;- read_csv(\"data/mds12_schoko_milch.csv\")\nNach AusfÃ¼hrung des Codeblocks stehen die Daten auf dem Objekt survey als Tibble bereit. Es ist eine gute Idee, fÃ¼r hÃ¤ufig verwendete Objekte kurze, aber sprechende Namen zu wÃ¤hlen â€“ survey ist hier ein guter Kompromiss.\nZum Laden der Daten gehÃ¶rt immer auch ein kurzer Reality-Check: Sind wirklich alle Beobachtungen (Zeilen) und Variablen (Spalten) da? Genau diese Frage beantworten wir im nÃ¤chsten Abschnitt.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#daten-laden-mit-r",
    "href": "project-1-survey/survey-data.html#daten-laden-mit-r",
    "title": "1Â  Umfragedaten",
    "section": "",
    "text": "WarnungAchtet auf den Unterstrich\n\n\n\nBitte achtet auf die Verwendung der richtigen Funktion read_csv. Es gibt in R auch eine Funktion mit dem Namen read.csv, die sehr Ã¤hnlich ist, aber keinen Tibble erzeugt. Wir verwenden in diesem Buch durchgehend das Tidyverse und Tibbles.\n\n\n\n\n\n\n\n\n\n\nHinweisMehr zum Laden von Daten laden (auch weitere Formate)\n\n\n\nAn dieser Stelle gehen wir nicht tiefer auf das Laden von Daten und andere Formate ein. Einen detaillierten Einblick findet ihr in Kapitel 7.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#kontext-und-metainformationen",
    "href": "project-1-survey/survey-data.html#kontext-und-metainformationen",
    "title": "1Â  Umfragedaten",
    "section": "1.2 Kontext und Metainformationen",
    "text": "1.2 Kontext und Metainformationen\n\nStellt euch vor, ihr bekommt eine Excel-Datei per Mail â€“ ohne Begleittext. Ihr kÃ¶nnt sie Ã¶ffnen, aber ihr wisst nicht, wer befragt wurde, wann die Erhebung stattgefunden hat oder was die Antwortcodes bedeuten. Ihr kÃ¶nnt dann zwar rechnen, aber ihr lauft Gefahr, das Falsche zu interpretieren. Ein paar Begleitinformationen in der E-Mail wÃ¤ren daher nicht schlecht. Vielleicht so etwas:\n\nâ€œDer verwendete Datensatz wurde am Fachgebiet AgrarÃ¶konomie der Hochschule OsnabrÃ¼ck unter Leitung von Prof.Â Dr.Â Ulrich Enneking im Jahr 2025 erhoben. In einer umfangreichen, mehrteiligen Online-Umfrage wurden deutschlandweit Menschen zu Einstellungen und Kaufverhalten bei Lebensmitteln befragt. An der Umfrage haben 2.811 Personen teilgenommen.â€\nSolche Informationen nennen wir Metainformationen (meta = Ã¼ber) oder Kontextinformationen. HÃ¤ufig lassen sie sich als Wâ€‘Fragen formulieren. TabelleÂ 1.1 fasst die wichtigsten fÃ¼r unseren Datensatz zusammen:\n\n\n\nTabelleÂ 1.1: Metainformationen zum Umfragedatensatz\n\n\n\n\n\n\n\n\n\nWâ€‘Frage\nAntwort\n\n\n\n\nWer hat die Daten erhoben?\nProf.Â Dr.Â Enneking\n\n\nWie wurden die Daten erhoben?\nOnline-Umfrage\n\n\nWann wurden die Daten erhoben?\n2025\n\n\nWo wurden die Daten erhoben?\nonline\n\n\nWer wurde befragt?\n2.811 Menschen deutschlandweit\n\n\nWas wurde erhoben?\nEinstellungen und Kaufverhalten bei Lebensmitteln\n\n\n\n\n\n\nEine Frage ist dabei besonders wichtig, weil sie bestimmt, wie wir spÃ¤ter Zahlen interpretieren: Was reprÃ¤sentiert eine Zeile in den Daten? Was sehen wir eigentlich, wenn wir eine Zeile betrachten? Auf diese Frage brauchen wir eine klare Antwort, bevor wir mit der Analyse beginnen. Manchmal kann man es durch genaues Hinschauen erraten â€“ aber der Schein kann trÃ¼gen. Wenn wir die Daten nicht selbst erhoben haben, sollten wir diese Information aus sicherer Quelle bekommen. In diesem Beispiel habe ich nachgefragt: Eine Zeile entspricht den Antworten einer Person auf die Onlineâ€‘Umfrage. In der empirischen Forschung sprechen wir dann von Beobachtungen.\n\nEmpirical research is any research that uses structured observations from the real world to attempt to answer questions. (Huntington-Klein 2026)\n\nWenn wir wissen, dass jede Zeile eine befragte Person ist, kÃ¶nnen wir auch sauber begrÃ¼nden, warum die Anzahl der Zeilen gleich der Anzahl der Teilnehmenden ist.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#dimensionierung-der-daten",
    "href": "project-1-survey/survey-data.html#dimensionierung-der-daten",
    "title": "1Â  Umfragedaten",
    "section": "1.3 Dimensionierung der Daten",
    "text": "1.3 Dimensionierung der Daten\nEs gibt mehrere Wege, die Anzahl der Beobachtungen zu bestimmen. Ein sehr direkter ist count(): Wenn wir count() ohne Variable aufrufen, zÃ¤hlt R schlicht die Zeilen.\n\nsurvey |&gt;\n1  count()\n\n\n1\n\nDer Befehl count() zÃ¤hlt die Beobachtungen (Zeilen) in einem Datensatz.\n\n\n\n\n# A tibble: 1 Ã— 1\n      n\n  &lt;int&gt;\n1  2811\n\n\nEine zweite, oft sehr praktische MÃ¶glichkeit ist: Gebt einfach den Namen des Tibbles aus. Tibbles zeigen euch direkt eine kompakte Zusammenfassung inkl. Dimensionen (Zeilen x Spalten) und eine Vorschau.\n\nsurvey\n\n# A tibble: 2,811 Ã— 813\n   q001hheinkauf q002geburt q003land q004geschlecht q005os v041nofleisch\n           &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1             2       1970        1              1      0             0\n 2             1       1990        7              1      0             0\n 3             2       1963        6              1      0             0\n 4             2       1989       13              2      0             1\n 5             2       1965        4              1      0             1\n 6             2       1957        2              1      0             0\n 7             2       1960       14              2      0             1\n 8             2       1984       13              1      0             0\n 9             2       1974        1              2      0             0\n10             2       1954       13              2      0             0\n# â„¹ 2,801 more rows\n# â„¹ 807 more variables: v041nofleisch_other &lt;chr&gt;, v041diaet_0nodiaet &lt;dbl&gt;,\n#   v041diaet_1lowcarb &lt;dbl&gt;, v041diaet_2laktose &lt;dbl&gt;,\n#   v041diaet_3gluten &lt;dbl&gt;, v041diaet_4paleo &lt;dbl&gt;, v041diaet_5ketogen &lt;dbl&gt;,\n#   v041diaet_6rohkost &lt;dbl&gt;, v041diaet_7makro &lt;dbl&gt;, v041diaet_8trenn &lt;dbl&gt;,\n#   v041diaet_9frutarisch &lt;dbl&gt;, v041diaet_10fleisch &lt;dbl&gt;,\n#   v041diaet_11mediterran &lt;dbl&gt;, v041diaet_12histaminarm &lt;dbl&gt;, â€¦\n\n\nIn der ersten Zeile der Ausgabe steht die Dimensionierung der Daten. Wir bekommen also nicht nur die Information, wie viele Beobachtungen (2.811) vorhanden sind, sondern auch, wie viele Variablen der Datensatz hat (813). Danach folgen die ersten Zeilen (und so viele Spalten, wie auf die Konsole passen). Tibbles achten darauf, die Konsole nicht komplett mit Text zu fluten, und schneiden daher irgendwann ab.\nManchmal wollen wir die Anzahl Zeilen und Spalten nicht nur wissen, sondern weiterverwenden. Wir kÃ¶nnen sie dann auf Objekten speichern:\n\nrows &lt;- nrow(survey)\ncols &lt;- ncol(survey)\n\nprint(str_glue(\"Der Datensatz hat {rows} Zeilen und {cols} Spalten.\"))\n\nDer Datensatz hat 2811 Zeilen und 813 Spalten.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#variablen-spalten",
    "href": "project-1-survey/survey-data.html#variablen-spalten",
    "title": "1Â  Umfragedaten",
    "section": "1.4 Variablen (Spalten)",
    "text": "1.4 Variablen (Spalten)\nNeben der Frage â€Was ist eine Zeile?â€œ ist die zweite Kernfrage: â€Was misst jede Spalte?â€œ In Umfragen steckt hinter fast jeder Frage (und oft hinter jeder Antwortoption) eine eigene Variable â€“ deshalb werden solche DatensÃ¤tze schnell sehr â€spaltenreichâ€œ.\n\nA variable, in the context of empirical research, is a bunch of observations of the same measurement. (Huntington-Klein 2026)\n\nBeobachtungen stellen wir typischerweise horizontal (in Zeilen) dar, Variablen vertikal (in Spalten).\n\n\n\n\n\n\nAbbildungÂ 1.1: Beobachtungen reprÃ¤sentieren wir als Zeilen, Variablen als Spalten.\n\n\n\nIm Idealfall gibt es zu einem Datensatz ein Data Dictionary (oder Codebuch): eine Art WÃ¶rterbuch, in dem jede Variable aufgefÃ¼hrt und inhaltlich erlÃ¤utert ist. Das ist Gold wert â€“ denn aus reinen Spaltennamen wie q001hheinkauf kÃ¶nnt ihr die Bedeutung oft nicht zuverlÃ¤ssig ableiten.\nDamit ihr trotzdem schnell arbeitsfÃ¤hig werdet, schauen wir uns jetzt Werkzeuge an, mit denen ihr Variablen in R systematisch â€abklopfenâ€œ kÃ¶nnt:\n\nWie viele Variablen gibt es?\nWelche Namen und Datentypen haben sie?\nWelche Werte kommen in einer Variable Ã¼berhaupt vor?\n\n\nWie viele Variablen?\nDie Anzahl der Variablen habt ihr bereits Ã¼ber die Tibble-Ausgabe gesehen. Ihr kÃ¶nnt sie aber auch direkt als Wert auslesen. Hier die Variante mit der Pipe:\n\nsurvey |&gt;\n  ncol()\n\n[1] 813\n\n\nDen Wert kÃ¶nnt ihr auf einem neuen Objekt speichern und spÃ¤ter wiederverwenden , das ist in Skripten hÃ¤ufig nÃ¼tzlich:\n\nvariable_count &lt;- ncol(survey)\n1print(str_glue(\"Der Datensatz hat {variable_count} Variablen.\"))\n\n\n1\n\nMit str_glue() kÃ¶nnt ihr Zeichenketten mit Platzhaltern versehen, die bei der AusfÃ¼hrung mit Werten ersetzt werden.\n\n\n\n\nDer Datensatz hat 813 Variablen.\n\n\n\n\nNamen, Typen, erste Werte: select() + glimpse()\nSchauen wir uns fÃ¼rs Erste nur die ersten 10 Variablen im Datensatz an:\n\nsurvey |&gt;\n1  select(1:10) |&gt;\n2  glimpse()\n\n\n1\n\nMit select() kÃ¶nnt ihr Variablen auswÃ¤hlen. Die Notation 1:10 bedeutet: Variablen an Position 1 bis 10.\n\n2\n\nMit glimpse() bekommt ihr schnell eine Ãœbersicht der Namen, Datentypen und ersten Werte der Variablen.\n\n\n\n\nRows: 2,811\nColumns: 10\n$ q001hheinkauf       &lt;dbl&gt; 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1,â€¦\n$ q002geburt          &lt;dbl&gt; 1970, 1990, 1963, 1989, 1965, 1957, 1960, 1984, 19â€¦\n$ q003land            &lt;dbl&gt; 1, 7, 6, 13, 4, 2, 14, 13, 1, 13, 5, 14, 9, 4, 3, â€¦\n$ q004geschlecht      &lt;dbl&gt; 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1,â€¦\n$ q005os              &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,â€¦\n$ v041nofleisch       &lt;dbl&gt; 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,â€¦\n$ v041nofleisch_other &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NAâ€¦\n$ v041diaet_0nodiaet  &lt;dbl&gt; 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1,â€¦\n$ v041diaet_1lowcarb  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,â€¦\n$ v041diaet_2laktose  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,â€¦\n\n\nHier steckt direkt ein wichtiges Muster drin: Wir bauen eine kleine â€Befehlsketteâ€œ. Das etwas merkwÃ¼rdig aussehende Symbol |&gt; (Pipe) sorgt dafÃ¼r, dass das Ergebnis links an den nÃ¤chsten Befehl rechts Ã¼bergeben wird. Eine dedizierte EinfÃ¼hrung in die Pipe findet ihr in Kapitel 8.\nMit der FlexibilitÃ¤t einer Programmiersprache wie R kÃ¶nnt ihr jede beliebige Menge an Spalten auswÃ¤hlen â€“ zum Beispiel auch die letzten 10:\n\nsurvey |&gt;\n  select(tail(everything(), 10))\n\n# A tibble: 2,811 Ã— 10\n   M070handeldiff3_1hochwertig M070handeldiff3_2regio M070handeldiff3_3preis\n                         &lt;dbl&gt;                  &lt;dbl&gt;                  &lt;dbl&gt;\n 1                          NA                     NA                     NA\n 2                          -1                      1                      2\n 3                          NA                     NA                     NA\n 4                          NA                     NA                     NA\n 5                          NA                     NA                     NA\n 6                          NA                     NA                     NA\n 7                          NA                     NA                     NA\n 8                          NA                     NA                     NA\n 9                           2                      2                     -2\n10                          NA                     NA                     NA\n# â„¹ 2,801 more rows\n# â„¹ 7 more variables: M070handeldiff3_4tierwohl &lt;dbl&gt;,\n#   M070handeldiff3_5vielfalt &lt;dbl&gt;, M070handeldiff3_6vetrauen &lt;dbl&gt;,\n#   M070handeldiff3_7nachhaltig &lt;dbl&gt;, M070handeldiff3_8gesund &lt;dbl&gt;,\n#   M070handeldiff3_9kauf &lt;dbl&gt;, M070handeldiff3_10trends &lt;dbl&gt;\n\n\nMit tail() ermitteln wir die letzten n Elemente einer Liste. everything() gibt uns (innerhalb von select()) die Liste aller Spalten. Der Ausdruck lÃ¤sst sich also Ã¼bersetzen als: Gib mir die letzten 10 Elemente aus der Liste aller Spalten. Gerade bei Umfragen mit vielen Spalten ist dieses gezielte AuswÃ¤hlen extrem nÃ¼tzlich. Noch mehr MÃ¶glichkeiten, Spalten auszuwÃ¤hlen, lernen wir im Verlauf des Projekts und im dedizierten Kapitel 9.\n\n\n\n\n\n\nHinweisVariablen haben eine feste Position\n\n\n\nVariablen (Spalten) haben eine feste Reihenfolge und Position in einem Datensatz. Ihr kÃ¶nnt eine Spalte daher nicht nur Ã¼ber ihren Namen, sondern auch Ã¼ber ihre Position ansprechen.\n\n\n\n\nWelchen Wertebereich hat eine Variable?\nglimpse() ist super, um schnell einen Eindruck zu bekommen â€“ aber es zeigt euch nur die ersten Werte. Wenn ihr wirklich wissen wollt, welche AusprÃ¤gungen vorkommen, mÃ¼sst ihr gezielt nachsehen.\nNehmen wir die Variable q001hheinkauf. Sie gehÃ¶rt zur Frage, ob die teilnehmende Person fÃ¼r den Lebensmitteleinkauf hauptverantwortlich ist oder ob die Aufgabe mit einer anderen Person geteilt wird. Im Codebuch zur Umfrage lesen wir nach, dass â€œ1â€ fÃ¼r â€œIch selbst und eine andere Personâ€ steht, wÃ¤hrend â€œ2â€ fÃ¼r â€œHauptsÃ¤chlich ich selbstâ€ steht. Der Wert â€œ0â€ stÃ¼nde fÃ¼r â€œFast immer eine andere Personâ€. Aber kommen wirklich nur diese Werte vor? Oder kommen Ã¼berhaupt alle vor?\nZuerst kÃ¶nnen wir uns die Spalte als Tibble ausgeben lassen:\n\nsurvey |&gt;\n  select(q001hheinkauf)\n\n# A tibble: 2,811 Ã— 1\n   q001hheinkauf\n           &lt;dbl&gt;\n 1             2\n 2             1\n 3             2\n 4             2\n 5             2\n 6             2\n 7             2\n 8             2\n 9             2\n10             2\n# â„¹ 2,801 more rows\n\n\nStandardmÃ¤ÃŸig zeigt R dabei nur die ersten 10 Zeilen. Das kÃ¶nnt ihr Ã¤ndern:\n\nsurvey |&gt;\n  select(q001hheinkauf) |&gt;\n  print(n = 20)\n\n# A tibble: 2,811 Ã— 1\n   q001hheinkauf\n           &lt;dbl&gt;\n 1             2\n 2             1\n 3             2\n 4             2\n 5             2\n 6             2\n 7             2\n 8             2\n 9             2\n10             2\n11             2\n12             1\n13             2\n14             1\n15             2\n16             2\n17             1\n18             1\n19             2\n20             1\n# â„¹ 2,791 more rows\n\n\nAlle Zeilen auszugeben wÃ¼rde dieses Kapitel sehr lang machen und wÃ¤re gleichzeitig aufwÃ¤ndig zu prÃ¼fen. Um dennoch sicher zu wissen, welche WerteausprÃ¤gungen existieren, kÃ¶nnen wir uns die eindeutigen Werte ausgeben lassen:\n\nsurvey |&gt;\n  distinct(q001hheinkauf)\n\n# A tibble: 2 Ã— 1\n  q001hheinkauf\n          &lt;dbl&gt;\n1             2\n2             1\n\n\nEine kleine Ãœberraschung, denn die â€œ0â€ ist nicht vertreten. Hat scheinbar niemand geantwortet. Wenn ihr zusÃ¤tzlich wissen wollt, wie hÃ¤ufig die AusprÃ¤gungen angekreuzt wurden:\n\nsurvey |&gt;\n  count(q001hheinkauf)\n\n# A tibble: 2 Ã— 2\n  q001hheinkauf     n\n          &lt;dbl&gt; &lt;int&gt;\n1             1   919\n2             2  1892\n\n\nDie Funktion count() gruppiert die Daten nach der Ã¼bergebenen Variable und zÃ¤hlt die Beobachtungen pro Gruppe. Wir stecken schon mittem in der Analyse der Daten ğŸ¤“.\n\n\n\n\n\n\nHinweisAggregieren von Daten\n\n\n\nDie Funktion count() ist eine Aggregationsfunktion. Eine dedizierte EinfÃ¼hrung, wie man mit R und dem dplyrâ€‘Paket Daten zusammenfasst, findet ihr in Kapitel 11.\n\n\nUnd weil es gerade passt: Wenn wir Daten analysieren, dann bevorzugen wir in dem allermeisten FÃ¤llen eine aussagekrÃ¤ftige Visualisierung Ã¼ber eine tabellarische Ausgabe. Die HÃ¤ufigkeiten der beiden AntwortmÃ¶glichkeiten kÃ¶nnen wir wunderbar als Balkendiagramm visualisieren:\n\nsurvey |&gt;\n  count(q001hheinkauf) |&gt;\n  ggplot() +\n  aes(x = q001hheinkauf, y = n) +\n  geom_col()\n\n\n\n\n\n\n\n\nZugegeben: Das Balkendiagramm ist verbesserungswÃ¼rdig, dennoch zeigt es einen wichtigen Aspekt der explorativen Datenanalyse und warum R dafÃ¼r so gut geeignet ist. Mit nur drei Zeilen Code erstellen wir ein Balkendiagramm, das uns die VerhÃ¤ltnisse der Anworten zur ersten Frage im Datensatz visuell aufzeigt. Und das Diagramm ist inhaltlich korrekt, dafÃ¼r sorgt die Bibliothek ggplot2, die wir hier verwenden. Es ist dafÃ¼r nicht wirklich ansprechend (schaut etwas mal die Labels auf der x-Achse an). Aber darum geht es in der explorativen Datenanalyse nicht. Wir wollen schhnell Ergebnisse sehen und flexibel in den Daten wÃ¼hlen kÃ¶nnen. Das funktioniert mit R und dem Tidyverse perfekt!",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/survey-data.html#beobachtungen-zeilen",
    "href": "project-1-survey/survey-data.html#beobachtungen-zeilen",
    "title": "1Â  Umfragedaten",
    "section": "1.5 Beobachtungen (Zeilen)",
    "text": "1.5 Beobachtungen (Zeilen)\nWas fÃ¼r Variablen gilt, gilt auch fÃ¼r Zeilen: Jede hat eine feste Position. Bei Zeilen nennen wir das auch die row number (Zeilennummer). Mit row_number() kÃ¶nnt ihr diese Position abfragen und damit gezielt Zeilen auswÃ¤hlen.\n\nsurvey |&gt;\n  select(1:10) |&gt;\n1  filter(row_number() &lt;= 10)\n\n\n1\n\nMit row_number() bekommen wir die Position (Zeilennummer) einer Beobachtung.\n\n\n\n\n# A tibble: 10 Ã— 10\n   q001hheinkauf q002geburt q003land q004geschlecht q005os v041nofleisch\n           &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;         &lt;dbl&gt;\n 1             2       1970        1              1      0             0\n 2             1       1990        7              1      0             0\n 3             2       1963        6              1      0             0\n 4             2       1989       13              2      0             1\n 5             2       1965        4              1      0             1\n 6             2       1957        2              1      0             0\n 7             2       1960       14              2      0             1\n 8             2       1984       13              1      0             0\n 9             2       1974        1              2      0             0\n10             2       1954       13              2      0             0\n# â„¹ 4 more variables: v041nofleisch_other &lt;chr&gt;, v041diaet_0nodiaet &lt;dbl&gt;,\n#   v041diaet_1lowcarb &lt;dbl&gt;, v041diaet_2laktose &lt;dbl&gt;\n\n\nDie Funktion filter() verwenden wir, um Beobachtungen nach Kriterien einzugrenzen â€“ zum Beispiel um nur weibliche Personen zu betrachten. Mit row_number() kÃ¶nnt ihr stattdessen nach Position filtern, z. B. um â€Beispielzeilenâ€œ fÃ¼r einen ersten Blick zu nehmen.\nStatt â€kleiner-gleichâ€œ (&lt;=) kÃ¶nnt ihr natÃ¼rlich auch andere Operatoren verwenden:\n\nsurvey |&gt;\n  filter(row_number() == 42) |&gt;\n  select(q004geschlecht)\n\n# A tibble: 1 Ã— 1\n  q004geschlecht\n           &lt;dbl&gt;\n1              2\n\n\nDamit habt ihr jetzt die wichtigsten Werkzeuge fÃ¼r den Start: Daten laden, Kontext verstehen, Dimensionen prÃ¼fen, Variablen Ã¼berblicken und Wertebereiche testen. Im nÃ¤chsten Schritt geht es darum, die Variablen inhaltlich zu interpretieren (Codebuch/Data Dictionary) und die Daten fÃ¼r Analysen vorzubereiten.\n\n\n\n\nHuntington-Klein, Nick. 2026. The effect: an introduction to research design and causality. Second edition. A Chapman & Hall Book. Boca Raton London New York: CRC Press.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>1</span>Â  <span class='chapter-title'>Umfragedaten</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html",
    "href": "project-1-survey/types-of-variables.html",
    "title": "2Â  Arten von Variablen",
    "section": "",
    "text": "2.1 Ein Schema zur Orientierung\nIn Kapitel 1 haben wir schon gesehen, dass Umfragedaten aus vielen unterschiedlichen Spalten bestehen: Manche Spalten sind Zahlen, andere sind Kategorien wie â€mÃ¤nnlich/weiblich/diversâ€œ, wieder andere enthalten Freitext. Das ist nicht nur â€Kosmetikâ€œ â€“ der Variablentyp entscheidet ganz praktisch darÃ¼ber,\nLasst uns deshalb Ordnung in die Spalten bringen: Welche Arten von Variablen gibt es â€“ und woran erkennt ihr sie in R?\nUm Variablen sauber abzugrenzen, hilft ein einfaches Schema. Laut Huntington-Klein (2026) unterscheiden wir in der empirischen Forschung zwischen:\nFÃ¼r die Praxis ist auÃŸerdem eine â€Zusammenfassungsebeneâ€œ nÃ¼tzlich:\nWichtig: Diese Einteilung beschreibt das Messniveau (also: was wird gemessen?). Der Datentyp in R (&lt;dbl&gt;, &lt;int&gt;, &lt;chr&gt;, â€¦) ist ein Hinweis, aber nicht die ganze Wahrheit. In Umfragen werden Kategorien z. B. oft als Zahlen kodiert (1, 2, 3 â€¦) oder als viele 0/1â€‘Spalten (Mehrfachauswahl). Ohne Codebuch/Data Dictionary kann man das leicht falsch lesen.\nSchauen wir uns jetzt die Typen nacheinander an â€“ jeweils mit Beispielen aus unserem Datensatz.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#ein-schema-zur-orientierung",
    "href": "project-1-survey/types-of-variables.html#ein-schema-zur-orientierung",
    "title": "2Â  Arten von Variablen",
    "section": "",
    "text": "Kontinuierlichen Variablen\nZÃ¤hlvariablen\nOrdinalen Variablen\nKategorialen Variablen\nQualitativen Variablen\n\n\n\nNumerisch: kontinuierlich + ZÃ¤hlvariablen\nKategorial: nominal + ordinal\n\n\n\n\n\n\n\nAbbildungÂ 2.1: Arten von Variablen und typische verwendete Datentypen in R.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#numerische-variablen",
    "href": "project-1-survey/types-of-variables.html#numerische-variablen",
    "title": "2Â  Arten von Variablen",
    "section": "2.2 Numerische Variablen",
    "text": "2.2 Numerische Variablen\nNumerische (quantitative) Variablen messen eine Menge oder GrÃ¶ÃŸe. Hier sind Kennzahlen wie Mittelwert, Median oder Standardabweichung oft sinnvoll â€“ aber nur, wenn die Daten plausibel sind und ihr AusreiÃŸer/fehlende Werte berÃ¼cksichtigt.\n\nKontinuierliche Variablen\n\nContinuous variables are variables that could take any value (perhaps within some range). (Huntington-Klein 2026)\n\nIm Umfragedatensatz fragt eine Frage nach der Eingabe eines Preises, den die Teilnehmenden bereit wÃ¤ren, fÃ¼r einen Liter Milch einer vorgegebenen Marke zu bezahlen:\nâ€œGeben Sie fÃ¼r die 3 Marken bitte den Preis an, den Sie fÃ¼r angemessen halten und bei dem Sie zugreifen wÃ¼rden! Als Dezimaltrennzeichen verwenden Sie bitte das Komma.â€\nSchauen wir auf ein paar Beobachtungen. Wie sehen die Antworten aus?\n\nsurvey |&gt;\n  select(u013pzahl_1weihen)\n\n# A tibble: 2,811 Ã— 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              1.49\n 2             NA   \n 3             NA   \n 4             NA   \n 5             NA   \n 6             NA   \n 7             NA   \n 8             NA   \n 9            150   \n10             NA   \n# â„¹ 2,801 more rows\n\n\nAnhand der Ausgabe erkennt ihr typischerweise drei Dinge:\n\nDer Datentyp ist &lt;dbl&gt; (double). Das passt zu Dezimalzahlen und ist daher typisch fÃ¼r kontinuierliche Variablen.\nViele Werte sind NA â€“ es fehlen also Angaben. SpÃ¤ter mÃ¼ssen wir klÃ¤ren, warum Werte fehlen und wie wir damit umgehen.\nManchmal seht ihr sehr ungewÃ¶hnliche Werte (z. B. 150 â‚¬). Das sind oft AusreiÃŸer â€“ z. B. durch Tippfehler.\n\n\nFehlende Werte (â€NAâ€œ) kurz behandeln\nFÃ¼r einen ersten Ãœberblick kÃ¶nnen wir fehlende Werte herausfiltern (auch wenn das nicht immer die richtige Entscheidung fÃ¼r eine echte Analyse ist). Das geht mit drop_na():\n\nsurvey |&gt;\n  select(u013pzahl_1weihen) |&gt;\n  drop_na()\n\n# A tibble: 231 Ã— 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              1.49\n 2            150   \n 3              1.19\n 4              3   \n 5              2   \n 6              1.6 \n 7              1.09\n 8              3   \n 9              1.8 \n10              2.2 \n# â„¹ 221 more rows\n\n\nJetzt sehen wir mehr â€echteâ€œ Preise. FÃ¼r kontinuierliche Variablen ist typisch: Es gibt keine feste Liste an AusprÃ¤gungen, sondern (theoretisch) unendlich viele Werte auf einem Kontinuum. Das merkt ihr auch daran, dass distinct() bei solchen Variablen schnell sehr viele unterschiedliche Werte liefern kann:\n\nsurvey |&gt;\n  select(u013pzahl_1weihen) |&gt;\n  drop_na() |&gt;\n  distinct()\n\n# A tibble: 48 Ã— 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              1.49\n 2            150   \n 3              1.19\n 4              3   \n 5              2   \n 6              1.6 \n 7              1.09\n 8              1.8 \n 9              2.2 \n10            120   \n# â„¹ 38 more rows\n\n\nZwar sieht es hier so aus, als wÃ¤ren die eindeutigen Werte mit 48 gar nicht so zahlreich. Trotzdem ist klar: theoretisch kÃ¶nnten viel mehr unterschiedliche Preise eingegeben werden â€“ und â€Preisâ€œ ist von Natur aus eine numerische GrÃ¶ÃŸe.\n\n\nAusreiÃŸer, Mittelwert und Median\nBei kontinuierlichen Variablen spielt hÃ¤ufig das Problem der AusreiÃŸer eine Rolle. Gerade in Umfragen ist ein Tippfehler eine naheliegende Ursache. Je nach Ursprung sind unterschiedliche MaÃŸnahmen mÃ¶glich: Tippfehler sollten wir korrigieren â€“ oder (wenn wir nicht sicher korrigieren kÃ¶nnen) pragmatisch filtern.\nStarten wir mit dem Durchschnittspreis als arithmetischem Mittel:\n\nsurvey |&gt;\n  summarize(avg_price = mean(u013pzahl_1weihen))\n\n# A tibble: 1 Ã— 1\n  avg_price\n      &lt;dbl&gt;\n1        NA\n\n\nWarum steht dort NA? Weil R nicht â€ratenâ€œ will, wie NA in Berechnungen behandelt werden soll. Sobald ein NA in die Rechnung eingeht, wird das Ergebnis NA. FÃ¼r einen ersten Blick entfernen wir also die fehlenden Werte:\n\nsurvey |&gt;\n1  drop_na(u013pzahl_1weihen) |&gt;\n  summarize(avg_price = mean(u013pzahl_1weihen))\n\n\n1\n\ndrop_na() entfernt alle Zeilen mit fehlenden Werten. Wenn ihr Spalten angebt, bezieht sich das Entfernen nur auf diese Spalten.\n\n\n\n\n# A tibble: 1 Ã— 1\n  avg_price\n      &lt;dbl&gt;\n1      4.58\n\n\nIm Durchschnitt halten die Probanden also einen Preis von 4,58 â‚¬ fÃ¼r einen Liter Milch fÃ¼r gerechtfertigt. Klingt das plausibel? PrÃ¼fen wir das mit einer robusteren KenngrÃ¶ÃŸe: dem Median.\n\nsurvey |&gt;\n  drop_na(u013pzahl_1weihen) |&gt;\n  summarize(avg_price = median(u013pzahl_1weihen))\n\n# A tibble: 1 Ã— 1\n  avg_price\n      &lt;dbl&gt;\n1      1.49\n\n\nDer Median ist mit 1,49 â‚¬ deutlich kleiner. Woran liegt das? Der Median ist robust gegenÃ¼ber AusreiÃŸern, das arithmetische Mittel dagegen nicht.\nDas arithmetische Mittel ist:\n\\[\n\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i\n\\]\nDer Median ist der mittlere Wert der sortierten Daten; bei geradem \\(n\\) ist er der Mittelwert der beiden mittleren Werte:\n\\[\n\\tilde{x} =\n\\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, & \\text{falls } n \\text{ ungerade ist},\\\\[6pt]\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & \\text{falls } n \\text{ gerade ist}.\n\\end{cases}\n\\]\nWas also tun? Da wir nicht sicher wissen, welche Eingabe â€eigentlich gemeintâ€œ war, entscheiden wir uns hier pragmatisch fÃ¼r ein Filtern unplausibler Werte. Schauen wir zuerst, welche extrem hohen Werte vorkommen:\n\nsurvey |&gt;\n  select(u013pzahl_1weihen) |&gt;\n  arrange(desc(u013pzahl_1weihen))\n\n# A tibble: 2,811 Ã— 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1               150\n 2               150\n 3               129\n 4               120\n 5               109\n 6                50\n 7                 7\n 8                 4\n 9                 4\n10                 3\n# â„¹ 2,801 more rows\n\n\nGar nicht so einfach, eine Grenze festzulegen. FÃ¼r dieses Beispiel wÃ¤hlen wir 10 â‚¬ als Obergrenze:\n\nsurvey |&gt;\n  filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n  summarize(avg_price = mean(u013pzahl_1weihen))\n\n# A tibble: 1 Ã— 1\n  avg_price\n      &lt;dbl&gt;\n1      1.56\n\n\nGibt es auch AusreiÃŸer nach unten?\n\nsurvey |&gt;\n  select(u013pzahl_1weihen) |&gt;\n  arrange(u013pzahl_1weihen)\n\n# A tibble: 2,811 Ã— 1\n   u013pzahl_1weihen\n               &lt;dbl&gt;\n 1              0   \n 2              0   \n 3              0   \n 4              0.09\n 5              0.89\n 6              0.95\n 7              0.99\n 8              0.99\n 9              0.99\n10              0.99\n# â„¹ 2,801 more rows\n\n\nAuch hier sehen wir unplausible Werte (z. B. 0 â‚¬). Filtern wir beide Seiten:\n\nsurvey |&gt;\n  filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n  filter(u013pzahl_1weihen &gt; 0.1) |&gt;\n  summarize(avg_price = mean(u013pzahl_1weihen))\n\n# A tibble: 1 Ã— 1\n  avg_price\n      &lt;dbl&gt;\n1      1.59\n\n\nDurch die Pipeline werden die Filter nacheinander angewendet: zuerst â€zu groÃŸâ€œ, danach â€zu kleinâ€œ. Danach berechnen wir erneut den Mittelwert.\n\n\n\n\n\n\nHinweisFiltern von Daten\n\n\n\nDie Funktion filter() ist zentral fÃ¼r die Auswahl der richtigen Beobachtungen. Eine EinfÃ¼hrung, wie man mit R und dem dplyrâ€‘Paket Daten filtert, findet ihr in Kapitel 10.\n\n\n\n\nAusreiÃŸer sehen: Boxplot und Histogramm\nVisualisierungen helfen, AusreiÃŸer schnell zu erkennen. Ein Boxplot stellt AusreiÃŸer als Punkte auÃŸerhalb der Box dar:\n\nsurvey |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nMan erkennt hier sehr schÃ¶n die Handvoll AusreiÃŸer. Die Box selbst ist dadurch kaum sichtbar. Was tun? Bei einem Boxplot solltet ihr nicht einfach filtern, â€nur damit es schÃ¶ner aussiehtâ€œ, weil der Boxplot Kennzahlen wie den Median und Quartile aus den gefilterten Daten berechnen wÃ¼rde â€“ und ihr damit den Plot inhaltlich verÃ¤ndert.\nDie LÃ¶sung: Reinzoomen statt filtern. Wir begrenzen nur die Achsenansicht:\n\nsurvey |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_boxplot() +\n  coord_cartesian(xlim = c(0, 10))\n\n\n\n\n\n\n\n\nSchon besser. Die â€Whiskerâ€œ des Boxplots reichen typischerweise bis zum 1,5â€‘fachen Interquartilsabstand (IQR) Ã¼ber/unter die Quartile:\n\\[\n\\left[\\, Q_1 - 1.5\\cdot\\mathrm{IQR},\\; Q_3 + 1.5\\cdot\\mathrm{IQR} \\,\\right]\n\\]\nwobei gilt:\n\\[\n\\mathrm{IQR} = Q_3 - Q_1\n\\]\nZoomen wir noch ein StÃ¼ck weiter hinein:\n\nsurvey |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_boxplot() +\n  coord_cartesian(xlim = c(0, 5))\n\n\n\n\n\n\n\n\nEine Alternative ist ein Histogramm:\n\nsurvey |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_histogram()\n\n\n\n\n\n\n\n\nAuch hier â€ziehenâ€œ AusreiÃŸer die Skala auseinander. Beim Histogramm dÃ¼rft ihr fÃ¼r die Darstellung pragmatisch filtern, weil es nur HÃ¤ufigkeiten pro Klasse zÃ¤hlt:\n\nsurvey |&gt;\n  filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_histogram()\n\n\n\n\n\n\n\n\nWenn ihr keine Klassenbreite angebt, wÃ¤hlt ggplot2 etwas Passendes. Ihr kÃ¶nnt das aber steuern, z. B. mit 50â€‘Centâ€‘Klassen:\n\nsurvey |&gt;\n  filter(u013pzahl_1weihen &lt; 10.0) |&gt;\n  ggplot() +\n  aes(x = u013pzahl_1weihen) +\n  geom_histogram(binwidth = 0.5)\n\n\n\n\n\n\n\n\nFÃ¼r jetzt merken wir uns: Kontinuierliche Variablen sind oft &lt;dbl&gt;, kÃ¶nnen viele AusprÃ¤gungen haben und sind empfindlich gegenÃ¼ber AusreiÃŸern. Boxplot/Histogramm geben euch schnell ein GefÃ¼hl fÃ¼r die Verteilung.\n\n\n\nZÃ¤hlvariablen\n\nCount variables are those that, well, count something. Perhaps how many times something happened or how many of something there are. (Huntington-Klein 2026)\n\nDer Unterschied zur kontinuierlichen Variable ist (ganz pragmatisch): ZÃ¤hlvariablen haben keine Nachkommastellen. Typische Beispiele:\n\nAlter (in Jahren)\nAnzahl KÃ¤ufe pro Monat\nAnzahl verkaufter Produkte\n\nZÃ¤hlvariablen kÃ¶nnen sehr viele AusprÃ¤gungen haben und werden dann in der explorativen Analyse oft Ã¤hnlich behandelt wie kontinuierliche Variablen. Trotzdem ist das Messniveau ein anderes: Es sind diskrete, abzÃ¤hlbare Werte.\n\nBeispiel: Alter aus dem Geburtsjahr ableiten\nDas Alter wurde nicht direkt gefragt, steckt aber indirekt in der Frage: â€In welchem Jahr sind Sie geboren?â€œ.\n\nsurvey |&gt; \n  select(q002geburt)\n\n# A tibble: 2,811 Ã— 1\n   q002geburt\n        &lt;dbl&gt;\n 1       1970\n 2       1990\n 3       1963\n 4       1989\n 5       1965\n 6       1957\n 7       1960\n 8       1984\n 9       1974\n10       1954\n# â„¹ 2,801 more rows\n\n\nWenn wir das Geburtsjahr kennen, kÃ¶nnen wir das Alter (mit kleiner Restunsicherheit) schÃ¤tzen:\n\nsurvey |&gt;\n  transmute(age = 2025 - q002geburt)\n\n# A tibble: 2,811 Ã— 1\n     age\n   &lt;dbl&gt;\n 1    55\n 2    35\n 3    62\n 4    36\n 5    60\n 6    68\n 7    65\n 8    41\n 9    51\n10    71\n# â„¹ 2,801 more rows\n\n\nWie viele unterschiedliche Alterswerte gibt es?\n\nsurvey |&gt;\n  transmute(age = 2025 - q002geburt) |&gt;\n  distinct()\n\n# A tibble: 61 Ã— 1\n     age\n   &lt;dbl&gt;\n 1    55\n 2    35\n 3    62\n 4    36\n 5    60\n 6    68\n 7    65\n 8    41\n 9    51\n10    71\n# â„¹ 51 more rows\n\n\nEs sind mit 61 sogar noch mehr AusprÃ¤gungen als beim Preis. Ein Histogramm mit 5â€‘Jahresâ€‘Klassen gibt schnell einen Ãœberblick:\n\nsurvey |&gt;\n  transmute(age = 2025 - q002geburt) |&gt;\n  ggplot() +\n  aes(x = age) +\n  geom_histogram(binwidth = 5, fill = \"lightblue\", alpha = 0.8) +\n  labs(y = \"HÃ¤ufigkeit\", x = \"Alter\", title = \"Altersverteilung der Probanden\") +\n  theme_bw()\n\n\n\n\n\n\n\n\nHier steckt nebenbei ein wichtiger Punkt: Auch in der explorativen Analyse lohnt es sich manchmal, Visualisierungen kurz lesbarer zu machen (Beschriftungen, Theme, Farben).\n\n\n\n\n\n\nHinweisVisualisierungen polieren\n\n\n\nWÃ¤hrend wir in der explorativen Datenanalyse Wert auf schnelle Ergebnisse legen, wollen wir fÃ¼r Publikationen ansprechende Visualisierungen im Hochglanzformat erstellen. In Kapitel 12 schauen wir explizit auf die MÃ¶glichkeiten, Visualisierungen aufzupolieren.\n\n\n\n\nGanze Zahlen (int)\nZÃ¤hlvariablen bestehen aus ganzen Zahlen (mathematisch: natÃ¼rlichen Zahlen). In R gibt es dafÃ¼r den Datentyp int, der in AbbildungÂ 2.1 auch fÃ¼r ZÃ¤hlvariablen angegeben ist.\nIn der Praxis macht es oft keinen groÃŸen Unterschied, ob ihr eine ZÃ¤hlvariable als double oder int speichert. Zwei Vorteile von int sind:\n\nint benÃ¶tigt weniger Speicher (bei sehr groÃŸen Daten relevant).\nEs signalisiert klar: â€Hier sind nur ganze Zahlen sinnvollâ€œ â€“ das hilft auch anderen, die den Datensatz spÃ¤ter nutzen.\n\nWandeln wir das Alter in int um und speichern es als neue Variable im Tibble:\n\nsurvey &lt;- \n  survey |&gt;\n  mutate(Q002age = as.integer(2025 - q002geburt), .after = \"q002geburt\")\n\nMit mutate() erzeugen wir eine neue Spalte. as.integer() klappt nur, wenn der Wert als ganze Zahl darstellbar ist; sonst gibt es einen Fehler. Mit .after steuern wir die Position der neuen Variable.\n\nsurvey |&gt;\n  select(q002geburt, Q002age)\n\n# A tibble: 2,811 Ã— 2\n   q002geburt Q002age\n        &lt;dbl&gt;   &lt;int&gt;\n 1       1970      55\n 2       1990      35\n 3       1963      62\n 4       1989      36\n 5       1965      60\n 6       1957      68\n 7       1960      65\n 8       1984      41\n 9       1974      51\n10       1954      71\n# â„¹ 2,801 more rows\n\n\nWie alt ist der Ã¤lteste Teilnehmende?\n\nsurvey |&gt;\n  select(Q002age) |&gt;\n  arrange(desc(Q002age)) |&gt;\n  head(1)\n\n# A tibble: 1 Ã— 1\n  Q002age\n    &lt;int&gt;\n1      80\n\n\nUnd der jÃ¼ngste?\n\nsurvey |&gt;\n  select(Q002age) |&gt;\n  arrange(Q002age) |&gt;\n  head(1)\n\n# A tibble: 1 Ã— 1\n  Q002age\n    &lt;int&gt;\n1      18\n\n\n\n\nSchneller Ãœberblick Ã¼ber eine Spalte mit skim()\nEs gibt ein nÃ¼tzliches Paket namens skimr, das unter anderem die Funktion skim() bereitstellt. Sie gibt euch einen schnellen Ãœberblick Ã¼ber einzelne Variablen oder sogar den gesamten Datensatz.\n\nlibrary(skimr)\nsurvey |&gt; \n  select(Q002age) |&gt; \n  skim() |&gt;\n  as_tibble()\n\n# A tibble: 1 Ã— 12\n  skim_type skim_variable n_missing complete_rate numeric.mean numeric.sd\n  &lt;chr&gt;     &lt;chr&gt;             &lt;int&gt;         &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;\n1 numeric   Q002age               0             1         48.4       14.7\n# â„¹ 6 more variables: numeric.p0 &lt;dbl&gt;, numeric.p25 &lt;dbl&gt;, numeric.p50 &lt;dbl&gt;,\n#   numeric.p75 &lt;dbl&gt;, numeric.p100 &lt;dbl&gt;, numeric.hist &lt;chr&gt;\n\n\nDen letzten Schritt as_tibble() benÃ¶tigt ihr nicht â€“ er ist nur notwendig, damit in diesem Buch eine Konsolenausgabe entsteht. In RStudio wird die Ausgabe automatisch passend dargestellt.\nskim() erzeugt einen Tibble mit Kennzahlen zur Variable Q002age, z. B.:\n\nDatentyp (skim_type)\nAnzahl fehlender Werte (n_missing) und FÃ¼llgrad (complete_rate)\nMittelwert, Standardabweichung, Quartile, Minimum/Maximum\nein kleines ASCIIâ€‘Histogramm (numeric.hist)\n\nUnd weil es ein Tibble ist, kÃ¶nnt ihr damit wie mit jedem anderen Datensatz weiterarbeiten â€“ zum Beispiel nur Mittelwert und Median auswÃ¤hlen:\n\nsurvey |&gt; \n  select(Q002age) |&gt; \n  skim() |&gt;\n  yank(\"numeric\") |&gt;\n  select(mean_age = mean, median_age = p50) \n\nVariable type: numeric\n\n\n\nmean_age\nmedian_age\n\n\n\n\n48.39\n50",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#kategoriale-variablen",
    "href": "project-1-survey/types-of-variables.html#kategoriale-variablen",
    "title": "2Â  Arten von Variablen",
    "section": "2.3 Kategoriale Variablen",
    "text": "2.3 Kategoriale Variablen\nKategoriale Variablen ordnen Beobachtungen in Kategorien ein. Oft sind sie in Umfragen sogar der hÃ¤ufigste Typ.\n\nNominale Variablen\n\nCategorical variables are variables recording which category an observation is in - simple enough! The color of a flower is an example of a categorical variable. Is the flower white, orange, or red? None of those options is â€œmoreâ€ than the others; theyâ€™re just different. (Huntington-Klein 2026)\n\nNominale Variablen haben Kategorien ohne natÃ¼rliche Reihenfolge. Typische Beispiele in Umfragen sind Geschlecht, Bundesland oder â€Hauptverantwortlich fÃ¼r den Einkauf: ja/neinâ€œ.\nIn R wollt ihr bei nominalen Variablen meist wissen:\n\nWelche Kategorien kommen vor?\nWie hÃ¤ufig sind sie?\n\nDas geht schnell mit distinct() oder (noch praktischer) count():\n\nsurvey |&gt;\n  count(q004geschlecht)\n\n# A tibble: 3 Ã— 2\n  q004geschlecht     n\n           &lt;dbl&gt; &lt;int&gt;\n1              1  1328\n2              2  1481\n3              3     2\n\n\nViele nominale Variablen sind als Zahlen kodiert (z. B. 1/2/3). Ohne Codebuch wisst ihr dann noch nicht, welche Zahl fÃ¼r welche Kategorie steht â€“ ihr kÃ¶nnt aber trotzdem schon prÃ¼fen, ob es â€unerwarteteâ€œ Codes gibt.\n\n\nOrdinale Variablen\n\nOrdinal variables are variables where some values are â€œmoreâ€ and others are â€œless,â€ but thereâ€™s not necessarily a rule as to how much more â€œmoreâ€ is. (Huntington-Klein 2026)\n\nOrdinale Variablen haben eine Reihenfolge (z. B. Zustimmung von 1 bis 7), aber die AbstÃ¤nde zwischen den Stufen sind nicht zwingend gleich groÃŸ. Das ist wichtig fÃ¼r die Auswertung: HÃ¤ufig sind Median und HÃ¤ufigkeiten sinnvoller als ein Mittelwert, und Visualisierungen sind oft Balkendiagramme.\nIn unserem Datensatz tauchen solche Skalenfragen z. B. in Variablen mit â€â€¦diff7â€¦â€œ im Namen auf. Ein schneller Check:\n\nsurvey |&gt;\n  count(ax010midiff7, sort = TRUE)\n\n# A tibble: 8 Ã— 2\n  ax010midiff7     n\n         &lt;dbl&gt; &lt;int&gt;\n1           NA   478\n2            5   345\n3            6   341\n4            7   340\n5            1   339\n6            4   329\n7            3   323\n8            2   316\n\n\nWenn ihr ordinale Variablen spÃ¤ter modellieren oder sauber visualisieren wollt, ist es oft sinnvoll, sie als ordered factor zu behandeln (statt als â€normaleâ€œ Zahl). Das machen wir an anderer Stelle im Buch noch ausfÃ¼hrlicher.\n\nSonderfall: Mehrfachauswahl als viele 0/1â€‘Spalten\nIn Umfragen werden Mehrfachauswahlâ€‘Fragen hÃ¤ufig als mehrere Dummyâ€‘Spalten gespeichert (0/1). Inhaltlich sind das kategoriale Informationen â€“ gespeichert als Zahlen.\nZum Beispiel gibt es im Datensatz mehrere Spalten, die mit v008ort_ beginnen (Einkaufsorte). Ein erster Blick auf ein paar davon:\n\nsurvey |&gt;\n  select(v008ort_1discount, v008ort_2super, v008ort_9online, v008ort_other) |&gt;\n  glimpse()\n\nRows: 2,811\nColumns: 4\n$ v008ort_1discount &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0â€¦\n$ v008ort_2super    &lt;dbl&gt; 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0â€¦\n$ v008ort_9online   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0â€¦\n$ v008ort_other     &lt;chr&gt; \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0â€¦\n\n\nDie Interpretation ist hier: â€Hat Person X diese Option gewÃ¤hlt â€“ ja/nein?â€œ.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#qualitative-variablen",
    "href": "project-1-survey/types-of-variables.html#qualitative-variablen",
    "title": "2Â  Arten von Variablen",
    "section": "2.4 Qualitative Variablen",
    "text": "2.4 Qualitative Variablen\n\nQualitative variables are a sort of catch-all category for everything else. They arenâ€™t numeric in nature, but also theyâ€™re not categorical. The text of a Washington Post headline is an example of a qualitative variable. (Huntington-Klein 2026)\n\nQualitative Variablen sind hÃ¤ufig Freitext: Antworten, die nicht in eine feste Kategorienliste passen. In Umfragen sind das oft â€Otherâ€œ-Felder. In unserem Datensatz findet ihr solche Spalten z. B. an Namen wie â€¦_other:\n\nsurvey |&gt;\n  select(v041nofleisch_other)\n\n# A tibble: 2,811 Ã— 1\n   v041nofleisch_other\n   &lt;chr&gt;              \n 1 &lt;NA&gt;               \n 2 &lt;NA&gt;               \n 3 &lt;NA&gt;               \n 4 &lt;NA&gt;               \n 5 &lt;NA&gt;               \n 6 &lt;NA&gt;               \n 7 &lt;NA&gt;               \n 8 &lt;NA&gt;               \n 9 &lt;NA&gt;               \n10 &lt;NA&gt;               \n# â„¹ 2,801 more rows\n\n\nFÃ¼r qualitative Variablen ist in der explorativen Analyse oft ein sinnvoller Start:\n\nzuerst die hÃ¤ufigsten Texte anschauen,\nTippfehler/Varianten vereinheitlichen,\nund dann entscheiden, ob man Kategorien daraus macht oder Textanalyse einsetzt.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-1-survey/types-of-variables.html#zusammenfassung-welcher-typ-welche-werkzeuge",
    "href": "project-1-survey/types-of-variables.html#zusammenfassung-welcher-typ-welche-werkzeuge",
    "title": "2Â  Arten von Variablen",
    "section": "2.5 Zusammenfassung: Welcher Typ â†’ welche Werkzeuge?",
    "text": "2.5 Zusammenfassung: Welcher Typ â†’ welche Werkzeuge?\n\nKontinuierlich (dbl): NA/AusreiÃŸer prÃ¼fen, Histogramm/Boxplot, Median als robuste ErgÃ¤nzung.\nZÃ¤hlvariable (diskret, oft int): HÃ¤ufig wie kontinuierlich auswerten, aber â€ganzzahligâ€œ im Kopf behalten.\nNominal (Kategorien): count()/Balkenplot, Kodierungen Ã¼ber Codebuch prÃ¼fen.\nOrdinal (geordnete Kategorien): HÃ¤ufigkeiten + Median; vorsichtig mit Mittelwert/Standardabweichung.\nQualitativ (Text): erst sichten/aufrÃ¤umen, dann strukturieren.\n\n\n\n\n\nHuntington-Klein, Nick. 2026. The effect: an introduction to research design and causality. Second edition. A Chapman & Hall Book. Boca Raton London New York: CRC Press.",
    "crumbs": [
      "Projekt 1: Umfrage",
      "<span class='chapter-number'>2</span>Â  <span class='chapter-title'>Arten von Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/load.html",
    "href": "project-2-news/load.html",
    "title": "3Â  Laden der Daten",
    "section": "",
    "text": "3.1 Tagesschau-BeitrÃ¤ge\nIn diesem ersten Kapitel des Projekts erkunden wir wie immer den neuen Datensatz. Dazu laden wir ihn mit R, und zwar als Tibble, damit wir auf alle Funktionen des Tidyverse zurÃ¼kgreifen kÃ¶nnen. AnschlieÃŸend lernen wir etwas Ã¼ber die enthaltenen Informationen.\nDie Daten stammen von der Webseite Tagesschau.de, die tÃ¤glich aktuelle Nachrichten verÃ¶ffentlicht. FÃ¼r dieses Projekt wurden fÃ¼r den Zeitraum 05.01.2006 bis 31.12.2025 insgesamt 59.500 Nachrichtenartikel gesammelt. Wer gerne mehr Ã¼ber den Prozess der Datensammlung erfahren mÃ¶chte findet im Anhang eine detaillierte Beschreibung der Python-Skripte, die fÃ¼r die Erstellung dieses Datensatzes verwendet wurden.\nFÃ¼r unsere Analysen gehen wir wie immer davon aus, dass die Daten bereits vorliegen. In diesem Fall als CSV-Datei, die wir sofort als Tibble in R laden kÃ¶nnen.\nlibrary(tidyverse)\nts &lt;- read_csv(\"data/tagesschau.csv\")\nMit der Funktion glimpse() bekommen wir einen schnellen Ãœberblick Ã¼ber die Struktur des Datensatzes.\nts |&gt;\n  glimpse()    \n\nRows: 59,500\nColumns: 21\n$ supertitle     &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Treffen der EU-Innâ€¦\n$ title          &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"GrundzÃ¼ge fÃ¼r gemeâ€¦\n$ date_time      &lt;dttm&gt; 2006-01-05 10:50:33, 2006-01-13 13:47:00, 2006-01-13 1â€¦\n$ author         &lt;chr&gt; \"JÃ¶rg SchÃ¶nenborn\", \"tagesschau.de\", \"tagesschau.de\", \"â€¦\n$ ressort        &lt;chr&gt; \"inland\", \"ausland\", \"inland\", \"ausland\", \"wirtschaft\",â€¦\n$ url            &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meldâ€¦\n$ thumbnail      &lt;chr&gt; \"\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e8â€¦\n$ tag            &lt;chr&gt; NA, NA, \"INTERVIEW\", NA, \"HINTERGRUND\", NA, NA, NA, \"INâ€¦\n$ shorttext      &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amtâ€¦\n$ description    &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amtâ€¦\n$ keywords       &lt;chr&gt; \"[\\\"DeutschlandTrend\\\"]\", \"[\\\"Meldung\\\"]\", \"[\\\"Intervieâ€¦\n$ date_modified  &lt;dttm&gt; 2021-01-28 10:32:31, 2023-03-01 23:51:29, 2023-03-01 1â€¦\n$ canonical_url  &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meldâ€¦\n$ language       &lt;chr&gt; \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"â€¦\n$ paragraphs     &lt;chr&gt; \"[\\\"Bundeskanzlerin Angela Merkel hat in den ersten secâ€¦\n$ text           &lt;chr&gt; \"Bundeskanzlerin Angela Merkel hat in den ersten sechs â€¦\n$ word_count     &lt;dbl&gt; 569, 406, 658, 264, 601, 399, 262, 516, 801, 433, 567, â€¦\n$ image_urls     &lt;chr&gt; \"[\\\"https://images.tagesschau.de/image/47dedcab-ee73-4eâ€¦\n$ image_captions &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,â€¦\n$ related_links  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,â€¦\n$ source_file    &lt;chr&gt; \"2006-01-05-articles.jsonl\", \"2006-01-13-articles.jsonlâ€¦\nWir sehen, dass der Datensatz 59.500 Zeilen und 21 Spalten enthÃ¤lt. Jede Zeile entspricht einem Nachrichtenbeitrag, und jede Spalte enthÃ¤lt Informationen Ã¼ber diesen Beitrag, wie zum Beispiel den Titel, den Text, das VerÃ¶ffentlichungsdatum und einige interessante Informationen mehr. Lasst uns einen Blick auf ein paar ausgewÃ¤hlte Spalten werfen.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>3</span>Â  <span class='chapter-title'>Laden der Daten</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html",
    "href": "project-2-news/factors.html",
    "title": "4Â  Faktoren",
    "section": "",
    "text": "4.1 Ãœberblick: Welche Variablen sind gute Faktoren?\nViele Variablen im Tagesschau-Datensatz sind kategorial: ressort, language, author, manchmal auch tag oder supertitle. In R werden solche Kategorien hÃ¤ufig als Faktoren (factors) dargestellt. Ein Faktor ist im Kern ein Vektor mit festen AusprÃ¤gungen (levels). Das ist in der Datenanalyse nÃ¼tzlich, weil\nIm Tidyverse ist forcats (Teil von tidyverse) das Werkzeug fÃ¼r Faktor-Operationen.\nEin schneller Check ist: Welche Spalten sind Text (&lt;chr&gt;) und haben eher wenige unterschiedliche Werte?\n# Anzahl unterschiedlicher Werte je Zeichen-Spalte\nchar_uniques &lt;- ts |&gt;\n  summarise(\n    across(where(is.character), ~ n_distinct(.x, na.rm = TRUE))\n  ) |&gt;\n  pivot_longer(everything(), names_to = \"variable\", values_to = \"n_distinct\") |&gt;\n  arrange(n_distinct)\n\nchar_uniques\n\n# A tibble: 18 Ã— 2\n   variable       n_distinct\n   &lt;chr&gt;               &lt;int&gt;\n 1 language                4\n 2 ressort                38\n 3 tag                   375\n 4 author               5216\n 5 source_file          6351\n 6 image_captions       9434\n 7 related_links       17122\n 8 thumbnail           41449\n 9 keywords            41962\n10 supertitle          46474\n11 image_urls          48806\n12 title               58902\n13 paragraphs          58986\n14 text                58986\n15 shorttext           59056\n16 description         59059\n17 canonical_url       59231\n18 url                 59433\nInterpretation:",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#Ã¼berblick-welche-variablen-sind-gute-faktoren",
    "href": "project-2-news/factors.html#Ã¼berblick-welche-variablen-sind-gute-faktoren",
    "title": "4Â  Faktoren",
    "section": "",
    "text": "Kleine n_distinct (z.B. language) â†’ sehr gute Kandidaten fÃ¼r Faktoren.\nGroÃŸe n_distinct (z.B. title, url) â†’ eher Identifikatoren/Free-Text, meistens kein Faktor.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#hÃ¤ufigkeiten-ressorts-zÃ¤hlen-und-visualisieren",
    "href": "project-2-news/factors.html#hÃ¤ufigkeiten-ressorts-zÃ¤hlen-und-visualisieren",
    "title": "4Â  Faktoren",
    "section": "4.2 HÃ¤ufigkeiten: Ressorts zÃ¤hlen und visualisieren",
    "text": "4.2 HÃ¤ufigkeiten: Ressorts zÃ¤hlen und visualisieren\nBei News-Daten ist ressort meist eine der wichtigsten Kategorien.\n\n# HÃ¤ufigkeitstabelle\nressort_counts &lt;- ts |&gt;\n  count(ressort, sort = TRUE)\n\nressort_counts\n\n# A tibble: 39 Ã— 2\n   ressort          n\n   &lt;chr&gt;        &lt;int&gt;\n 1 ausland      22675\n 2 wirtschaft   15935\n 3 inland       13463\n 4 wissen        2045\n 5 faktenfinder  1059\n 6 investigativ  1042\n 7 newsticker    1021\n 8 multimedia     650\n 9 kommentar      468\n10 kultur         340\n# â„¹ 29 more rows\n\n\nFÃ¼r eine Visualisierung ist es hilfreich, ressort als Faktor zu nutzen und nach HÃ¤ufigkeit zu ordnen.\n\nressort_counts |&gt;\n  filter(!is.na(ressort)) |&gt;\n  mutate(ressort = fct_reorder(ressort, n)) |&gt;\n  ggplot(aes(x = ressort, y = n)) +\n  geom_col() +\n  coord_flip() +\n  theme_bw() +\n  labs(x = \"Ressort\", y = \"Anzahl der BeitrÃ¤ge\")\n\n\n\n\n\n\n\n\nWarum ist das nÃ¼tzlich?\n\nDu erkennst sofort, welche Ressorts dominieren (wichtig fÃ¼r Stichproben, Bias, Gewichtung).\nViele weitere Analysen (Zeitreihen, Textfeatures) lassen sich sinnvoll nach Ressort splitten.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#zu-viele-kategorien-lumpen-seltene-werte-zusammenfassen",
    "href": "project-2-news/factors.html#zu-viele-kategorien-lumpen-seltene-werte-zusammenfassen",
    "title": "4Â  Faktoren",
    "section": "4.3 Zu viele Kategorien: Lumpen (seltene Werte zusammenfassen)",
    "text": "4.3 Zu viele Kategorien: Lumpen (seltene Werte zusammenfassen)\nBei Kategorien wie author gibt es oft sehr viele AusprÃ¤gungen. FÃ¼r Auswertungen und Plots ist es dann sinnvoll, seltene Werte in Other zusammenzufassen.\n\n# Top-Autor:innen + Other\n# (Falls author sehr oft NA ist: NAs explizit als Kategorie behandeln)\n\nts |&gt;\n  mutate(\n    author = fct_explicit_na(author, na_level = \"(fehlend)\"),\n    author = fct_lump_n(author, n = 15)\n  ) |&gt;\n  count(author, sort = TRUE)\n\n# A tibble: 16 Ã— 2\n   author                    n\n   &lt;fct&gt;                 &lt;int&gt;\n 1 Other                 20487\n 2 tagesschau.de         19926\n 3 (fehlend)             16625\n 4 Kai KÃ¼stner             387\n 5 Martin Bohne            207\n 6 Silvia StÃ¶ber           201\n 7 Stephan Ueberbach       185\n 8 Helga Schmidt           184\n 9 Ralph Sina              182\n10 Jakob Mayr              177\n11 Karin Bensch            177\n12 Patrick Gensing         176\n13 Frank BrÃ¤utigam         157\n14 Angela GÃ¶pfert          149\n15 Christoph PrÃ¶ssl        148\n16 Jan-Christoph Kitzler   132\n\n\nDas ist ein typischer Schritt in der Datenanalyse:\n\nreduziert visuelle Unordnung,\nverhindert, dass â€EinzelfÃ¤lleâ€œ die Story dominieren,\nstabilisiert Modelle (zu viele Kategorien fÃ¼hren sonst schnell zu Overfitting).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#sinnvolle-reihenfolgen-faktoren-nach-kennzahlen-ordnen",
    "href": "project-2-news/factors.html#sinnvolle-reihenfolgen-faktoren-nach-kennzahlen-ordnen",
    "title": "4Â  Faktoren",
    "section": "4.4 Sinnvolle Reihenfolgen: Faktoren nach Kennzahlen ordnen",
    "text": "4.4 Sinnvolle Reihenfolgen: Faktoren nach Kennzahlen ordnen\nEin Faktor muss nicht alphabetisch sortiert sein. HÃ¤ufig willst du Kategorien nach einer analytischen Kennzahl ordnen.\nBeispiel: Welche Ressorts haben im Median die lÃ¤ngsten Texte (Ã¼ber word_count)?\n\nressort_wordcount &lt;- ts |&gt;\n  filter(!is.na(ressort), !is.na(word_count)) |&gt;\n  group_by(ressort) |&gt;\n  summarise(\n    n = n(),\n    median_word_count = median(word_count),\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(desc(median_word_count))\n\nressort_wordcount\n\n# A tibble: 32 Ã— 3\n   ressort                                   n median_word_count\n   &lt;chr&gt;                                 &lt;int&gt;             &lt;dbl&gt;\n 1 incels                                    1             2589 \n 2 newsticker                             1021             1987 \n 3 geschichte                                1             1451 \n 4 ueber-uns                                 2             1010.\n 5 fussball                                  4              864.\n 6 ratgeber                                  2              820.\n 7 investigativ                           1042              804.\n 8 faktenfinder                           1059              754 \n 9 news                                      8              678.\n10 Einstellungen einblenden Pfeil rechts   210              657 \n# â„¹ 22 more rows\n\n\nUnd als Plot, nach Median-Wortanzahl geordnet:\n\nressort_wordcount |&gt;\n  mutate(ressort = fct_reorder(ressort, median_word_count)) |&gt;\n  ggplot(aes(x = ressort, y = median_word_count)) +\n  geom_col() +\n  coord_flip() +\n  theme_bw() +\n  labs(x = \"Ressort\", y = \"Median Wortanzahl\")\n\n\n\n\n\n\n\n\nSo ein Plot ist ein guter Einstieg, um Hypothesen zu formulieren (z.B. â€Politikartikel sind lÃ¤nger als Sportmeldungenâ€œ).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#kategorien-bereinigen-recoding-und-missingness-sichtbar-machen",
    "href": "project-2-news/factors.html#kategorien-bereinigen-recoding-und-missingness-sichtbar-machen",
    "title": "4Â  Faktoren",
    "section": "4.5 Kategorien bereinigen: Recoding und Missingness sichtbar machen",
    "text": "4.5 Kategorien bereinigen: Recoding und Missingness sichtbar machen\nOft sind Kategorien â€nicht sauberâ€œ: unterschiedliche Schreibweisen, leere Strings, oder NAs. FÃ¼r Analytics ist es wichtig, diese FÃ¤lle bewusst zu behandeln.\nBeispiel: language sollte im Datensatz meistens de sein.\n\n# Sprache: NA explizit machen + HÃ¤ufigkeiten\n\nts |&gt;\n  mutate(language = fct_explicit_na(language, na_level = \"(fehlend)\")) |&gt;\n  count(language, sort = TRUE)\n\n# A tibble: 5 Ã— 2\n  language      n\n  &lt;fct&gt;     &lt;int&gt;\n1 de        59495\n2 en            2\n3 es            1\n4 it            1\n5 (fehlend)     1\n\n\nWenn du Kategorien zusammenfÃ¼hren mÃ¶chtest (z.B. Synonyme), hilft fct_recode():\n\n# Beispiel-Recode (nur als Muster; passe Mapping bei Bedarf an deine Daten an)\n\nts |&gt;\n  mutate(\n    ressort = fct_recode(\n      ressort,\n      inland = \"inland\",\n      ausland = \"ausland\"\n    )\n  ) |&gt;\n  count(ressort, sort = TRUE)\n\n# A tibble: 39 Ã— 2\n   ressort          n\n   &lt;fct&gt;        &lt;int&gt;\n 1 ausland      22675\n 2 wirtschaft   15935\n 3 inland       13463\n 4 wissen        2045\n 5 faktenfinder  1059\n 6 investigativ  1042\n 7 newsticker    1021\n 8 multimedia     650\n 9 kommentar      468\n10 kultur         340\n# â„¹ 29 more rows",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/factors.html#abgeleitete-faktoren-wochentag-und-tageszeit",
    "href": "project-2-news/factors.html#abgeleitete-faktoren-wochentag-und-tageszeit",
    "title": "4Â  Faktoren",
    "section": "4.6 Abgeleitete Faktoren: Wochentag und Tageszeit",
    "text": "4.6 Abgeleitete Faktoren: Wochentag und Tageszeit\nFaktoren entstehen nicht nur aus Textspalten. Gerade Zeitstempel werden in Analytics oft in kategoriale Einheiten transformiert, um Muster sichtbar zu machen.\n\n# Wochentag (deutsche Labels) und Stunde\n# Hinweis: base::weekdays() hÃ¤ngt von der Locale ab; daher nutzen wir lubridate::wday()\n\nts |&gt;\n  mutate(\n    weekday = wday(date_time, label = TRUE, abbr = FALSE, week_start = 1),\n    hour = hour(date_time)\n  ) |&gt;\n  count(weekday, sort = TRUE)\n\n# A tibble: 8 Ã— 2\n  weekday        n\n  &lt;ord&gt;      &lt;int&gt;\n1 Donnerstag 10649\n2 Mittwoch   10503\n3 Dienstag   10158\n4 Freitag     9345\n5 Montag      8979\n6 Samstag     5107\n7 Sonntag     4730\n8 &lt;NA&gt;          29\n\n\nWochentage als Faktor sind besonders nÃ¼tzlich fÃ¼r:\n\nPublikationsmuster (z.B. weniger BeitrÃ¤ge am Wochenende?),\nKontrollvariablen in Modellen,\nsegmentierte Reports (â€œMoâ€“Frâ€ vs.Â Wochenende).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>4</span>Â  <span class='chapter-title'>Faktoren</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html",
    "href": "project-2-news/variables.html",
    "title": "5Â  Variablen",
    "section": "",
    "text": "5.1 Ãœbersicht der Variablen\nNachdem wir in Kapitel 3 die Tagesschau-Daten geladen und einen ersten Ãœberblick Ã¼ber die enthaltenen Informationen gewonnen haben, wollen wir uns nun genauer mit den einzelnen Variablen beschÃ¤ftigen.\nUm eine Ãœbersicht Ã¼ber die in einem Datensatz enthaltenen Variablen zu bekommen, kÃ¶nnen wir die Funktion glimpse() verwenden. Sie gibt uns einen schnellen Ãœberblick Ã¼ber die Struktur des Datensatzes, einschlieÃŸlich der Namen der Variablen, ihrer Datentypen und einiger Beispielwerte.\nts |&gt;\n  glimpse()\n\nRows: 59,500\nColumns: 21\n$ supertitle     &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"Treffen der EU-Innâ€¦\n$ title          &lt;chr&gt; \"ARD-DeutschlandTrend Januar 2006\", \"GrundzÃ¼ge fÃ¼r gemeâ€¦\n$ date_time      &lt;dttm&gt; 2006-01-05 10:50:33, 2006-01-13 13:47:00, 2006-01-13 1â€¦\n$ author         &lt;chr&gt; \"JÃ¶rg SchÃ¶nenborn\", \"tagesschau.de\", \"tagesschau.de\", \"â€¦\n$ ressort        &lt;chr&gt; \"inland\", \"ausland\", \"inland\", \"ausland\", \"wirtschaft\",â€¦\n$ url            &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meldâ€¦\n$ thumbnail      &lt;chr&gt; \"\\\"https://images.tagesschau.de/image/47dedcab-ee73-4e8â€¦\n$ tag            &lt;chr&gt; NA, NA, \"INTERVIEW\", NA, \"HINTERGRUND\", NA, NA, NA, \"INâ€¦\n$ shorttext      &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amtâ€¦\n$ description    &lt;chr&gt; \"Angela Merkel hat in den ersten sechs Wochen ihrer Amtâ€¦\n$ keywords       &lt;chr&gt; \"[\\\"DeutschlandTrend\\\"]\", \"[\\\"Meldung\\\"]\", \"[\\\"Intervieâ€¦\n$ date_modified  &lt;dttm&gt; 2021-01-28 10:32:31, 2023-03-01 23:51:29, 2023-03-01 1â€¦\n$ canonical_url  &lt;chr&gt; \"https://www.tagesschau.de/inland/deutschlandtrend/meldâ€¦\n$ language       &lt;chr&gt; \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"de\", \"â€¦\n$ paragraphs     &lt;chr&gt; \"[\\\"Bundeskanzlerin Angela Merkel hat in den ersten secâ€¦\n$ text           &lt;chr&gt; \"Bundeskanzlerin Angela Merkel hat in den ersten sechs â€¦\n$ word_count     &lt;dbl&gt; 569, 406, 658, 264, 601, 399, 262, 516, 801, 433, 567, â€¦\n$ image_urls     &lt;chr&gt; \"[\\\"https://images.tagesschau.de/image/47dedcab-ee73-4eâ€¦\n$ image_captions &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,â€¦\n$ related_links  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,â€¦\n$ source_file    &lt;chr&gt; \"2006-01-05-articles.jsonl\", \"2006-01-13-articles.jsonlâ€¦",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Ãœbersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html#fehlende-werte",
    "href": "project-2-news/variables.html#fehlende-werte",
    "title": "5Â  Variablen",
    "section": "5.2 Fehlende Werte",
    "text": "5.2 Fehlende Werte\nFehlende Werte (missing values) sind in realen DatensÃ¤tzen vÃ¶llig normal: Manche Informationen sind fÃ¼r einen Beitrag nicht vorhanden (z.B. kein:e Autor:in), wurden beim Scraping nicht gefunden oder sind nur fÃ¼r bestimmte Ressorts sinnvoll.\nEin erster, sehr nÃ¼tzlicher Schritt ist ein â€Missingness-Profilâ€œ: Welche Spalten haben Ã¼berhaupt fehlende Werte â€“ und wie viele?\n\nts |&gt;\n  summarise(\n    across(\n      everything(),\n      list(n_missing = ~ sum(is.na(.x)), pct_missing = ~ mean(is.na(.x))),\n      .names = \"{.col}__{.fn}\"\n    )\n  ) |&gt;\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\") |&gt;\n  separate(metric, into = c(\"variable\", \"metric\"), sep = \"__\") |&gt;\n  pivot_wider(names_from = metric, values_from = value) |&gt;\n  arrange(desc(pct_missing))\n\n# A tibble: 21 Ã— 3\n   variable       n_missing pct_missing\n   &lt;chr&gt;              &lt;dbl&gt;       &lt;dbl&gt;\n 1 image_captions     49446     0.831  \n 2 related_links      42196     0.709  \n 3 tag                32797     0.551  \n 4 author             16625     0.279  \n 5 image_urls          6140     0.103  \n 6 keywords             638     0.0107 \n 7 date_modified        627     0.0105 \n 8 paragraphs           323     0.00543\n 9 text                 323     0.00543\n10 word_count           323     0.00543\n# â„¹ 11 more rows\n\n\nDas Ergebnis hilft dir analytisch sofort weiter:\n\nSpalten mit sehr vielen fehlenden Werten eignen sich oft eher als optionale Zusatzinformationen.\nSpalten mit wenigen fehlenden Werten sind meist robuste â€Kernvariablenâ€œ.\nWenn wichtige Variablen viele NAs enthalten, lohnt sich Ursachenforschung (Erhebung, Scraper, Parsing, Definition der Variable).\n\nWenn du eine kompakte, gut lesbare Gesamtsicht mÃ¶chtest, ist skimr sehr praktisch (inkl. Missingness, Verteilungen, Beispiele). Damit die Kapitel auch ohne das Paket rendern, ist es hier optional:\n\nif (requireNamespace(\"skimr\", quietly = TRUE)) {\n  skimr::skim(ts)\n} else {\n  cat(\"Optional: install.packages('skimr') fÃ¼r eine kompakte Variable-Ãœbersicht.\\n\")\n}\n\n\nData summary\n\n\nName\nts\n\n\nNumber of rows\n59500\n\n\nNumber of columns\n21\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n18\n\n\nnumeric\n1\n\n\nPOSIXct\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nsupertitle\n0\n1.00\n3\n67\n0\n46474\n0\n\n\ntitle\n0\n1.00\n3\n146\n0\n58902\n0\n\n\nauthor\n16625\n0.72\n3\n476\n0\n5216\n0\n\n\nressort\n5\n1.00\n2\n37\n0\n38\n0\n\n\nurl\n0\n1.00\n38\n174\n0\n59433\n0\n\n\nthumbnail\n22\n1.00\n67\n320\n0\n41449\n0\n\n\ntag\n32797\n0.45\n2\n76\n0\n375\n0\n\n\nshorttext\n7\n1.00\n10\n717\n0\n59056\n0\n\n\ndescription\n7\n1.00\n10\n807\n0\n59059\n0\n\n\nkeywords\n638\n0.99\n5\n763\n0\n41962\n0\n\n\ncanonical_url\n6\n1.00\n31\n174\n0\n59231\n0\n\n\nlanguage\n1\n1.00\n2\n2\n0\n4\n0\n\n\nparagraphs\n323\n0.99\n22\n84250\n0\n58986\n0\n\n\ntext\n323\n0.99\n18\n84140\n0\n58986\n0\n\n\nimage_urls\n6140\n0.90\n128\n166482\n0\n48806\n0\n\n\nimage_captions\n49446\n0.17\n10\n4379\n0\n9434\n0\n\n\nrelated_links\n42196\n0.29\n42\n27104\n0\n17122\n0\n\n\nsource_file\n0\n1.00\n25\n25\n0\n6351\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nword_count\n323\n0.99\n540.12\n402.18\n3\n320\n461\n657\n11165\nâ–‡â–â–â–â–\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ndate_time\n29\n1.00\n2006-01-05 10:50:33\n2025-12-31 20:29:48\n2023-06-05 17:39:28\n59372\n\n\ndate_modified\n627\n0.99\n2007-05-10 14:15:00\n2026-02-09 17:57:43\n2024-11-07 18:20:14\n58867",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Ãœbersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html#duplikate",
    "href": "project-2-news/variables.html#duplikate",
    "title": "5Â  Variablen",
    "section": "5.3 Duplikate",
    "text": "5.3 Duplikate\nDuplikate kÃ¶nnen in News-Daten aus verschiedenen GrÃ¼nden entstehen: ein Artikel wurde mehrfach gespeichert, die gleiche URL taucht in mehreren Quellfiles auf, oder Inhalte sind sehr Ã¤hnlich.\nIn der Praxis definieren wir Duplikate Ã¼ber eine eindeutige ID. Bei Webdaten ist das hÃ¤ufig die url (oder canonical_url). Schauen wir zuerst, ob es URLs gibt, die mehrfach vorkommen:\n\nts |&gt;\n  count(url, sort = TRUE) |&gt;\n  filter(!is.na(url), n &gt; 1)\n\n# A tibble: 11 Ã— 2\n   url                                                                         n\n   &lt;chr&gt;                                                                   &lt;int&gt;\n 1 https://www.tagesschau.de/multimedia/podcast/11km/11km-feed-100.html       53\n 2 https://www.phoenix.de/livestream.html                                      5\n 3 https://www.tagesschau.de/multimedia/podcasts/podcast-11km-101.html         4\n 4 https://www.tagesschau.de/multimedia/podcast/11km/podcast-11km-2788.htâ€¦     2\n 5 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-corona-sâ€¦     2\n 6 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-kontrollâ€¦     2\n 7 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-rauchen-â€¦     2\n 8 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-streit-uâ€¦     2\n 9 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-tabubrucâ€¦     2\n10 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-weltglueâ€¦     2\n11 https://www.tagesschau.de/multimedia/podcast/15-minuten/audio-wer-machâ€¦     2\n\n\nWenn du wissen willst, welche DatensÃ¤tze dahinterstehen, kannst du dir einzelne FÃ¤lle anzeigen lassen. Das ist ein typischer Debugging-Schritt in der Datenbereinigung:\n\nts |&gt;\n  add_count(url, name = \"n_url\") |&gt;\n  filter(!is.na(url), n_url &gt; 1) |&gt;\n  select(url, date_time, ressort, title, n_url) |&gt;\n  arrange(desc(n_url), url, date_time)\n\n# A tibble: 78 Ã— 5\n   url                                   date_time           ressort title n_url\n   &lt;chr&gt;                                 &lt;dttm&gt;              &lt;chr&gt;   &lt;chr&gt; &lt;int&gt;\n 1 https://www.tagesschau.de/multimediaâ€¦ 2023-04-25 11:15:00 multimâ€¦ 11KMâ€¦    53\n 2 https://www.tagesschau.de/multimediaâ€¦ 2023-05-30 05:46:00 multimâ€¦ 11KMâ€¦    53\n 3 https://www.tagesschau.de/multimediaâ€¦ 2023-06-28 05:14:00 multimâ€¦ 11KMâ€¦    53\n 4 https://www.tagesschau.de/multimediaâ€¦ 2023-07-07 07:07:00 multimâ€¦ 11KMâ€¦    53\n 5 https://www.tagesschau.de/multimediaâ€¦ 2023-09-26 09:14:00 multimâ€¦ 11KMâ€¦    53\n 6 https://www.tagesschau.de/multimediaâ€¦ 2023-10-19 09:02:00 multimâ€¦ 11KMâ€¦    53\n 7 https://www.tagesschau.de/multimediaâ€¦ 2023-11-30 08:58:00 multimâ€¦ 11KMâ€¦    53\n 8 https://www.tagesschau.de/multimediaâ€¦ 2023-12-19 08:22:00 multimâ€¦ 11KMâ€¦    53\n 9 https://www.tagesschau.de/multimediaâ€¦ 2024-01-31 07:04:00 multimâ€¦ 11KMâ€¦    53\n10 https://www.tagesschau.de/multimediaâ€¦ 2024-02-28 06:29:00 multimâ€¦ 11KMâ€¦    53\n# â„¹ 68 more rows\n\n\nFÃ¼r viele Analysen (z.B. ZÃ¤hlen, Zeitreihen) willst du Duplikate entfernen, damit Ergebnisse nicht â€aufgeblasenâ€œ werden. Wenn url eindeutig sein soll, kannst du eine deduplizierte Version erzeugen:\n\nts_dedup &lt;- ts |&gt;\n  arrange(date_time) |&gt;\n  distinct(url, .keep_all = TRUE)\n\nts |&gt;\n  summarise(n_rows = n()) |&gt;\n  bind_cols(ts_dedup |&gt; summarise(n_rows_dedup = n()))\n\n# A tibble: 1 Ã— 2\n  n_rows n_rows_dedup\n   &lt;int&gt;        &lt;int&gt;\n1  59500        59433\n\n\nWichtig: Welche Zeile du bei Duplikaten behÃ¤ltst (erste/letzte, nach date_modified, nach DatenqualitÃ¤t) ist eine fachliche Entscheidung. arrange() vor distinct() macht diese Entscheidung explizit und reproduzierbar.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Ãœbersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/variables.html#wertebereiche",
    "href": "project-2-news/variables.html#wertebereiche",
    "title": "5Â  Variablen",
    "section": "5.4 Wertebereiche",
    "text": "5.4 Wertebereiche\nWertebereiche (ranges) sind ein schneller PlausibilitÃ¤tscheck. Gerade numerische Variablen enthalten manchmal AusreiÃŸer oder â€kaputteâ€œ Werte (z.B. negative LÃ¤ngen, extrem groÃŸe ZÃ¤hlwerte), die aus Parsing- oder Scraping-Problemen stammen.\nIm Datensatz gibt es z.B. word_count (Wortanzahl) und oft auch paragraphs (Absatzanzahl). Wir schauen uns typische Kennzahlen und AusreiÃŸer an:\n\nts |&gt;\n  summarise(\n    n = n(),\n    word_count_min = min(word_count, na.rm = TRUE),\n    word_count_p25 = quantile(word_count, 0.25, na.rm = TRUE),\n    word_count_median = median(word_count, na.rm = TRUE),\n    word_count_p75 = quantile(word_count, 0.75, na.rm = TRUE),\n    word_count_max = max(word_count, na.rm = TRUE),\n    paragraphs_min = min(paragraphs, na.rm = TRUE),\n    paragraphs_median = median(paragraphs, na.rm = TRUE),\n    paragraphs_max = max(paragraphs, na.rm = TRUE)\n  )\n\n# A tibble: 1 Ã— 9\n      n word_count_min word_count_p25 word_count_median word_count_p75\n  &lt;int&gt;          &lt;dbl&gt;          &lt;dbl&gt;             &lt;dbl&gt;          &lt;dbl&gt;\n1 59500              3            320               461            657\n# â„¹ 4 more variables: word_count_max &lt;dbl&gt;, paragraphs_min &lt;chr&gt;,\n#   paragraphs_median &lt;chr&gt;, paragraphs_max &lt;chr&gt;\n\n\nEine Visualisierung macht Verteilungen und AusreiÃŸer noch schneller greifbar. Ein Histogramm zeigt dir, wie â€langâ€œ Tagesschau-BeitrÃ¤ge typischerweise sind:\n\nts |&gt;\n  ggplot(aes(x = word_count)) +\n  geom_histogram(bins = 50, na.rm = TRUE) +\n  theme_bw() +\n  labs(x = \"Wortanzahl\", y = \"Anzahl der BeitrÃ¤ge\")\n\n\n\n\n\n\n\n\nUnd ein Boxplot nach Ressort ist nÃ¼tzlich, um Unterschiede zwischen Kategorien sichtbar zu machen (z.B. sind Wirtschaftsartikel im Schnitt lÃ¤nger?):\n\nts |&gt;\n  filter(!is.na(ressort), !is.na(word_count)) |&gt;\n  mutate(ressort = fct_lump_n(ressort, n = 10)) |&gt;\n  ggplot(aes(x = ressort, y = word_count)) +\n  geom_boxplot(outlier.alpha = 0.2) +\n  coord_flip() +\n  theme_bw() +\n  labs(x = \"Ressort (Top 10 + Other)\", y = \"Wortanzahl\")\n\n\n\n\n\n\n\n\nWarum ist das fÃ¼r Data Analytics hilfreich?\n\nDu bekommst ein GefÃ¼hl fÃ¼r â€typischeâ€œ Inhalte (Baseline), bevor du Modelle baust.\nAusreiÃŸer-FÃ¤lle sind oft inhaltlich spannend (Breaking News) oder Datenprobleme.\nKategorienvergleiche liefern schnell Hypothesen fÃ¼r tiefergehende Analysen (z.B. Trends je Ressort).",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>5</span>Â  <span class='chapter-title'>Ãœbersicht der Variablen</span>"
    ]
  },
  {
    "objectID": "project-2-news/time.html",
    "href": "project-2-news/time.html",
    "title": "6Â  Zeit",
    "section": "",
    "text": "6.1 Verteilung der BeitrÃ¤ge Ã¼ber die Zeit\nNachrichten haben einen inhÃ¤renten zeitlichen Charakter, da sie sich auf aktuelle Ereignisse beziehen. Es ist daher interessant zu sehen, wie die Anzahl der verÃ¶ffentlichten NachrichtenbeitrÃ¤ge Ã¼ber die Zeit verteilt ist. Die entsprechende Spalte fÃ¼r den Zeitbezug erkennen wir in der Ausgabe der glimpse()-Funktion oben am Datentyp &lt;dttm&gt;, was fÃ¼r datetime steht. Schauen wir uns ein paar Beispiele an:\nts |&gt;\n  select(date_time)\n\n# A tibble: 59,500 Ã— 1\n   date_time          \n   &lt;dttm&gt;             \n 1 2006-01-05 10:50:33\n 2 2006-01-13 13:47:00\n 3 2006-01-13 10:18:00\n 4 2006-01-14 14:24:00\n 5 2006-01-15 14:44:00\n 6 2006-01-18 19:30:00\n 7 2006-01-25 17:37:00\n 8 2006-02-02 10:52:26\n 9 2006-02-02 08:39:00\n10 2006-02-14 14:20:00\n# â„¹ 59,490 more rows\nWir erkennen an der Ausgabe der ersten Zeilen wie genau ein Wert vom datetime-Datentyp aufgebaut ist. Es handelt sich um ein standardisiertes Format mit dem Namen ISO-8601, das einer festen Syntax folgt. Der erste Teil stellt das Datum mit seinen Bestandteilen Jahr, Monat und Tag dar, jeweils als vierstellige (Jahr) und zweistellige (Monat, Tag) Zahlen, getrennt mit einem Bindestrich. Danach folgt, getrennt durch ein Leerzeichen, die Uhrzeitangabe. Hier ist das Format wie gewohnt: HH:MM:ss, also jeweils zwei Ziffern fÃ¼r die Stunde, Minute und Sekunde, jeweils durch einen Doppelpunkt getrennt.\nWeil das Format standardisiert ist, gibt es entsprechende Funktionen, mit denen wir jeden Bestandteil extrahieren wollen. Mit der Funktion year() bekommen wir etwa nur das Jahr als Zahl. Ensprechende Funktionen gibt es auch fÃ¼r andere Datums- und Zeitbestandteile. Details zur Arbeit mit Datum und Zeit findet ihr im Kapitel Dates and times aus Wickham, Ã‡etinkaya-Rundel, und Grolemund (2023).\nGleichzeitig kÃ¶nnen wir ein Datum abrunden - klingt komisch? Dabei schneiden wir einfach den Teil des Zeitstempels ab, der unseren gewÃ¼nschten Detailgrad Ã¼berschreitet. Wenn wir etwa eine Analyse auf Monatsbasis erstellen wollen, dann kÃ¶nnen wir jedes Datum auf den jeweils ersten des Monats runden, im dem sich der Zeitstempel befindet:\nts |&gt;\n  mutate(date_month = floor_date(date_time, unit = \"month\"), .keep = \"used\")\n\n# A tibble: 59,500 Ã— 2\n   date_time           date_month         \n   &lt;dttm&gt;              &lt;dttm&gt;             \n 1 2006-01-05 10:50:33 2006-01-01 00:00:00\n 2 2006-01-13 13:47:00 2006-01-01 00:00:00\n 3 2006-01-13 10:18:00 2006-01-01 00:00:00\n 4 2006-01-14 14:24:00 2006-01-01 00:00:00\n 5 2006-01-15 14:44:00 2006-01-01 00:00:00\n 6 2006-01-18 19:30:00 2006-01-01 00:00:00\n 7 2006-01-25 17:37:00 2006-01-01 00:00:00\n 8 2006-02-02 10:52:26 2006-02-01 00:00:00\n 9 2006-02-02 08:39:00 2006-02-01 00:00:00\n10 2006-02-14 14:20:00 2006-02-01 00:00:00\n# â„¹ 59,490 more rows\nIn der Ausgabe seht ihr links das Originaldatum mit allen Details und rechts das abgeschnittene und auf den ersten des jeweiligen Monats gerundete Datum. Das SchÃ¶ne an floor_date() ist, dass es als Ergebnis einen Wert vom gleichen Datentyp erzeugt, also auch ein datetime. Warum ist das gut? Weil wir damit in der Visualisieurung gut klarkommen, wie ihr im nÃ¤chsten Schritt sehen werdet:\nts |&gt;\n  mutate(date_month = floor_date(date_time, \"month\")) |&gt;\n  ggplot() +\n  aes(x = date_month) +\n  geom_bar() +\n  theme_bw() +\n  labs(x = \"Monat\", y = \"Anzahl der BeitrÃ¤ge\")\nSchaut mal auf die x-Achse. FÃ¤llt euch was auf?",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>6</span>Â  <span class='chapter-title'>Zeit</span>"
    ]
  },
  {
    "objectID": "project-2-news/time.html#verteilung-der-beitrÃ¤ge-Ã¼ber-die-zeit",
    "href": "project-2-news/time.html#verteilung-der-beitrÃ¤ge-Ã¼ber-die-zeit",
    "title": "6Â  Zeit",
    "section": "",
    "text": "Wickham, Hadley, Mine Ã‡etinkaya-Rundel, und Garrett Grolemund. 2023. R for data science: import, tidy, transform, visualize, and model data. 2nd edition. Sebastopol, CA: Oâ€™Reilly Media, Inc.",
    "crumbs": [
      "Projekt 2: News",
      "<span class='chapter-number'>6</span>Â  <span class='chapter-title'>Zeit</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html",
    "href": "r-basics/pipe.html",
    "title": "8Â  Pipe-Operator",
    "section": "",
    "text": "8.1 Was macht die Pipe eigentlich?\nWenn ihr Daten analysiert, arbeitet ihr fast nie mit einem Befehl. Stattdessen baut ihr eine kleine Kette aus vielen Schritten: Spalten auswÃ¤hlen, Zeilen filtern, neue Variablen berechnen, sortieren, zusammenfassen und zwischendurch kurz prÃ¼fen, ob alles so aussieht wie gedacht.\nOhne Pipe werden solche Schrittketten schnell unÃ¼bersichtlich. Mit der Pipe schreibt ihr eure Analyse so, dass ihr sie wie einen Text von oben nach unten lesen kÃ¶nnt.\nIn diesem Kapitel klÃ¤ren wir drei Fragen:\nDie wichtigste Regel ist kurz:\nDas sieht zum Beispiel so aus:\nund bedeutet:\nSchauen wir uns das in einem kleinen Beispiel an. Die Funktion nrow() gibt euch die Anzahl Zeilen eines Datensatzes zurÃ¼ck. Ohne Pipe schreibt ihr:\nnrow(tweets)\n\n[1] 58421\nMit Pipe rÃ¼ckt der Datensatz nach links und wird rechts automatisch in nrow() eingesetzt:\ntweets |&gt;\n  nrow()\n\n[1] 58421\nDas Ergebnis einer Pipe muss Ã¼brigens nicht immer ein Tibble bleiben. Nach nrow() ist das Ergebnis eine Zahl, in diesem Datensatz also 58.421. Diese Zahl kÃ¶nnt ihr direkt in den nÃ¤chsten Schritt weiterreichen:\ntweets |&gt;\n  nrow() |&gt;\n  sqrt()\n\n[1] 241.7044\nInhaltlich ist das Beispiel etwas kÃ¼nstlich. Es zeigt aber gut, dass die Pipe einfach Ergebnisse weiterreicht, egal ob es ein Tibble, eine Zahl oder ein Text ist.\nIn AbbildungÂ 8.1 seht ihr das typische Muster, das euch im ganzen Buch immer wieder begegnet: Am Anfang steht ein Datensatz als Tibble, danach folgen mehrere Schritte, am Ende kommt oft eine kurze Ausgabe zur Kontrolle.\nListingÂ 8.1: Am Anfang steht immer ein Tibble, der durch die Pipe weitergereicht wird.\n\n\ntweets |&gt;\n  select(screen_name, favorite_count, retweet_count) |&gt;\n  glimpse()\n\n\n\n\nRows: 58,421\nColumns: 3\n$ screen_name    &lt;chr&gt; \"cem_oezdemir\", \"W_Schmidt_\", \"lisapaus\", \"lisapaus\", \"â€¦\n$ favorite_count &lt;dbl&gt; 0, 0, 3, 11, 25, 93, 154, 448, 0, 1, 2, 2, 58, 103, 266â€¦\n$ retweet_count  &lt;dbl&gt; 23, 10659, 1, 1, 6, 9, 15, 56, 29, 1, 1, 1, 10, 13, 26,â€¦\nIn ListingÂ 8.1 ist tweets der Startpunkt. select() nimmt den Tibble und reduziert ihn auf die gewÃ¼nschten Spalten. glimpse() bekommt dann das Ergebnis und zeigt euch schnell Struktur und erste Werte.\nWenn ihr es formeller mÃ¶gt, kÃ¶nnt ihr euch eine Pipe-Kette wie eine verschachtelte Funktionsanwendung vorstellen:",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>Â  <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html#was-macht-die-pipe-eigentlich",
    "href": "r-basics/pipe.html#was-macht-die-pipe-eigentlich",
    "title": "8Â  Pipe-Operator",
    "section": "",
    "text": "Die Pipe nimmt das Ergebnis links und setzt es rechts als erstes Argument ein.\n\n\nx |&gt; f(a, b)\n\nf(x, a, b)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildungÂ 8.1: Die Pipe leitet das Ergebnis des ersten Befehls an den zweiten Befehl weiter.\n\n\n\n\n\n\n\n\n\n\n\nOhne Pipe\nMit Pipe\n\n\n\n\nf(g(h(x)))\nx |&gt; h() |&gt; g() |&gt; f()",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>Â  <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html#warum-die-pipe-euren-code-besser-macht",
    "href": "r-basics/pipe.html#warum-die-pipe-euren-code-besser-macht",
    "title": "8Â  Pipe-Operator",
    "section": "8.2 Warum die Pipe euren Code besser macht",
    "text": "8.2 Warum die Pipe euren Code besser macht\nDie Pipe hilft euch vor allem bei drei Dingen:\n\nLesbarkeit: Ihr kÃ¶nnt den Code von oben nach unten lesen.\nWartbarkeit: Ihr kÃ¶nnt einzelne Schritte leicht austauschen.\nStruktur: Jeder Schritt steht in einer eigenen Zeile.\n\nDas merkt ihr spÃ¤testens dann, wenn eine Transformation etwas lÃ¤nger wird. Ohne Pipe wird daraus schnell ein Klammermonster:\n\n\n\n\nListingÂ 8.2: Ohne die Pipe werden komplexe Transformationen schnell unÃ¼bersichtlich.\n\n\nhead(\n  arrange(\n    select(\n      filter(\n        mutate(\n          filter(tweets, !is_retweet),\n          is_top_tweet = retweet_count &gt;= quantile(retweet_count, 0.99)\n        ),\n        is_top_tweet\n      ),\n      retweet_count, screen_name, text\n    ),\n    -retweet_count\n  ),\n  5\n)\n\n\n\n\n# A tibble: 5 Ã— 3\n  retweet_count screen_name     text                                            \n          &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;                                           \n1         12652 Bundeskanzler   Der russische Ãœberfall markiert eine Zeitenwendâ€¦\n2          8032 Bundeskanzler   The Russian invasion marks a turning point. It â€¦\n3          7152 ABaerbockArchiv Klimakrise ist jetzt. HÃ¶ren wir auf, nur zu redâ€¦\n4          5407 ABaerbock       #MohammadMehdiKarami &amp; #MohammadHosseini - â€¦\n5          5363 Karl_Lauterbach Ich mÃ¶chte mich bei allen bedanken, die mich alâ€¦\n\n\nBeim ersten Blick wirkt das wie ein RÃ¤tsel. Der Code funktioniert, aber um zu verstehen, was passiert, mÃ¼sst ihr von innen nach auÃŸen lesen. Die eigentliche Schrittfolge ist:\nfilter (6) â†’ mutate (5) â†’ filter (4) â†’ select (3) â†’ arrange (2) â†’ head (1)\nMit Pipe schreibt ihr genau diese Reihenfolge direkt so auf, wie ihr sie gedanklich sowieso abarbeitet:\n\n\n\n\nListingÂ 8.3: Die Pipe gibt eine klare Struktur, macht den Code lesbar und erlaubt schnelle Ã„nderungen.\n\n\ntweets |&gt;\n  filter(!is_retweet) |&gt;\n  mutate(is_top_tweet = retweet_count &gt;= quantile(retweet_count, 0.99)) |&gt;\n  filter(is_top_tweet) |&gt;\n  select(retweet_count, screen_name, text) |&gt;\n  arrange(-retweet_count) |&gt;\n  head(5)\n\n\n\n\n# A tibble: 5 Ã— 3\n  retweet_count screen_name     text                                            \n          &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;                                           \n1         12652 Bundeskanzler   Der russische Ãœberfall markiert eine Zeitenwendâ€¦\n2          8032 Bundeskanzler   The Russian invasion marks a turning point. It â€¦\n3          7152 ABaerbockArchiv Klimakrise ist jetzt. HÃ¶ren wir auf, nur zu redâ€¦\n4          5407 ABaerbock       #MohammadMehdiKarami &amp; #MohammadHosseini - â€¦\n5          5363 Karl_Lauterbach Ich mÃ¶chte mich bei allen bedanken, die mich alâ€¦\n\n\nDas Ergebnis ist identisch, aber ihr kÃ¶nnt jetzt jeden Schritt einzeln lesen. AuÃŸerdem kÃ¶nnt ihr sehr schnell ausprobieren, welchen Effekt ein Schritt hat. Kommentiert ihn dafÃ¼r einfach temporÃ¤r aus:\n\ntweets |&gt;\n  # filter(!is_retweet) |&gt;\n  mutate(is_top_tweet = retweet_count &gt;= quantile(retweet_count, 0.99)) |&gt;\n  filter(is_top_tweet) |&gt;\n  select(retweet_count, screen_name, text) |&gt;\n  arrange(-retweet_count) |&gt;\n  head(5)\n\n# A tibble: 5 Ã— 3\n  retweet_count screen_name     text                                            \n          &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;                                           \n1        434571 cem_oezdemir    RT @Schwarzenegger: I love the Russian people. â€¦\n2        276452 klara_geywitz   RT @Twitter: Twitter is built by immigrants of â€¦\n3        271059 SteffiLemke     RT @KamalaHarris: While I may be the first womaâ€¦\n4        188454 ABaerbockArchiv RT @verygooster: every woman in this pic tho htâ€¦\n5        169437 W_Schmidt_      RT @MarcusRashford: https://t.co/bs9lksGM4q     \n\n\nWenn ihr Retweets nicht herausfiltert, landet ein geteilter Tweet von Cem Ã–zdemir auf Platz 1. Genau solche schnellen Checks sind in der explorativen Datenanalyse Gold wert.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>Â  <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html#sonderfÃ¤lle-wenn-es-nicht-das-erste-argument-ist",
    "href": "r-basics/pipe.html#sonderfÃ¤lle-wenn-es-nicht-das-erste-argument-ist",
    "title": "8Â  Pipe-Operator",
    "section": "8.3 SonderfÃ¤lle: wenn es nicht das erste Argument ist",
    "text": "8.3 SonderfÃ¤lle: wenn es nicht das erste Argument ist\nIm Tidyverse klappt die Pipe fast immer reibungslos, weil die Funktionen so gestaltet sind, dass der Datensatz als erstes Argument kommt. Manchmal ist das aber anders, vor allem bei Base-R-Funktionen.\nNehmen wir an, ihr wollt einen Text aus einem Online-Fragebogen bereinigen. Da entstehen schnell doppelte Leerzeichen, die euch spÃ¤ter beim Auswerten nerven kÃ¶nnen.\n\ntext &lt;- \"Jemand  hat unsaubere Werte   eingegeben. \"\n\ntext |&gt;\n  trimws() |&gt;\n  tolower() |&gt;\n  (\\(x) gsub(\"[[:punct:]]+\", \"\", x))() |&gt;\n  (\\(x) gsub(\"[[:space:]]+\", \" \", x))()\n\n[1] \"jemand hat unsaubere werte eingegeben\"\n\n\ngsub() (global substitute) ersetzt alle Vorkommnisse eines gesuchten Teilstrings durch einen anderen String. Im Beispiel entfernt die erste Ersetzung Satzzeichen. Die zweite fasst mehrere Leerzeichen zu einem einzelnen zusammen.\nDer Haken ist: Bei gsub() ist der Text, in dem ersetzt werden soll, das dritte Argument. Die Pipe kann ihn also nicht automatisch als erstes Argument einsetzen. Die LÃ¶sung ist eine anonyme Funktion \\(x) ..., in der ihr selbst festlegt, wo x eingesetzt wird.\nWenn ihr solche Dinge hÃ¤ufiger macht, lohnt sich oft der Griff zu einer Tidyverse-Variante. Das Paket stringr bietet dafÃ¼r Funktionen, bei denen der zu bearbeitende Text als erstes Argument kommt:\n\ntext |&gt;\n  str_trim() |&gt;\n  str_to_lower() |&gt;\n  str_remove_all(\"[[:punct:]]+\") |&gt;\n  str_replace_all(\"[[:space:]]+\", \" \")\n\n[1] \"jemand hat unsaubere werte eingegeben\"\n\n\nMerkt euch: Wenn es eine passende Tidyverse-Funktion gibt, ist das Piping meistens am angenehmsten. Wenn nicht, kÃ¶nnt ihr mit anonymen Funktionen trotzdem sauber weiter pipen.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>Â  <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "r-basics/pipe.html#kurz-zusammengefasst",
    "href": "r-basics/pipe.html#kurz-zusammengefasst",
    "title": "8Â  Pipe-Operator",
    "section": "8.4 Kurz zusammengefasst",
    "text": "8.4 Kurz zusammengefasst\n\nDie Pipe |&gt; reicht das Ergebnis links an den nÃ¤chsten Schritt rechts weiter.\nStandardmÃ¤ÃŸig wird der linke Wert als erstes Argument eingesetzt.\nIn lÃ¤ngeren Transformationen bringt die Pipe Lesbarkeit und macht Experimente leicht.\nWenn eine Funktion den Wert nicht als erstes Argument erwartet, helfen anonyme Funktionen oder Tidyverse-Alternativen.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>8</span>Â  <span class='chapter-title'>Pipe-Operator</span>"
    ]
  },
  {
    "objectID": "appendix/appendix-a-scraping.html",
    "href": "appendix/appendix-a-scraping.html",
    "title": "Anhang A: Scraping",
    "section": "",
    "text": "In diesem Anhang findest du eine detaillierte Beschreibung der Python-Skripte, die fÃ¼r die Erstellung des Datensatzes aus Tagesschau-BeitrÃ¤ge verwendet wurden. Diese Skripte wurden entwickelt, um die NachrichtenbeitrÃ¤ge von Tagesschau.de zu sammeln und in einem strukturierten Format zu speichern.",
    "crumbs": [
      "Anhang A: Scraping"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Quellen",
    "section": "",
    "text": "Huntington-Klein, Nick. 2026. The Effect: An Introduction to\nResearch Design and Causality. Second edition. A\nChapman & Hall Book. Boca\nRaton London New York: CRC Press.\n\n\nWickham, Hadley, Mine Ã‡etinkaya-Rundel, and Garrett Grolemund. 2023.\nR for Data Science: Import, Tidy, Transform, Visualize, and Model\nData. 2nd edition. Sebastopol, CA: Oâ€™Reilly Media, Inc.",
    "crumbs": [
      "Quellen"
    ]
  }
]