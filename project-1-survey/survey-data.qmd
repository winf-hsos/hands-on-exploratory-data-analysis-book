# Umfragedaten {#sec-surveys-data}

In diesem Projekt geht es um die Analyse eines Umfragedatensatzes. Umfragen sind ein praktisches Werkzeug, wenn wir etwas √ºber Einstellungen, Pr√§ferenzen oder Verhalten von Menschen herausfinden wollen ‚Äì und genau solche Datens√§tze begegnen euch sp√§ter auch im Job ziemlich h√§ufig.

Bevor wir loslegen, eine Leitfrage: Wenn ihr eine Tabelle mit hunderten Spalten vor euch habt ‚Äì woher wisst ihr eigentlich, *was* ihr da seht? Was ist eine Zeile? Was ist eine Spalte? Und wie k√∂nnt ihr schnell pr√ºfen, ob die Daten √ºberhaupt korrekt in R angekommen sind? Genau darum geht es in diesem Abschnitt.

::: {.callout-note appearance="simple"}

## Lernziele in diesem Abschnitt

::: {.reuse #learning-objectives}

- Wie lade ich einen Datensatz mit R?
- Welche Metainformationen (Kontext) sollte ich zu einem Datensatz kennen?
- Wie finde ich heraus, wie viele Beobachtungen und Variablen in den Daten stecken?
- Welche Werkzeuge helfen mir, Variablen schnell zu √ºberblicken?
- Wie pr√ºfe ich, welche Werte in einer Variable vorkommen?

:::

:::

## Daten laden mit R

In jedem Projekt steht am Anfang das Laden der Daten. In diesem Buch gehen wir davon aus, dass ein Datensatz bereits erhoben wurde. Die Datenerhebung ist nicht direkt Bestandteil dieses Buches ‚Äì es geht prim√§r um die Daten*analyse*.

Die Umfrageergebnisse wurden mit der Software [Limesurvey](https://www.limesurvey.org/) erhoben und als CSV-Datei exportiert. Wenn ihr das GitHub-Repository f√ºr dieses Buch auf euren Rechner heruntergeladen habt, dann liegen die Daten im Ordner `/data` und k√∂nnen so geladen werden:

```{r}
#| eval: false
#| label: lst-surveys-load-data
library(tidyverse)
survey <- read_csv("data/mds12_schoko_milch.csv")
```

::: {.callout-warning appearance="simple"}
## Achtet auf den Unterstrich

Bitte achtet auf die Verwendung der richtigen Funktion `read_csv`. Es gibt in R auch eine Funktion mit dem Namen `read.csv`, die sehr √§hnlich ist, aber keinen Tibble erzeugt. Wir verwenden in diesem Buch durchgehend das Tidyverse und Tibbles.
:::

Nach Ausf√ºhrung des Codeblocks stehen die Daten auf dem Objekt `survey` als Tibble bereit. Es ist eine gute Idee, f√ºr h√§ufig verwendete Objekte kurze, aber sprechende Namen zu w√§hlen ‚Äì `survey` ist hier ein guter Kompromiss.

Zum Laden der Daten geh√∂rt immer auch ein kurzer Reality-Check: Sind wirklich alle Beobachtungen (Zeilen) und Variablen (Spalten) da? Genau diese Frage beantworten wir im n√§chsten Abschnitt.

::: {.callout-note appearance="simple"}
## Mehr zum Laden von Daten laden (auch weitere Formate)

An dieser Stelle gehen wir nicht tiefer auf das Laden von Daten und andere Formate ein. Einen detaillierten Einblick findet ihr in @sec-basics-load-data.
:::

```{r}
#| include: false
source("project-1-survey/setup.R")

n <- nrow(survey)
n_fmt <- format(n, big.mark = ".", decimal.mark = ",")
```

## Kontext und Metainformationen

::: {.reuse #slides-setup}
Stellt euch vor, ihr bekommt eine Excel-Datei per Mail ‚Äì ohne Begleittext. Ihr k√∂nnt sie √∂ffnen, aber ihr wisst nicht, wer befragt wurde, wann die Erhebung stattgefunden hat oder was die Antwortcodes bedeuten. Ihr *k√∂nnt* dann zwar rechnen, aber ihr lauft Gefahr, das Falsche zu interpretieren. Ein paar Begleitinformationen in der E-Mail w√§ren daher nicht schlecht. Vielleicht so etwas:
:::

*"Der verwendete Datensatz wurde am Fachgebiet Agrar√∂konomie der Hochschule Osnabr√ºck unter Leitung von Prof. Dr. Ulrich Enneking im Jahr 2025 erhoben. In einer umfangreichen, mehrteiligen Online-Umfrage wurden deutschlandweit Menschen zu Einstellungen und Kaufverhalten bei Lebensmitteln befragt. An der Umfrage haben `r n_fmt` Personen teilgenommen."*

Solche Informationen nennen wir *Metainformationen* (meta = √ºber) oder *Kontextinformationen*. H√§ufig lassen sie sich als W‚ÄëFragen formulieren. @tbl-survey-context fasst die wichtigsten f√ºr unseren Datensatz zusammen:

| W‚ÄëFrage | Antwort |
|:---|:----|
| Wer hat die Daten erhoben? | Prof. Dr. Enneking |
| Wie wurden die Daten erhoben? | Online-Umfrage |
| Wann wurden die Daten erhoben? | 2025 |
| Wo wurden die Daten erhoben? | online |
| Wer wurde befragt? | `r n_fmt` Menschen deutschlandweit |
| Was wurde erhoben? | Einstellungen und Kaufverhalten bei Lebensmitteln |

: Metainformationen zum Umfragedatensatz {#tbl-survey-context}

Eine Frage ist dabei besonders wichtig, weil sie bestimmt, *wie* wir sp√§ter Zahlen interpretieren: Was repr√§sentiert eine Zeile in den Daten? Was sehen wir eigentlich, wenn wir eine Zeile betrachten? Auf diese Frage brauchen wir eine klare Antwort, bevor wir mit der Analyse beginnen. Manchmal kann man es durch genaues Hinschauen erraten ‚Äì aber der Schein kann tr√ºgen. Wenn wir die Daten nicht selbst erhoben haben, sollten wir diese Information aus sicherer Quelle bekommen. In diesem Beispiel habe ich nachgefragt: Eine Zeile entspricht den Antworten *einer Person* auf die Online‚ÄëUmfrage. In der empirischen Forschung sprechen wir dann von *Beobachtungen*.

> Empirical research is any research that uses structured observations from the real world to attempt to answer questions. [@effect_2026]

Wenn wir wissen, dass jede Zeile eine befragte Person ist, k√∂nnen wir auch sauber begr√ºnden, warum die Anzahl der Zeilen gleich der Anzahl der Teilnehmenden ist.

## Dimensionierung der Daten

Es gibt mehrere Wege, die Anzahl der Beobachtungen zu bestimmen. Ein sehr direkter ist `count()`: Wenn wir `count()` ohne Variable aufrufen, z√§hlt R schlicht die Zeilen.

```{r}
#| label: lst-surveys-count
survey |>
  count() # <1>
```
1. Der Befehl `count()` z√§hlt die Beobachtungen (Zeilen) in einem Datensatz.

Eine zweite, oft sehr praktische M√∂glichkeit ist: Gebt einfach den Namen des Tibbles aus. Tibbles zeigen euch direkt eine kompakte Zusammenfassung inkl. Dimensionen (`Zeilen x Spalten`) und eine Vorschau.

```{r}
#| label: lst-surveys-tibble-name
#| lst-cap: "Wir k√∂nnen einfach den Namen des Tibbles aufrufen, um an wichtige Informationen zu kommen."
survey
```

In der ersten Zeile der Ausgabe steht die Dimensionierung der Daten. Wir bekommen also nicht nur die Information, wie viele Beobachtungen (`r n_fmt`) vorhanden sind, sondern auch, wie viele Variablen der Datensatz hat (`r survey |> ncol()`). Danach folgen die ersten Zeilen (und so viele Spalten, wie auf die Konsole passen). Tibbles achten darauf, die Konsole nicht komplett mit Text zu fluten, und schneiden daher irgendwann ab.

Manchmal wollen wir die Anzahl Zeilen und Spalten nicht nur wissen, sondern weiterverwenden. Wir k√∂nnen sie dann auf Objekten speichern:

```{r}
rows <- nrow(survey)
cols <- ncol(survey)

print(str_glue("Der Datensatz hat {rows} Zeilen und {cols} Spalten."))
```

## Variablen (Spalten)

Neben der Frage ‚ÄûWas ist eine Zeile?‚Äú ist die zweite Kernfrage: ‚ÄûWas misst jede Spalte?‚Äú In Umfragen steckt hinter fast jeder Frage (und oft hinter jeder Antwortoption) eine eigene Variable ‚Äì deshalb werden solche Datens√§tze schnell sehr ‚Äûspaltenreich‚Äú.

> A variable, in the context of empirical research, is a bunch of observations of the same measurement. [@effect_2026]

Beobachtungen stellen wir typischerweise horizontal (in Zeilen) dar, Variablen vertikal (in Spalten).

![Beobachtungen repr√§sentieren wir als Zeilen, Variablen als Spalten.](/images/observation_variable.png){#fig-surveys-observation-variable .lightbox}

Im Idealfall gibt es zu einem Datensatz ein *Data Dictionary* (oder Codebuch): eine Art W√∂rterbuch, in dem jede Variable aufgef√ºhrt und inhaltlich erl√§utert ist. Das ist Gold wert ‚Äì denn aus reinen Spaltennamen wie `q001hheinkauf` k√∂nnt ihr die Bedeutung oft nicht zuverl√§ssig ableiten.

Damit ihr trotzdem schnell arbeitsf√§hig werdet, schauen wir uns jetzt Werkzeuge an, mit denen ihr Variablen in R systematisch ‚Äûabklopfen‚Äú k√∂nnt:

- Wie viele Variablen gibt es?
- Welche Namen und Datentypen haben sie?
- Welche Werte kommen in einer Variable √ºberhaupt vor?

### Wie viele Variablen?

Die Anzahl der Variablen habt ihr bereits √ºber die Tibble-Ausgabe gesehen. Ihr k√∂nnt sie aber auch direkt als Wert auslesen. Hier die Variante mit der Pipe:

```{r}
survey |>
  ncol()
```

Den Wert k√∂nnt ihr auf einem neuen Objekt speichern und sp√§ter wiederverwenden , das ist in Skripten h√§ufig n√ºtzlich:

```{r}
variable_count <- ncol(survey)
print(str_glue("Der Datensatz hat {variable_count} Variablen.")) # <1>
```
1. Mit `str_glue()` k√∂nnt ihr Zeichenketten mit Platzhaltern versehen, die bei der Ausf√ºhrung mit Werten ersetzt werden.

### Namen, Typen, erste Werte: `select()` + `glimpse()`

Schauen wir uns f√ºrs Erste nur die ersten 10 Variablen im Datensatz an:

```{r}
survey |>
  select(1:10) |> # <1>
  glimpse() # <2>
```
1. Mit `select()` k√∂nnt ihr Variablen ausw√§hlen. Die Notation `1:10` bedeutet: *Variablen an Position 1 bis 10*.
2. Mit `glimpse()` bekommt ihr schnell eine √úbersicht der Namen, Datentypen und ersten Werte der Variablen.

Hier steckt direkt ein wichtiges Muster drin: Wir bauen eine kleine ‚ÄûBefehlskette‚Äú. Das etwas merkw√ºrdig aussehende Symbol `|>` (Pipe) sorgt daf√ºr, dass das Ergebnis links an den n√§chsten Befehl rechts √ºbergeben wird. Eine dedizierte Einf√ºhrung in die Pipe findet ihr in @sec-survey-pipe.

Mit der Flexibilit√§t einer Programmiersprache wie R k√∂nnt ihr jede beliebige Menge an Spalten ausw√§hlen ‚Äì zum Beispiel auch die letzten 10:

```{r}
survey |>
  select(tail(everything(), 10))
```

Mit `tail()` ermitteln wir die letzten `n` Elemente einer Liste. `everything()` gibt uns (innerhalb von `select()`) die Liste aller Spalten. Der Ausdruck l√§sst sich also √ºbersetzen als: *Gib mir die letzten 10 Elemente aus der Liste aller Spalten.* Gerade bei Umfragen mit vielen Spalten ist dieses gezielte Ausw√§hlen extrem n√ºtzlich. Noch mehr M√∂glichkeiten, Spalten auszuw√§hlen, lernen wir im Verlauf des Projekts und im dedizierten @sec-basics-select.

::: {.callout-note appearance="simple"}
## Variablen haben eine feste Position

Variablen (Spalten) haben eine feste Reihenfolge und Position in einem Datensatz. Ihr k√∂nnt eine Spalte daher nicht nur √ºber ihren Namen, sondern auch √ºber ihre Position ansprechen.
:::

### Welchen Wertebereich hat eine Variable?

`glimpse()` ist super, um *schnell* einen Eindruck zu bekommen ‚Äì aber es zeigt euch nur die ersten Werte. Wenn ihr wirklich wissen wollt, welche Auspr√§gungen vorkommen, m√ºsst ihr gezielt nachsehen.

Nehmen wir die Variable `q001hheinkauf`. Sie geh√∂rt zur Frage, ob die teilnehmende Person f√ºr den Lebensmitteleinkauf hauptverantwortlich ist oder ob die Aufgabe mit einer anderen Person geteilt wird. Im Codebuch zur Umfrage lesen wir nach, dass "1" f√ºr "Ich selbst und eine andere Person" steht, w√§hrend "2" f√ºr  "Haupts√§chlich ich selbst" steht. Der Wert "0" st√ºnde f√ºr "Fast immer eine andere Person".  Aber kommen wirklich nur diese Werte vor? Oder kommen √ºberhaupt alle vor?

Zuerst k√∂nnen wir uns die Spalte als Tibble ausgeben lassen:

```{r}
survey |>
  select(q001hheinkauf)
```

Standardm√§√üig zeigt R dabei nur die ersten 10 Zeilen. Das k√∂nnt ihr √§ndern:

```{r}
survey |>
  select(q001hheinkauf) |>
  print(n = 20)
```

Alle Zeilen auszugeben w√ºrde dieses Kapitel sehr lang machen und w√§re gleichzeitig aufw√§ndig zu pr√ºfen. Um dennoch sicher zu wissen, welche Werteauspr√§gungen existieren, k√∂nnen wir uns die eindeutigen Werte ausgeben lassen:

```{r}
survey |>
  distinct(q001hheinkauf)
```

Eine kleine √úberraschung, denn die "0" ist nicht vertreten. Hat scheinbar niemand geantwortet. Wenn ihr zus√§tzlich wissen wollt, wie h√§ufig die Auspr√§gungen angekreuzt wurden:

```{r}
survey |>
  count(q001hheinkauf)
```

Die Funktion `count()` gruppiert die Daten nach der √ºbergebenen Variable und z√§hlt die Beobachtungen pro Gruppe. Wir stecken schon mittem in der Analyse der Daten ü§ì.

::: {.callout-note appearance="simple"}
## Aggregieren von Daten

Die Funktion `count()` ist eine Aggregationsfunktion. Eine dedizierte Einf√ºhrung, wie man mit R und dem `dplyr`‚ÄëPaket Daten zusammenfasst, findet ihr in @sec-basics-summarize.
:::

Und weil es gerade passt: Wenn wir Daten analysieren, dann bevorzugen wir in dem allermeisten F√§llen eine aussagekr√§ftige Visualisierung √ºber eine tabellarische Ausgabe. Die H√§ufigkeiten der beiden Antwortm√∂glichkeiten k√∂nnen wir wunderbar als Balkendiagramm visualisieren:

```{r}
survey |>
  count(q001hheinkauf) |>
  ggplot() +
  aes(x = q001hheinkauf, y = n) +
  geom_col()
```

Zugegeben: Das Balkendiagramm ist verbesserungsw√ºrdig, dennoch zeigt es einen wichtigen Aspekt der explorativen Datenanalyse und warum R daf√ºr so gut geeignet ist. Mit nur drei Zeilen Code erstellen wir ein Balkendiagramm, das uns die Verh√§ltnisse der Anworten zur ersten Frage im Datensatz visuell aufzeigt. Und das Diagramm ist inhaltlich korrekt, daf√ºr sorgt die Bibliothek `ggplot2`, die wir hier verwenden. Es ist daf√ºr nicht wirklich ansprechend (schaut etwas mal die Labels auf der x-Achse an). Aber darum geht es in der explorativen Datenanalyse nicht. Wir wollen schhnell Ergebnisse sehen und flexibel in den Daten w√ºhlen k√∂nnen. Das funktioniert mit R und dem Tidyverse perfekt!

## Beobachtungen (Zeilen)

Was f√ºr Variablen gilt, gilt auch f√ºr Zeilen: Jede hat eine feste Position. Bei Zeilen nennen wir das auch die *row number* (Zeilennummer). Mit `row_number()` k√∂nnt ihr diese Position abfragen und damit gezielt Zeilen ausw√§hlen.

```{r}
survey |>
  select(1:10) |>
  filter(row_number() <= 10) # <1>
```
1. Mit `row_number()` bekommen wir die Position (Zeilennummer) einer Beobachtung.

Die Funktion `filter()` verwenden wir, um Beobachtungen nach Kriterien einzugrenzen ‚Äì zum Beispiel um nur weibliche Personen zu betrachten. Mit `row_number()` k√∂nnt ihr stattdessen nach Position filtern, z. B. um ‚ÄûBeispielzeilen‚Äú f√ºr einen ersten Blick zu nehmen.

Statt ‚Äûkleiner-gleich‚Äú (`<=`) k√∂nnt ihr nat√ºrlich auch andere Operatoren verwenden:

```{r}
survey |>
  filter(row_number() == 42) |>
  select(q004geschlecht)
```

Damit habt ihr jetzt die wichtigsten Werkzeuge f√ºr den Start: Daten laden, Kontext verstehen, Dimensionen pr√ºfen, Variablen √ºberblicken und Wertebereiche testen. Im n√§chsten Schritt geht es darum, die Variablen inhaltlich zu interpretieren (Codebuch/Data Dictionary) und die Daten f√ºr Analysen vorzubereiten.

